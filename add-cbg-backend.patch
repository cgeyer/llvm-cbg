From ec00009a48f303f135705aff0bc4e405e2996979 Mon Sep 17 00:00:00 2001
From: Clemens Bernhard Geyer <clemens.geyer@gmail.com>
Date: Thu, 16 Feb 2012 10:08:03 +0100
Subject: [PATCH 2/2] Added cbg target.

---
 configure                                   |   16 +-
 include/llvm/ADT/Triple.h                   |    1 +
 lib/Support/Triple.cpp                      |    1 +
 lib/Target/cbg/.gitignore                   |    5 +
 lib/Target/cbg/CMakeLists.txt               |   28 +
 lib/Target/cbg/DelaySlotFiller.cpp          |  335 +++++
 lib/Target/cbg/FPMover.cpp                  |  144 ++
 lib/Target/cbg/Makefile                     |   23 +
 lib/Target/cbg/PredecessorList.cpp          |  102 ++
 lib/Target/cbg/PredecessorList.h            |   71 +
 lib/Target/cbg/README.txt                   |   59 +
 lib/Target/cbg/TargetInfo/CMakeLists.txt    |    7 +
 lib/Target/cbg/TargetInfo/Makefile          |   15 +
 lib/Target/cbg/TargetInfo/cbgTargetInfo.cpp |   19 +
 lib/Target/cbg/cbg.h                        |  129 ++
 lib/Target/cbg/cbg.td                       |   95 ++
 lib/Target/cbg/cbgAsmPrinter.cpp            |  289 ++++
 lib/Target/cbg/cbgCallingConv.td            |   36 +
 lib/Target/cbg/cbgFrameLowering.cpp         |   80 ++
 lib/Target/cbg/cbgFrameLowering.h           |   41 +
 lib/Target/cbg/cbgHWLoop.cpp                |  639 +++++++++
 lib/Target/cbg/cbgISelDAGToDAG.cpp          |  216 +++
 lib/Target/cbg/cbgISelLowering.cpp          | 1311 ++++++++++++++++++
 lib/Target/cbg/cbgISelLowering.h            |  111 ++
 lib/Target/cbg/cbgInstrFormats.td           |  114 ++
 lib/Target/cbg/cbgInstrInfo.cpp             |  346 +++++
 lib/Target/cbg/cbgInstrInfo.h               |  126 ++
 lib/Target/cbg/cbgInstrInfo.td              | 1328 +++++++++++++++++++
 lib/Target/cbg/cbgMCAsmInfo.cpp             |   34 +
 lib/Target/cbg/cbgMCAsmInfo.h               |   29 +
 lib/Target/cbg/cbgMachineFunctionInfo.h     |   47 +
 lib/Target/cbg/cbgPredicationPass.cpp       | 1917 +++++++++++++++++++++++++++
 lib/Target/cbg/cbgRegisterInfo.cpp          |  134 ++
 lib/Target/cbg/cbgRegisterInfo.h            |   59 +
 lib/Target/cbg/cbgRegisterInfo.td           |  205 +++
 lib/Target/cbg/cbgSelectionDAGInfo.cpp      |   23 +
 lib/Target/cbg/cbgSelectionDAGInfo.h        |   31 +
 lib/Target/cbg/cbgSubtarget.cpp             |   35 +
 lib/Target/cbg/cbgSubtarget.h               |   66 +
 lib/Target/cbg/cbgTargetMachine.cpp         |   78 ++
 lib/Target/cbg/cbgTargetMachine.h           |   78 ++
 41 files changed, 8419 insertions(+), 4 deletions(-)
 create mode 100644 lib/Target/cbg/.gitignore
 create mode 100644 lib/Target/cbg/CMakeLists.txt
 create mode 100644 lib/Target/cbg/DelaySlotFiller.cpp
 create mode 100644 lib/Target/cbg/FPMover.cpp
 create mode 100644 lib/Target/cbg/Makefile
 create mode 100644 lib/Target/cbg/PredecessorList.cpp
 create mode 100644 lib/Target/cbg/PredecessorList.h
 create mode 100644 lib/Target/cbg/README.txt
 create mode 100644 lib/Target/cbg/TargetInfo/CMakeLists.txt
 create mode 100644 lib/Target/cbg/TargetInfo/Makefile
 create mode 100644 lib/Target/cbg/TargetInfo/cbgTargetInfo.cpp
 create mode 100644 lib/Target/cbg/cbg.h
 create mode 100644 lib/Target/cbg/cbg.td
 create mode 100644 lib/Target/cbg/cbgAsmPrinter.cpp
 create mode 100644 lib/Target/cbg/cbgCallingConv.td
 create mode 100644 lib/Target/cbg/cbgFrameLowering.cpp
 create mode 100644 lib/Target/cbg/cbgFrameLowering.h
 create mode 100644 lib/Target/cbg/cbgHWLoop.cpp
 create mode 100644 lib/Target/cbg/cbgISelDAGToDAG.cpp
 create mode 100644 lib/Target/cbg/cbgISelLowering.cpp
 create mode 100644 lib/Target/cbg/cbgISelLowering.h
 create mode 100644 lib/Target/cbg/cbgInstrFormats.td
 create mode 100644 lib/Target/cbg/cbgInstrInfo.cpp
 create mode 100644 lib/Target/cbg/cbgInstrInfo.h
 create mode 100644 lib/Target/cbg/cbgInstrInfo.td
 create mode 100644 lib/Target/cbg/cbgMCAsmInfo.cpp
 create mode 100644 lib/Target/cbg/cbgMCAsmInfo.h
 create mode 100644 lib/Target/cbg/cbgMachineFunctionInfo.h
 create mode 100644 lib/Target/cbg/cbgPredicationPass.cpp
 create mode 100644 lib/Target/cbg/cbgRegisterInfo.cpp
 create mode 100644 lib/Target/cbg/cbgRegisterInfo.h
 create mode 100644 lib/Target/cbg/cbgRegisterInfo.td
 create mode 100644 lib/Target/cbg/cbgSelectionDAGInfo.cpp
 create mode 100644 lib/Target/cbg/cbgSelectionDAGInfo.h
 create mode 100644 lib/Target/cbg/cbgSubtarget.cpp
 create mode 100644 lib/Target/cbg/cbgSubtarget.h
 create mode 100644 lib/Target/cbg/cbgTargetMachine.cpp
 create mode 100644 lib/Target/cbg/cbgTargetMachine.h

diff --git a/configure b/configure
index 52bf988..bb10b9d 100755
--- a/configure
+++ b/configure
@@ -1427,9 +1427,9 @@ Optional Features:
                           (default is YES)
   --enable-targets        Build specific host targets: all or
                           target1,target2,... Valid targets are: host, x86,
-                          x86_64, sparc, powerpc, alpha, arm, mips, spu,
-                          xcore, msp430, systemz, blackfin, ptx, cbe, and cpp
-                          (default=all)
+                          x86_64, sparc, cbg, powerpc, alpha, arm, mips, 
+						  spu, xcore, msp430, systemz, blackfin, ptx, cbe, 
+						  and cpp (default=all)
   --enable-cbe-printf-a   Enable C Backend output with hex floating point via
                           %a (default is YES)
   --enable-bindings       Build specific language bindings:
@@ -2394,6 +2394,7 @@ else
   case $target in
   i?86-*)                 llvm_cv_target_arch="x86" ;;
   amd64-* | x86_64-*)     llvm_cv_target_arch="x86_64" ;;
+  cbg*-*)                 llvm_cv_target_arch="cbg" ;;
   sparc*-*)               llvm_cv_target_arch="Sparc" ;;
   powerpc*-*)             llvm_cv_target_arch="PowerPC" ;;
   alpha*-*)               llvm_cv_target_arch="Alpha" ;;
@@ -4848,6 +4849,8 @@ else
   case "$llvm_cv_target_arch" in
     x86)         TARGET_HAS_JIT=1
  ;;
+    cbg)     TARGET_HAS_JIT=0
+ ;;
     Sparc)       TARGET_HAS_JIT=0
  ;;
     PowerPC)     TARGET_HAS_JIT=1
@@ -5056,11 +5059,15 @@ if test "$enableval" = host-only ; then
   enableval=host
 fi
 case "$enableval" in
-  all) TARGETS_TO_BUILD="X86 Sparc PowerPC Alpha ARM Mips CellSPU XCore MSP430 SystemZ Blackfin CBackend CppBackend MBlaze PTX" ;;
+  all) TARGETS_TO_BUILD="X86 cbg PowerPC Alpha ARM Mips CellSPU XCore MSP430 SystemZ Blackfin CBackend CppBackend MBlaze PTX" ;;
+#  all) TARGETS_TO_BUILD="X86 Sparc PowerPC Alpha ARM Mips CellSPU XCore MSP430 SystemZ Blackfin CBackend CppBackend MBlaze PTX" ;;
+#  all) TARGETS_TO_BUILD="cbg Sparc" ;;
+#  all) TARGETS_TO_BUILD="mySparc" ;;
   *)for a_target in `echo $enableval|sed -e 's/,/ /g' ` ; do
       case "$a_target" in
         x86)      TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
         x86_64)   TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
+        cbg)      TARGETS_TO_BUILD="cbg $TARGETS_TO_BUILD" ;;
         sparc)    TARGETS_TO_BUILD="Sparc $TARGETS_TO_BUILD" ;;
         powerpc)  TARGETS_TO_BUILD="PowerPC $TARGETS_TO_BUILD" ;;
         alpha)    TARGETS_TO_BUILD="Alpha $TARGETS_TO_BUILD" ;;
@@ -5078,6 +5085,7 @@ case "$enableval" in
         host) case "$llvm_cv_target_arch" in
             x86)         TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
             x86_64)      TARGETS_TO_BUILD="X86 $TARGETS_TO_BUILD" ;;
+            cbg)         TARGETS_TO_BUILD="cbg $TARGETS_TO_BUILD" ;;
             Sparc)       TARGETS_TO_BUILD="Sparc $TARGETS_TO_BUILD" ;;
             PowerPC)     TARGETS_TO_BUILD="PowerPC $TARGETS_TO_BUILD" ;;
             Alpha)       TARGETS_TO_BUILD="Alpha $TARGETS_TO_BUILD" ;;
diff --git a/include/llvm/ADT/Triple.h b/include/llvm/ADT/Triple.h
index e6dcc23..819087f 100644
--- a/include/llvm/ADT/Triple.h
+++ b/include/llvm/ADT/Triple.h
@@ -57,6 +57,7 @@ public:
     ppc64,   // PPC64: powerpc64, ppu
     sparc,   // Sparc: sparc
     sparcv9, // Sparcv9: Sparcv9
+    cbg,     // CBG
     systemz, // SystemZ: s390x
     tce,     // TCE (http://tce.cs.tut.fi/): tce
     thumb,   // Thumb: thumb, thumbv.*
diff --git a/lib/Support/Triple.cpp b/lib/Support/Triple.cpp
index 36edf6e..b25533d 100644
--- a/lib/Support/Triple.cpp
+++ b/lib/Support/Triple.cpp
@@ -34,6 +34,7 @@ const char *Triple::getArchTypeName(ArchType Kind) {
   case ppc:     return "powerpc";
   case sparc:   return "sparc";
   case sparcv9: return "sparcv9";
+  case cbg:     return "cbg";
   case systemz: return "s390x";
   case tce:     return "tce";
   case thumb:   return "thumb";
diff --git a/lib/Target/cbg/.gitignore b/lib/Target/cbg/.gitignore
new file mode 100644
index 0000000..10bf780
--- /dev/null
+++ b/lib/Target/cbg/.gitignore
@@ -0,0 +1,5 @@
+# ignore files generated by table generator
+*.inc
+
+# ignore release directory
+Release/
diff --git a/lib/Target/cbg/CMakeLists.txt b/lib/Target/cbg/CMakeLists.txt
new file mode 100644
index 0000000..74ca3a0
--- /dev/null
+++ b/lib/Target/cbg/CMakeLists.txt
@@ -0,0 +1,28 @@
+set(LLVM_TARGET_DEFINITIONS cbg.td)
+
+tablegen(cbgGenRegisterInfo.h.inc -gen-register-desc-header)
+tablegen(cbgGenRegisterNames.inc -gen-register-enums)
+tablegen(cbgGenRegisterInfo.inc -gen-register-desc)
+tablegen(cbgGenInstrNames.inc -gen-instr-enums)
+tablegen(cbgGenInstrInfo.inc -gen-instr-desc)
+tablegen(cbgGenAsmWriter.inc -gen-asm-writer)
+tablegen(cbgGenDAGISel.inc -gen-dag-isel)
+tablegen(cbgGenSubtarget.inc -gen-subtarget)
+tablegen(cbgGenCallingConv.inc -gen-callingconv)
+
+add_llvm_target(cbgCodeGen
+  DelaySlotFiller.cpp
+  FPMover.cpp
+  cbgAsmPrinter.cpp
+  cbgInstrInfo.cpp
+  cbgISelDAGToDAG.cpp
+  cbgISelLowering.cpp
+  cbgFrameLowering.cpp
+  cbgMCAsmInfo.cpp
+  cbgRegisterInfo.cpp
+  cbgSubtarget.cpp
+  cbgTargetMachine.cpp
+  cbgSelectionDAGInfo.cpp
+  )
+
+add_subdirectory(TargetInfo)
diff --git a/lib/Target/cbg/DelaySlotFiller.cpp b/lib/Target/cbg/DelaySlotFiller.cpp
new file mode 100644
index 0000000..15d2c3b
--- /dev/null
+++ b/lib/Target/cbg/DelaySlotFiller.cpp
@@ -0,0 +1,335 @@
+//===-- DelaySlotFiller.cpp - CBG delay slot filler ---------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This is a simple local pass that attempts to fill delay slots with useful
+// instructions. If no instructions can be moved into the delay slot, then a
+// NOP is placed.
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "delay-slot-filler"
+#include "cbg.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetInstrInfo.h"
+#include "llvm/Target/TargetRegisterInfo.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/Statistic.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+STATISTIC(FilledSlots, "Number of delay slots filled");
+
+static cl::opt<bool> DisableDelaySlotFiller(
+  "disable-cbg-delay-filler",
+  cl::init(false),
+  cl::desc("Disable the cbg delay slot filler."),
+  cl::Hidden);
+
+namespace {
+  struct Filler : public MachineFunctionPass {
+    /// Target machine description which we query for reg. names, data
+    /// layout, etc.
+    ///
+    TargetMachine &TM;
+    const TargetInstrInfo *TII;
+
+    static char ID;
+    Filler(TargetMachine &tm) 
+      : MachineFunctionPass(ID), TM(tm), TII(tm.getInstrInfo()) { }
+
+    virtual const char *getPassName() const {
+      return "CBG Delay Slot Filler";
+    }
+
+    bool runOnMachineBasicBlock(MachineBasicBlock &MBB);
+    bool runOnMachineFunction(MachineFunction &F) {
+      bool Changed = false;
+      for (MachineFunction::iterator FI = F.begin(), FE = F.end();
+           FI != FE; ++FI)
+        Changed |= runOnMachineBasicBlock(*FI);
+      return Changed;
+    }
+
+    bool isDelayFiller(MachineBasicBlock &MBB,
+                       MachineBasicBlock::iterator candidate);
+
+    void insertCallUses(MachineBasicBlock::iterator MI,
+                        SmallSet<unsigned, 32>& RegUses);
+
+    void insertDefsUses(MachineBasicBlock::iterator MI,
+                        SmallSet<unsigned, 32>& RegDefs,
+                        SmallSet<unsigned, 32>& RegUses);
+
+    bool IsRegInSet(SmallSet<unsigned, 32>& RegSet,
+                    unsigned Reg);
+
+    bool delayHasHazard(MachineBasicBlock::iterator candidate,
+                        bool &sawLoad, bool &sawStore,
+                        SmallSet<unsigned, 32> &RegDefs,
+                        SmallSet<unsigned, 32> &RegUses);
+
+    MachineBasicBlock::iterator
+    findDelayInstr(MachineBasicBlock &MBB, MachineBasicBlock::iterator slot);
+
+    bool needsUnimp(MachineBasicBlock::iterator I, unsigned &StructSize);
+
+  };
+  char Filler::ID = 0;
+} // end of anonymous namespace
+
+/// createcbgDelaySlotFillerPass - Returns a pass that fills in delay
+/// slots in cbg MachineFunctions
+///
+FunctionPass *llvm::createcbgDelaySlotFillerPass(TargetMachine &tm) {
+  return new Filler(tm);
+}
+
+
+/// runOnMachineBasicBlock - Fill in delay slots for the given basic block.
+/// We assume there is only one delay slot per delayed instruction.
+///
+bool Filler::runOnMachineBasicBlock(MachineBasicBlock &MBB) {
+  bool Changed = false;
+
+  // check, whether current MBB is successor of a hwloop MBB
+  if (MBB.size() == 1) {
+    MachineBasicBlock* predecessor = MBB.getPrevNode();
+    // a hardware loop has to consist of at least two instructions => insert nop
+    if (predecessor->rbegin()->getOpcode() == CBG::HWLOOP) {
+      BuildMI(MBB, MBB.end(), MBB.begin()->getDebugLoc(), TII->get(CBG::NOP));
+      return true;
+    }
+  }
+
+  for (MachineBasicBlock::iterator I = MBB.begin(); I != MBB.end(); ++I)
+    if (I->getDesc().hasDelaySlot()) {
+      MachineBasicBlock::iterator D = MBB.end();
+      MachineBasicBlock::iterator J = I;
+
+      if (!DisableDelaySlotFiller)
+        D = findDelayInstr(MBB, I);
+
+      ++FilledSlots;
+      Changed = true;
+
+      if (D == MBB.end())
+        BuildMI(MBB, ++J, I->getDebugLoc(), TII->get(CBG::NOP));
+      else
+        MBB.splice(++J, &MBB, D);
+      unsigned structSize = 0;
+      if (needsUnimp(I, structSize)) {
+        MachineBasicBlock::iterator J = I;
+        ++J; //skip the delay filler.
+        BuildMI(MBB, ++J, I->getDebugLoc(),
+                TII->get(CBG::UNIMP)).addImm(structSize);
+      }
+    }
+  return Changed;
+}
+
+MachineBasicBlock::iterator
+Filler::findDelayInstr(MachineBasicBlock &MBB,
+                       MachineBasicBlock::iterator slot)
+{
+  SmallSet<unsigned, 32> RegDefs;
+  SmallSet<unsigned, 32> RegUses;
+  bool sawLoad = false;
+  bool sawStore = false;
+
+  MachineBasicBlock::iterator I = slot;
+
+  if (slot->getOpcode() == CBG::RET)
+    return MBB.end();
+
+  if (slot->getOpcode() == CBG::RETL) {
+    --I;
+    if (I->getOpcode() != CBG::RESTORErr)
+      return MBB.end();
+    //change retl to ret
+    slot->setDesc(TII->get(CBG::RET));
+    return I;
+  }
+
+  //Call's delay filler can def some of call's uses.
+  if (slot->getDesc().isCall())
+    insertCallUses(slot, RegUses);
+  else
+    insertDefsUses(slot, RegDefs, RegUses);
+
+  bool done = false;
+
+  while (!done) {
+    done = (I == MBB.begin());
+
+    if (!done)
+      --I;
+
+    // skip debug value
+    if (I->isDebugValue())
+      continue;
+
+
+    if (I->hasUnmodeledSideEffects()
+        || I->isInlineAsm()
+        || I->isLabel()
+        || I->getDesc().hasDelaySlot()
+        || isDelayFiller(MBB, I))
+      break;
+
+    if (delayHasHazard(I, sawLoad, sawStore, RegDefs, RegUses)) {
+      insertDefsUses(I, RegDefs, RegUses);
+      continue;
+    }
+
+    return I;
+  }
+  return MBB.end();
+}
+
+bool Filler::delayHasHazard(MachineBasicBlock::iterator candidate,
+                            bool &sawLoad,
+                            bool &sawStore,
+                            SmallSet<unsigned, 32> &RegDefs,
+                            SmallSet<unsigned, 32> &RegUses)
+{
+
+  if (candidate->isImplicitDef() || candidate->isKill())
+    return true;
+
+  if (candidate->getDesc().mayLoad()) {
+    sawLoad = true;
+    if (sawStore)
+      return true;
+  }
+
+  if (candidate->getDesc().mayStore()) {
+    if (sawStore)
+      return true;
+    sawStore = true;
+    if (sawLoad)
+      return true;
+  }
+
+  for (unsigned i = 0, e = candidate->getNumOperands(); i!= e; ++i) {
+    const MachineOperand &MO = candidate->getOperand(i);
+    if (!MO.isReg())
+      continue; // skip
+
+    unsigned Reg = MO.getReg();
+
+    if (MO.isDef()) {
+      //check whether Reg is defined or used before delay slot.
+      if (IsRegInSet(RegDefs, Reg) || IsRegInSet(RegUses, Reg))
+        return true;
+    }
+    if (MO.isUse()) {
+      //check whether Reg is defined before delay slot.
+      if (IsRegInSet(RegDefs, Reg))
+        return true;
+    }
+  }
+  return false;
+}
+
+
+void Filler::insertCallUses(MachineBasicBlock::iterator MI,
+                            SmallSet<unsigned, 32>& RegUses)
+{
+
+  switch(MI->getOpcode()) {
+  default: llvm_unreachable("Unknown opcode.");
+  case CBG::CALL: break;
+  case CBG::JMPLrr:
+  case CBG::JMPLri:
+    assert(MI->getNumOperands() >= 2);
+    const MachineOperand &Reg = MI->getOperand(0);
+    assert(Reg.isReg() && "JMPL first operand is not a register.");
+    assert(Reg.isUse() && "JMPL first operand is not a use.");
+    RegUses.insert(Reg.getReg());
+
+    const MachineOperand &RegOrImm = MI->getOperand(1);
+    if (RegOrImm.isImm())
+        break;
+    assert(RegOrImm.isReg() && "JMPLrr second operand is not a register.");
+    assert(RegOrImm.isUse() && "JMPLrr second operand is not a use.");
+    RegUses.insert(RegOrImm.getReg());
+    break;
+  }
+}
+
+//Insert Defs and Uses of MI into the sets RegDefs and RegUses.
+void Filler::insertDefsUses(MachineBasicBlock::iterator MI,
+                            SmallSet<unsigned, 32>& RegDefs,
+                            SmallSet<unsigned, 32>& RegUses)
+{
+  for (unsigned i = 0, e = MI->getNumOperands(); i != e; ++i) {
+    const MachineOperand &MO = MI->getOperand(i);
+    if (!MO.isReg())
+      continue;
+
+    unsigned Reg = MO.getReg();
+    if (Reg == 0)
+      continue;
+    if (MO.isDef())
+      RegDefs.insert(Reg);
+    if (MO.isUse())
+      RegUses.insert(Reg);
+
+  }
+}
+
+//returns true if the Reg or its alias is in the RegSet.
+bool Filler::IsRegInSet(SmallSet<unsigned, 32>& RegSet, unsigned Reg)
+{
+  if (RegSet.count(Reg))
+    return true;
+  // check Aliased Registers
+  for (const unsigned *Alias = TM.getRegisterInfo()->getAliasSet(Reg);
+       *Alias; ++ Alias)
+    if (RegSet.count(*Alias))
+      return true;
+
+  return false;
+}
+
+// return true if the candidate is a delay filler.
+bool Filler::isDelayFiller(MachineBasicBlock &MBB,
+                           MachineBasicBlock::iterator candidate)
+{
+  if (candidate == MBB.begin())
+    return false;
+  if (candidate->getOpcode() == CBG::UNIMP)
+    return true;
+  const TargetInstrDesc &prevdesc = (--candidate)->getDesc();
+  return prevdesc.hasDelaySlot();
+}
+
+bool Filler::needsUnimp(MachineBasicBlock::iterator I, unsigned &StructSize)
+{
+  if (!I->getDesc().isCall())
+    return false;
+
+  unsigned structSizeOpNum = 0;
+  switch (I->getOpcode()) {
+  default: llvm_unreachable("Unknown call opcode.");
+  case CBG::CALL: structSizeOpNum = 1; break;
+  case CBG::JMPLrr:
+  case CBG::JMPLri: structSizeOpNum = 2; break;
+  }
+
+  const MachineOperand &MO = I->getOperand(structSizeOpNum);
+  if (!MO.isImm())
+    return false;
+  StructSize = MO.getImm();
+  return true;
+}
diff --git a/lib/Target/cbg/FPMover.cpp b/lib/Target/cbg/FPMover.cpp
new file mode 100644
index 0000000..8c2904c
--- /dev/null
+++ b/lib/Target/cbg/FPMover.cpp
@@ -0,0 +1,144 @@
+//===-- FPMover.cpp - cbg double-precision floating point move fixer ----===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// Expand FpMOVD/FpABSD/FpNEGD instructions into their single-precision pieces.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "fpmover"
+#include "cbg.h"
+#include "cbgSubtarget.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetInstrInfo.h"
+#include "llvm/ADT/Statistic.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+STATISTIC(NumFpDs , "Number of instructions translated");
+STATISTIC(NoopFpDs, "Number of noop instructions removed");
+
+namespace {
+  struct FPMover : public MachineFunctionPass {
+    /// Target machine description which we query for reg. names, data
+    /// layout, etc.
+    ///
+    TargetMachine &TM;
+    
+    static char ID;
+    explicit FPMover(TargetMachine &tm) 
+      : MachineFunctionPass(ID), TM(tm) { }
+
+    virtual const char *getPassName() const {
+      return "CBG Double-FP Move Fixer";
+    }
+
+    bool runOnMachineBasicBlock(MachineBasicBlock &MBB);
+    bool runOnMachineFunction(MachineFunction &F);
+  };
+  char FPMover::ID = 0;
+} // end of anonymous namespace
+
+/// createcbgFPMoverPass - Returns a pass that turns FpMOVD
+/// instructions into FMOVS instructions
+///
+FunctionPass *llvm::createcbgFPMoverPass(TargetMachine &tm) {
+  return new FPMover(tm);
+}
+
+/// getDoubleRegPair - Given a DFP register, return the even and odd FP
+/// registers that correspond to it.
+static void getDoubleRegPair(unsigned DoubleReg, unsigned &EvenReg,
+                             unsigned &OddReg) {
+  static const unsigned EvenHalvesOfPairs[] = {
+    CBG::F0, CBG::F2, CBG::F4, CBG::F6, CBG::F8, CBG::F10, CBG::F12, CBG::F14,
+    CBG::F16, CBG::F18, CBG::F20, CBG::F22, CBG::F24, CBG::F26, CBG::F28, CBG::F30
+  };
+  static const unsigned OddHalvesOfPairs[] = {
+    CBG::F1, CBG::F3, CBG::F5, CBG::F7, CBG::F9, CBG::F11, CBG::F13, CBG::F15,
+    CBG::F17, CBG::F19, CBG::F21, CBG::F23, CBG::F25, CBG::F27, CBG::F29, CBG::F31
+  };
+  static const unsigned DoubleRegsInOrder[] = {
+    CBG::D0, CBG::D1, CBG::D2, CBG::D3, CBG::D4, CBG::D5, CBG::D6, CBG::D7, CBG::D8,
+    CBG::D9, CBG::D10, CBG::D11, CBG::D12, CBG::D13, CBG::D14, CBG::D15
+  };
+  for (unsigned i = 0; i < sizeof(DoubleRegsInOrder)/sizeof(unsigned); ++i)
+    if (DoubleRegsInOrder[i] == DoubleReg) {
+      EvenReg = EvenHalvesOfPairs[i];
+      OddReg = OddHalvesOfPairs[i];
+      return;
+    }
+  llvm_unreachable("Can't find reg");
+}
+
+/// runOnMachineBasicBlock - Fixup FpMOVD instructions in this MBB.
+///
+bool FPMover::runOnMachineBasicBlock(MachineBasicBlock &MBB) {
+  bool Changed = false;
+  for (MachineBasicBlock::iterator I = MBB.begin(); I != MBB.end(); ) {
+    MachineInstr *MI = I++;
+    DebugLoc dl = MI->getDebugLoc();
+    if (MI->getOpcode() == CBG::FpMOVD || MI->getOpcode() == CBG::FpABSD ||
+        MI->getOpcode() == CBG::FpNEGD) {
+      Changed = true;
+      unsigned DestDReg = MI->getOperand(0).getReg();
+      unsigned SrcDReg  = MI->getOperand(1).getReg();
+      if (DestDReg == SrcDReg && MI->getOpcode() == CBG::FpMOVD) {
+        MBB.erase(MI);   // Eliminate the noop copy.
+        ++NoopFpDs;
+        continue;
+      }
+      
+      unsigned EvenSrcReg = 0, OddSrcReg = 0, EvenDestReg = 0, OddDestReg = 0;
+      getDoubleRegPair(DestDReg, EvenDestReg, OddDestReg);
+      getDoubleRegPair(SrcDReg, EvenSrcReg, OddSrcReg);
+
+      const TargetInstrInfo *TII = TM.getInstrInfo();
+      if (MI->getOpcode() == CBG::FpMOVD)
+        MI->setDesc(TII->get(CBG::FMOVS));
+      else if (MI->getOpcode() == CBG::FpNEGD)
+        MI->setDesc(TII->get(CBG::FNEGS));
+      else if (MI->getOpcode() == CBG::FpABSD)
+        MI->setDesc(TII->get(CBG::FABSS));
+      else
+        llvm_unreachable("Unknown opcode!");
+        
+      MI->getOperand(0).setReg(EvenDestReg);
+      MI->getOperand(1).setReg(EvenSrcReg);
+      DEBUG(errs() << "FPMover: the modified instr is: " << *MI);
+      // Insert copy for the other half of the double.
+      if (DestDReg != SrcDReg) {
+        MI = BuildMI(MBB, I, dl, TM.getInstrInfo()->get(CBG::FMOVS), OddDestReg)
+          .addReg(OddSrcReg);
+        DEBUG(errs() << "FPMover: the inserted instr is: " << *MI);
+      }
+      ++NumFpDs;
+    }
+  }
+  return Changed;
+}
+
+bool FPMover::runOnMachineFunction(MachineFunction &F) {
+  // If the target has V9 instructions, the fp-mover pseudos will never be
+  // emitted.  Avoid a scan of the instructions to improve compile time.
+  /*if (TM.getSubtarget<cbgSubtarget>().isV9())
+    return false;*/
+//  std::cerr << __func__ << std::endl;
+  bool Changed = false;
+  for (MachineFunction::iterator FI = F.begin(), FE = F.end();
+       FI != FE; ++FI)
+    Changed |= runOnMachineBasicBlock(*FI);
+  return Changed;
+}
diff --git a/lib/Target/cbg/Makefile b/lib/Target/cbg/Makefile
new file mode 100644
index 0000000..784ae47
--- /dev/null
+++ b/lib/Target/cbg/Makefile
@@ -0,0 +1,23 @@
+##===- lib/Target/cbg/Makefile ---------------------------*- Makefile -*-===##
+#
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+##===----------------------------------------------------------------------===##
+
+LEVEL = ../../..
+LIBRARYNAME = LLVMcbgCodeGen
+TARGET = cbg
+
+# Make sure that tblgen is run, first thing.
+BUILT_SOURCES = cbgGenRegisterInfo.h.inc cbgGenRegisterNames.inc \
+                cbgGenRegisterInfo.inc cbgGenInstrNames.inc \
+                cbgGenInstrInfo.inc cbgGenAsmWriter.inc \
+                cbgGenDAGISel.inc cbgGenSubtarget.inc cbgGenCallingConv.inc
+
+DIRS = TargetInfo
+
+include $(LEVEL)/Makefile.common
+
diff --git a/lib/Target/cbg/PredecessorList.cpp b/lib/Target/cbg/PredecessorList.cpp
new file mode 100644
index 0000000..41fbc54
--- /dev/null
+++ b/lib/Target/cbg/PredecessorList.cpp
@@ -0,0 +1,102 @@
+/*
+ * PredecessorList.cpp
+ *
+ *  Created on: Nov 7, 2011
+ *      Author: cbg
+ */
+
+#include "PredecessorList.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+PredecessorList::~PredecessorList() {
+  for (PredList::iterator mbb_it = listEntries.begin();
+       mbb_it != listEntries.end();
+       ++mbb_it) {
+    delete(*mbb_it);
+  }
+}
+
+PredecessorList::ListEntry& PredecessorList::ListEntry::operator=(const ListEntry& le) {
+  if (this != &le) {
+    MBB = le.MBB;
+    predecessor = le.predecessor;
+  }
+  return (*this);
+}
+
+bool PredecessorList::ListEntry::operator==(const MachineBasicBlock* mbb) const {
+  return (mbb->getNumber() == MBB->getNumber());
+}
+
+bool PredecessorList::ListEntry::operator!=(const MachineBasicBlock* mbb) const {
+  return (mbb->getNumber() != MBB->getNumber());
+}
+
+/**
+ * @brief       Searches the list if it contains the specified machine basic block and returns
+ *              the corresponding list entry.
+ * @param mbb   Machine basic block to find.
+ * @return      The corresponding list entry on success, NULL if the list does not contain
+ *              the specified entry.
+ */
+PredecessorList::ListEntry* PredecessorList::findMachineBasicBlock(const MachineBasicBlock* mbb) {
+  ListEntry* listEntry = 0;
+  PredList::iterator list_it;
+
+  for (list_it = listEntries.begin(); list_it != listEntries.end(); ++list_it) {
+    if (*(*list_it) == mbb) {
+      listEntry = *list_it;
+      break;
+    }
+  }
+  return listEntry;
+}
+
+void PredecessorList::insertRoot(MachineBasicBlock* mbb) {
+  ListEntry* newEntry = new ListEntry(mbb);
+  listEntries.push_back(newEntry);
+}
+
+/**
+ * @brief               Inserts a machine basic block with the specified predecessor
+ *                      into list. If mbb is NULL, nothing will be inserted.
+ * @param mbb           The machine basic block which will be inserted.
+ * @param predecessor   The predecessor of the basic block.
+ */
+void PredecessorList::insertSuccessor(MachineBasicBlock* mbb,
+                                      const MachineBasicBlock* predecessor) {
+
+  ListEntry* pred = findMachineBasicBlock(predecessor);
+  ListEntry* newEntry;
+  if (mbb) {
+    newEntry = new ListEntry(mbb, pred);
+    listEntries.push_back(newEntry);
+  }
+
+}
+
+PredecessorList::MBB_list PredecessorList::getPredecessors(const MachineBasicBlock* &mbb) {
+  ListEntry* listEntry;
+//  ListEntry* predecessor;
+  MBB_list mbb_list;
+
+//  std::cerr << "Adding all predecessors of BB#" << mbb->getNumber() << " to list." << std::endl;
+
+  listEntry = findMachineBasicBlock(mbb);
+  if (mbb) {
+    mbb_list.push_back(const_cast<MachineBasicBlock*>(mbb));
+//    std::cerr << "Add BB#" << mbb->getNumber() << std::endl;
+  }
+
+//  std::cerr << "Address of predecessor: " << listEntry->getPredecessor() << std::endl;
+
+  while (listEntry->getPredecessor()) {
+    listEntry = listEntry->getPredecessor();
+//    std::cerr << "Add BB#" << listEntry->getMachineBasicBlock()->getNumber() << std::endl;
+    mbb_list.push_front(listEntry->getMachineBasicBlock());
+  }
+  return mbb_list;
+}
diff --git a/lib/Target/cbg/PredecessorList.h b/lib/Target/cbg/PredecessorList.h
new file mode 100644
index 0000000..c0c682b
--- /dev/null
+++ b/lib/Target/cbg/PredecessorList.h
@@ -0,0 +1,71 @@
+/*
+ * PredecessorList.h
+ *
+ *  Created on: Nov 7, 2011
+ *      Author: cbg
+ */
+
+#ifndef PREDECESSORLIST_H_
+#define PREDECESSORLIST_H_
+
+#include "llvm/CodeGen/MachineBasicBlock.h"
+
+#include <list>
+
+using namespace llvm;
+
+class PredecessorList {
+protected:
+
+  class ListEntry {
+  private:
+    MachineBasicBlock*  MBB;
+    ListEntry*          predecessor;
+  public:
+    ListEntry(MachineBasicBlock* mbb, ListEntry* pred) :
+      MBB(mbb), predecessor(pred) {}
+
+    ListEntry(MachineBasicBlock* mbb) :
+      MBB(mbb), predecessor(0) {}
+
+    ListEntry* getPredecessor(void) const {
+      return predecessor;
+    }
+
+    MachineBasicBlock* getMachineBasicBlock(void) const {
+      return MBB;
+    }
+
+    ListEntry& operator=(const ListEntry&);
+
+    bool operator==(const MachineBasicBlock*) const;
+    bool operator!=(const MachineBasicBlock*) const;
+  };
+
+  typedef std::list<ListEntry*> PredList;
+
+private:
+  PredList listEntries;
+
+protected:
+  ListEntry* findMachineBasicBlock(const MachineBasicBlock*);
+
+public:
+
+  typedef std::list<MachineBasicBlock*> MBB_list;
+
+  PredecessorList() :
+    listEntries(0) {}
+
+  ~PredecessorList();
+
+  void insertRoot(MachineBasicBlock* mbb);
+  void insertSuccessor(MachineBasicBlock* mbb,
+                       const MachineBasicBlock* predecessor);
+
+  MBB_list getPredecessors(const MachineBasicBlock* &mbb);
+
+};
+
+
+#endif /* PREDECESSORLIST_H_ */
diff --git a/lib/Target/cbg/README.txt b/lib/Target/cbg/README.txt
new file mode 100644
index 0000000..b4991fe
--- /dev/null
+++ b/lib/Target/cbg/README.txt
@@ -0,0 +1,59 @@
+
+To-do
+-----
+
+* Keep the address of the constant pool in a register instead of forming its
+  address all of the time.
+* We can fold small constant offsets into the %hi/%lo references to constant
+  pool addresses as well.
+* When in V9 mode, register allocate %icc[0-3].
+* Add support for isel'ing UMUL_LOHI instead of marking it as Expand.
+* Emit the 'Branch on Integer Register with Prediction' instructions.  It's
+  not clear how to write a pattern for this though:
+
+float %t1(int %a, int* %p) {
+        %C = seteq int %a, 0
+        br bool %C, label %T, label %F
+T:
+        store int 123, int* %p
+        br label %F
+F:
+        ret float undef
+}
+
+codegens to this:
+
+t1:
+        save -96, %o6, %o6
+1)      subcc %i0, 0, %l0
+1)      bne .LBBt1_2    ! F
+        nop
+.LBBt1_1:       ! T
+        or %g0, 123, %l0
+        st %l0, [%i1]
+.LBBt1_2:       ! F
+        restore %g0, %g0, %g0
+        retl
+        nop
+
+1) should be replaced with a brz in V9 mode.
+
+* Same as above, but emit conditional move on register zero (p192) in V9 
+  mode.  Testcase:
+
+int %t1(int %a, int %b) {
+        %C = seteq int %a, 0
+        %D = select bool %C, int %a, int %b
+        ret int %D
+}
+
+* Emit MULX/[SU]DIVX instructions in V9 mode instead of fiddling 
+  with the Y register, if they are faster.
+
+* Codegen bswap(load)/store(bswap) -> load/store ASI
+
+* Implement frame pointer elimination, e.g. eliminate save/restore for 
+  leaf fns.
+* Fill delay slots
+
+* Implement JIT support
diff --git a/lib/Target/cbg/TargetInfo/CMakeLists.txt b/lib/Target/cbg/TargetInfo/CMakeLists.txt
new file mode 100644
index 0000000..beea205
--- /dev/null
+++ b/lib/Target/cbg/TargetInfo/CMakeLists.txt
@@ -0,0 +1,7 @@
+include_directories( ${CMAKE_CURRENT_BINARY_DIR}/.. ${CMAKE_CURRENT_SOURCE_DIR}/.. )
+
+add_llvm_library(LLVMcbgInfo
+  cbgTargetInfo.cpp
+  )
+
+add_dependencies(LLVMcbgInfo cbgCodeGenTable_gen)
diff --git a/lib/Target/cbg/TargetInfo/Makefile b/lib/Target/cbg/TargetInfo/Makefile
new file mode 100644
index 0000000..9a86e45
--- /dev/null
+++ b/lib/Target/cbg/TargetInfo/Makefile
@@ -0,0 +1,15 @@
+##===- lib/Target/cbg/TargetInfo/Makefile ----------------*- Makefile -*-===##
+#
+#                     The LLVM Compiler Infrastructure
+#
+# This file is distributed under the University of Illinois Open Source
+# License. See LICENSE.TXT for details.
+#
+##===----------------------------------------------------------------------===##
+LEVEL = ../../../..
+LIBRARYNAME = LLVMcbgInfo
+
+# Hack: we need to include 'main' target directory to grab private headers
+CPPFLAGS = -I$(PROJ_OBJ_DIR)/.. -I$(PROJ_SRC_DIR)/..
+
+include $(LEVEL)/Makefile.common
diff --git a/lib/Target/cbg/TargetInfo/cbgTargetInfo.cpp b/lib/Target/cbg/TargetInfo/cbgTargetInfo.cpp
new file mode 100644
index 0000000..4cf6ec0
--- /dev/null
+++ b/lib/Target/cbg/TargetInfo/cbgTargetInfo.cpp
@@ -0,0 +1,19 @@
+//===-- cbgTargetInfo.cpp - cbg Target Implementation -----------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbg.h"
+#include "llvm/Module.h"
+#include "llvm/Target/TargetRegistry.h"
+using namespace llvm;
+
+Target llvm::ThecbgTarget;
+
+extern "C" void LLVMInitializecbgTargetInfo() {
+  RegisterTarget<Triple::cbg> X(ThecbgTarget, "cbg", "CBG");
+}
diff --git a/lib/Target/cbg/cbg.h b/lib/Target/cbg/cbg.h
new file mode 100644
index 0000000..61d13d0
--- /dev/null
+++ b/lib/Target/cbg/cbg.h
@@ -0,0 +1,129 @@
+//===-- cbg.h - Top-level interface for cbg representation --*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the entry points for global functions defined in the LLVM
+// cbg back-end.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef TARGET_CBG_H
+#define TARGET_CBG_H
+
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Target/TargetMachine.h"
+#include <cassert>
+
+namespace llvm {
+  class FunctionPass;
+  class LoopPass;
+  class cbgTargetMachine;
+  class formatted_raw_ostream;
+
+  FunctionPass *createcbgISelDag(cbgTargetMachine &TM);
+  FunctionPass *createcbgDelaySlotFillerPass(TargetMachine &TM);
+  FunctionPass *createcbgFPMoverPass(TargetMachine &TM);
+  // Function pass for finding loops which can be transformed
+  // to hardware loops
+  FunctionPass *createcbgHWLoopPass(TargetMachine &TM, unsigned loopDepth, bool rIndexVar);
+  // Function pass for inserting predicated blocks instead of branches
+  FunctionPass *createcbgPredBlockCCPass(TargetMachine &TM);
+  FunctionPass *createcbgPredBlockRegPass(TargetMachine &TM);
+  FunctionPass *createcbgPredInstrCCPass(TargetMachine &TM);
+  FunctionPass *createcbgPredInstrRegPass(TargetMachine &TM);
+
+  extern Target ThecbgTarget;
+
+} // end namespace llvm;
+
+// Defines symbolic names for cbg registers.  This defines a mapping from
+// register name to register number.
+//
+#include "cbgGenRegisterNames.inc"
+
+// Defines symbolic names for the cbg instructions.
+//
+#include "cbgGenInstrNames.inc"
+
+
+namespace llvm {
+  // Enums corresponding to cbg condition codes, both icc's and fcc's.  These
+  // values must be kept in sync with the ones in the .td file.
+  namespace CBGCC {
+    enum CondCodes {
+      //ICC_A   =  8   ,  // Always
+      //ICC_N   =  0   ,  // Never
+      ICC_NE  =  9   ,  // Not Equal
+      ICC_E   =  1   ,  // Equal
+      ICC_G   = 10   ,  // Greater
+      ICC_LE  =  2   ,  // Less or Equal
+      ICC_GE  = 11   ,  // Greater or Equal
+      ICC_L   =  3   ,  // Less
+      ICC_GU  = 12   ,  // Greater Unsigned
+      ICC_LEU =  4   ,  // Less or Equal Unsigned
+      ICC_CC  = 13   ,  // Carry Clear/Great or Equal Unsigned
+      ICC_CS  =  5   ,  // Carry Set/Less Unsigned
+      ICC_POS = 14   ,  // Positive
+      ICC_NEG =  6   ,  // Negative
+      ICC_VC  = 15   ,  // Overflow Clear
+      ICC_VS  =  7   ,  // Overflow Set
+      
+      //FCC_A   =  8+16,  // Always
+      //FCC_N   =  0+16,  // Never
+      FCC_U   =  7+16,  // Unordered
+      FCC_G   =  6+16,  // Greater
+      FCC_UG  =  5+16,  // Unordered or Greater
+      FCC_L   =  4+16,  // Less
+      FCC_UL  =  3+16,  // Unordered or Less
+      FCC_LG  =  2+16,  // Less or Greater
+      FCC_NE  =  1+16,  // Not Equal
+      FCC_E   =  9+16,  // Equal
+      FCC_UE  = 10+16,  // Unordered or Equal
+      FCC_GE  = 11+16,  // Greater or Equal
+      FCC_UGE = 12+16,  // Unordered or Greater or Equal
+      FCC_LE  = 13+16,  // Less or Equal
+      FCC_ULE = 14+16,  // Unordered or Less or Equal
+      FCC_O   = 15+16   // Ordered
+    };
+  }
+  
+  inline static const char *CBGCondCodeToString(CBGCC::CondCodes CC) {
+    switch (CC) {
+    default: llvm_unreachable("Unknown condition code");
+    case CBGCC::ICC_NE:  return "ne";
+    case CBGCC::ICC_E:   return "e";
+    case CBGCC::ICC_G:   return "g";
+    case CBGCC::ICC_LE:  return "le";
+    case CBGCC::ICC_GE:  return "ge";
+    case CBGCC::ICC_L:   return "l";
+    case CBGCC::ICC_GU:  return "gu";
+    case CBGCC::ICC_LEU: return "leu";
+    case CBGCC::ICC_CC:  return "cc";
+    case CBGCC::ICC_CS:  return "cs";
+    case CBGCC::ICC_POS: return "pos";
+    case CBGCC::ICC_NEG: return "neg";
+    case CBGCC::ICC_VC:  return "vc";
+    case CBGCC::ICC_VS:  return "vs";
+    case CBGCC::FCC_U:   return "u";
+    case CBGCC::FCC_G:   return "g";
+    case CBGCC::FCC_UG:  return "ug";
+    case CBGCC::FCC_L:   return "l";
+    case CBGCC::FCC_UL:  return "ul";
+    case CBGCC::FCC_LG:  return "lg";
+    case CBGCC::FCC_NE:  return "ne";
+    case CBGCC::FCC_E:   return "e";
+    case CBGCC::FCC_UE:  return "ue";
+    case CBGCC::FCC_GE:  return "ge";
+    case CBGCC::FCC_UGE: return "uge";
+    case CBGCC::FCC_LE:  return "le";
+    case CBGCC::FCC_ULE: return "ule";
+    case CBGCC::FCC_O:   return "o";
+    }       
+  }
+}  // end namespace llvm
+#endif
diff --git a/lib/Target/cbg/cbg.td b/lib/Target/cbg/cbg.td
new file mode 100644
index 0000000..3dff82d
--- /dev/null
+++ b/lib/Target/cbg/cbg.td
@@ -0,0 +1,95 @@
+//===- cbg.td - Describe the cbg Target Machine --------*- tablegen -*-===//
+// 
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+// 
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Target-independent interfaces which we are implementing
+//===----------------------------------------------------------------------===//
+
+include "llvm/Target/Target.td"
+
+//===----------------------------------------------------------------------===//
+// CBG Subtarget features.
+//
+ 
+def FeatureSelCC
+  : SubtargetFeature<"selcc", "HasSelCC", "true",
+                     "Enable selCC instructions">;
+def FeatureMovCC
+  : SubtargetFeature<"movcc", "HasMovCC", "true",
+                     "Enable selCC instructions">;
+def FeaturePredBlocksCC
+  : SubtargetFeature<"predblockscc", "HasPredBlocksCC", "true",
+                     "Enable predicated blocks with condition codes">;
+def FeaturePredBlocksReg
+  : SubtargetFeature<"predblocksreg", "HasPredBlocksReg", "true",
+                     "Enable predicated blocks with predicate register">;
+def FeaturePredInstrCC
+  : SubtargetFeature<"predinstrcc", "HasPredInstrCC", "true",
+                     "Enable fully predicated instructions with condition codes">;
+def FeaturePredInstrReg
+  : SubtargetFeature<"predinstrreg", "HasPredInstrReg", "true",
+                     "Enable fully predicated instructions with predicate register">;
+def FeatureHWLoop
+  : SubtargetFeature<"singleloop", "HasHWLoop", "true",
+                     "Enable hardware support for single loop">;
+
+def FeatureHWLoopOpt
+  : SubtargetFeature<"hwloopopt", "HasHWLoopOpt", "true",
+                     "Enable hardware loop code optimizations">;
+// def FeatureHWLoops
+//   : SubtargetFeature<"nestedloops", "HasHWLoops", "true",
+//                      "Enable hardware support for nested loops - currently not implemented (same as singleloop)">;
+// def FeatureVLIWIfElse
+//   : SubtargetFeature<"vliwbranches", "HasVLIWIfElse", "true",
+//                      "Enable concurrent if and else execution - currently not implemented">;
+
+//===----------------------------------------------------------------------===//
+// Register File, Calling Conv, Instruction Descriptions
+//===----------------------------------------------------------------------===//
+
+include "cbgRegisterInfo.td"
+include "cbgCallingConv.td"
+include "cbgInstrInfo.td"
+
+def cbgInstrInfo : InstrInfo;
+
+//===----------------------------------------------------------------------===//
+// CBG processors supported.
+//===----------------------------------------------------------------------===//
+
+class Proc<string Name, list<SubtargetFeature> Features>
+ : Processor<Name, NoItineraries, Features>;
+
+def : Proc<"v8",                    []>;
+def : Proc<"v8-blockicc-movcc",     [FeatureMovCC, FeaturePredBlocksCC, FeatureHWLoop, FeatureHWLoopOpt]>;
+def : Proc<"v8-blockpreg-selcc",    [FeatureSelCC, FeaturePredBlocksReg, FeatureHWLoop, FeatureHWLoopOpt]>;
+def : Proc<"v8-blockicc-selcc",     [FeatureSelCC, FeaturePredBlocksCC, FeatureHWLoop, FeatureHWLoopOpt]>;
+// def : Proc<"v8-selcc",        [FeatureSelCC]>;
+// def : Proc<"v8-movcc",        [FeatureMovCC]>;
+// def : Proc<"v8-predblockscc", [FeaturePredBlocksCC]>;
+// def : Proc<"v8-predblocksreg",[FeaturePredBlocksReg]>;
+// def : Proc<"v8-predinstrcc",  [FeaturePredInstrCC]>;
+// def : Proc<"v8-predinstrreg", [FeaturePredInstrReg]>;
+// def : Proc<"v8-singleloop",   [FeatureHWLoop]>;
+// def : Proc<"v8-nestedloop",   [FeatureHWLoops]>;
+// def : Proc<"v8-vliwbranches", [FeatureVLIWIfElse]>;
+// def : Proc<"v8-block-loops",  [FeaturePredBlocksCC, FeatureHWLoops]>;
+// def : Proc<"v8-pred-loops",   [FeaturePredInstrCC, FeatureHWLoops]>;
+
+//===----------------------------------------------------------------------===//
+// Declare the target which we are implementing
+//===----------------------------------------------------------------------===//
+
+def cbg : Target {
+  // Pull in Instruction Info:
+  let InstructionSet = cbgInstrInfo;
+}
diff --git a/lib/Target/cbg/cbgAsmPrinter.cpp b/lib/Target/cbg/cbgAsmPrinter.cpp
new file mode 100644
index 0000000..a399ef6
--- /dev/null
+++ b/lib/Target/cbg/cbgAsmPrinter.cpp
@@ -0,0 +1,289 @@
+//===-- cbgAsmPrinter.cpp - cbg LLVM assembly writer ------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains a printer that converts from our internal representation
+// of machine-dependent LLVM code to GAS-format CBG assembly language.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "asm-printer"
+#include "cbg.h"
+#include "cbgInstrInfo.h"
+#include "cbgTargetMachine.h"
+#include "llvm/CodeGen/AsmPrinter.h"
+#include "llvm/CodeGen/MachineInstr.h"
+#include "llvm/MC/MCAsmInfo.h"
+#include "llvm/MC/MCStreamer.h"
+#include "llvm/MC/MCSymbol.h"
+#include "llvm/Target/Mangler.h"
+#include "llvm/Target/TargetRegistry.h"
+#include "llvm/ADT/SmallString.h"
+#include "llvm/ADT/StringExtras.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+namespace {
+  class cbgAsmPrinter : public AsmPrinter {
+  public:
+    explicit cbgAsmPrinter(TargetMachine &TM, MCStreamer &Streamer)
+      : AsmPrinter(TM, Streamer) {}
+
+    virtual const char *getPassName() const {
+      return "cbg Assembly Printer";
+    }
+
+    void printOperand(const MachineInstr *MI, int opNum, raw_ostream &OS);
+    void printMemOperand(const MachineInstr *MI, int opNum, raw_ostream &OS,
+                         const char *Modifier = 0);
+    void printCCOperand(const MachineInstr *MI, int opNum, raw_ostream &OS);
+
+    void printPredCCOperand(const MachineInstr *MI, int opNum, raw_ostream &OS);
+    void printPRegTFOperand(const MachineInstr *MI, int opNum, raw_ostream &OS);
+
+    virtual void EmitInstruction(const MachineInstr *MI) {
+      SmallString<128> Str;
+      raw_svector_ostream OS(Str);
+      printInstruction(MI, OS);
+      OutStreamer.EmitRawText(OS.str());
+    }
+    void printInstruction(const MachineInstr *MI, raw_ostream &OS);// autogen'd.
+    static const char *getRegisterName(unsigned RegNo);
+
+    bool PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                         unsigned AsmVariant, const char *ExtraCode,
+                         raw_ostream &O);
+    bool PrintAsmMemoryOperand(const MachineInstr *MI, unsigned OpNo,
+                               unsigned AsmVariant, const char *ExtraCode,
+                               raw_ostream &O);
+
+    bool printGetPCX(const MachineInstr *MI, unsigned OpNo, raw_ostream &OS);
+    
+    virtual bool isBlockOnlyReachableByFallthrough(const MachineBasicBlock *MBB)
+                       const;
+  };
+} // end of anonymous namespace
+
+#include "cbgGenAsmWriter.inc"
+
+void cbgAsmPrinter::printOperand(const MachineInstr *MI, int opNum,
+                                   raw_ostream &O) {
+  const MachineOperand &MO = MI->getOperand (opNum);
+  bool CloseParen = false;
+  if (MI->getOpcode() == CBG::SETHIi && !MO.isReg() && !MO.isImm()) {
+    O << "%hi(";
+    CloseParen = true;
+  } else if ((MI->getOpcode() == CBG::ORri || MI->getOpcode() == CBG::ADDri) &&
+             !MO.isReg() && !MO.isImm()) {
+    O << "%lo(";
+    CloseParen = true;
+  }
+  switch (MO.getType()) {
+  case MachineOperand::MO_Register:
+    O << "%" << LowercaseString(getRegisterName(MO.getReg()));
+    break;
+
+  case MachineOperand::MO_Immediate:
+    O << (int)MO.getImm();
+    break;
+  case MachineOperand::MO_MachineBasicBlock:
+    O << *MO.getMBB()->getSymbol();
+    return;
+  case MachineOperand::MO_GlobalAddress:
+    O << *Mang->getSymbol(MO.getGlobal());
+    break;
+  case MachineOperand::MO_ExternalSymbol:
+    O << MO.getSymbolName();
+    break;
+  case MachineOperand::MO_ConstantPoolIndex:
+    O << MAI->getPrivateGlobalPrefix() << "CPI" << getFunctionNumber() << "_"
+      << MO.getIndex();
+    break;
+  default:
+    llvm_unreachable("<unknown operand type>");
+  }
+  if (CloseParen) O << ")";
+}
+
+void cbgAsmPrinter::printMemOperand(const MachineInstr *MI, int opNum,
+                                      raw_ostream &O, const char *Modifier) {
+  printOperand(MI, opNum, O);
+
+  // If this is an ADD operand, emit it like normal operands.
+  if (Modifier && !strcmp(Modifier, "arith")) {
+    O << ", ";
+    printOperand(MI, opNum+1, O);
+    return;
+  }
+
+  if (MI->getOperand(opNum+1).isReg() &&
+      MI->getOperand(opNum+1).getReg() == CBG::G0)
+    return;   // don't print "+%g0"
+  if (MI->getOperand(opNum+1).isImm() &&
+      MI->getOperand(opNum+1).getImm() == 0)
+    return;   // don't print "+0"
+
+  O << "+";
+  if (MI->getOperand(opNum+1).isGlobal() ||
+      MI->getOperand(opNum+1).isCPI()) {
+    O << "%lo(";
+    printOperand(MI, opNum+1, O);
+    O << ")";
+  } else {
+    printOperand(MI, opNum+1, O);
+  }
+}
+
+bool cbgAsmPrinter::printGetPCX(const MachineInstr *MI, unsigned opNum,
+                                  raw_ostream &O) {
+  std::string operand = "";
+  const MachineOperand &MO = MI->getOperand(opNum);
+  switch (MO.getType()) {
+  default: assert(0 && "Operand is not a register ");
+  case MachineOperand::MO_Register:
+    assert(TargetRegisterInfo::isPhysicalRegister(MO.getReg()) &&
+           "Operand is not a physical register ");
+    assert(MO.getReg() != CBG::O7 && 
+           "%o7 is assigned as destination for getpcx!");
+    operand = "%" + LowercaseString(getRegisterName(MO.getReg()));
+    break;
+  }
+
+  unsigned mfNum = MI->getParent()->getParent()->getFunctionNumber();
+  unsigned bbNum = MI->getParent()->getNumber();
+
+  O << '\n' << ".LLGETPCH" << mfNum << '_' << bbNum << ":\n";
+  O << "\tcall\t.LLGETPC" << mfNum << '_' << bbNum << '\n' ;
+
+  O << "\t  sethi\t"
+    << "%hi(_GLOBAL_OFFSET_TABLE_+(.-.LLGETPCH" << mfNum << '_' << bbNum 
+    << ")), "  << operand << '\n' ;
+
+  O << ".LLGETPC" << mfNum << '_' << bbNum << ":\n" ;
+  O << "\tor\t" << operand  
+    << ", %lo(_GLOBAL_OFFSET_TABLE_+(.-.LLGETPCH" << mfNum << '_' << bbNum
+    << ")), " << operand << '\n';
+  O << "\tadd\t" << operand << ", %o7, " << operand << '\n'; 
+  
+  return true;
+}
+
+void cbgAsmPrinter::printCCOperand(const MachineInstr *MI, int opNum,
+                                     raw_ostream &O) {
+  int CC = (int)MI->getOperand(opNum).getImm();
+  O << CBGCondCodeToString((CBGCC::CondCodes)CC);
+}
+
+void cbgAsmPrinter::printPredCCOperand(const MachineInstr *MI, int opNum, raw_ostream &OS) {
+  int CC = (int)MI->getOperand(opNum).getImm();
+  if (CC > 0) {
+    OS << CBGCondCodeToString((CBGCC::CondCodes)CC);
+  }
+}
+
+void cbgAsmPrinter::printPRegTFOperand(const MachineInstr *MI, int opNum, raw_ostream &OS) {
+  int tfOperand = (int)MI->getOperand(opNum).getImm();
+  if (tfOperand == 0) {
+    OS << "f";
+  } else {
+    OS << "t";
+  }
+}
+
+/// PrintAsmOperand - Print out an operand for an inline asm expression.
+///
+bool cbgAsmPrinter::PrintAsmOperand(const MachineInstr *MI, unsigned OpNo,
+                                      unsigned AsmVariant,
+                                      const char *ExtraCode,
+                                      raw_ostream &O) {
+  if (ExtraCode && ExtraCode[0]) {
+    if (ExtraCode[1] != 0) return true; // Unknown modifier.
+
+    switch (ExtraCode[0]) {
+    default: return true;  // Unknown modifier.
+    case 'r':
+     break;
+    }
+  }
+
+  printOperand(MI, OpNo, O);
+
+  return false;
+}
+
+bool cbgAsmPrinter::PrintAsmMemoryOperand(const MachineInstr *MI,
+                                            unsigned OpNo, unsigned AsmVariant,
+                                            const char *ExtraCode,
+                                            raw_ostream &O) {
+  if (ExtraCode && ExtraCode[0])
+    return true;  // Unknown modifier
+
+  O << '[';
+  printMemOperand(MI, OpNo, O);
+  O << ']';
+
+  return false;
+}
+
+/// isBlockOnlyReachableByFallthough - Return true if the basic block has
+/// exactly one predecessor and the control transfer mechanism between
+/// the predecessor and this block is a fall-through.
+///
+/// This overrides AsmPrinter's implementation to handle delay slots.
+bool cbgAsmPrinter::
+isBlockOnlyReachableByFallthrough(const MachineBasicBlock *MBB) const {
+
+  MachineFunction* F = const_cast<MachineFunction*>(MBB->getParent());
+  MachineFunction::iterator mf_iter = F->begin();
+
+  // labels for blocks after a hardware loop are needed to be printed
+  if (MBB != &(*mf_iter)) {
+    mf_iter++;
+    if (MBB != &(*mf_iter)) {
+      MachineBasicBlock* const_mbb = const_cast<MachineBasicBlock*>(MBB->getPrevNode()->getPrevNode());
+      MachineBasicBlock::iterator mbb_iter = const_mbb->end();
+      --mbb_iter;
+      if (mbb_iter->getOpcode() == CBG::HWLOOP) {
+        return false;
+      }
+    }
+  }
+
+  // If this is a landing pad, it isn't a fall through.  If it has no preds,
+  // then nothing falls through to it.
+  if (MBB->isLandingPad() || MBB->pred_empty())
+    return false;
+
+  // If there isn't exactly one predecessor, it can't be a fall through.
+  MachineBasicBlock::const_pred_iterator PI = MBB->pred_begin(), PI2 = PI;
+  ++PI2;
+  if (PI2 != MBB->pred_end())
+    return false;
+  
+  // The predecessor has to be immediately before this block.
+  const MachineBasicBlock *Pred = *PI;
+  
+  if (!Pred->isLayoutSuccessor(MBB))
+    return false;
+  
+  // Check if the last terminator is an unconditional branch.
+  MachineBasicBlock::const_iterator I = Pred->end();
+  while (I != Pred->begin() && !(--I)->getDesc().isTerminator())
+    ; // Noop
+  return I == Pred->end() || !I->getDesc().isBarrier();
+}
+
+
+
+// Force static initialization.
+extern "C" void LLVMInitializecbgAsmPrinter() {
+  RegisterAsmPrinter<cbgAsmPrinter> X(ThecbgTarget);
+}
diff --git a/lib/Target/cbg/cbgCallingConv.td b/lib/Target/cbg/cbgCallingConv.td
new file mode 100644
index 0000000..848733a
--- /dev/null
+++ b/lib/Target/cbg/cbgCallingConv.td
@@ -0,0 +1,36 @@
+//===- cbgCallingConv.td - Calling Conventions cbg -----*- tablegen -*-===//
+// 
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+// 
+//===----------------------------------------------------------------------===//
+//
+// This describes the calling conventions for the cbg architectures.
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Return Value Calling Conventions
+//===----------------------------------------------------------------------===//
+
+// cbg 32-bit C return-value convention.
+def RetCC_Sparc32 : CallingConv<[
+  CCIfType<[i32], CCAssignToReg<[I0, I1, I2, I3, I4, I5]>>,
+  CCIfType<[f32], CCAssignToReg<[F0, F1, F2, F3]>>,
+  CCIfType<[f64], CCAssignToReg<[D0, D1]>>
+]>;
+
+// cbg 32-bit C Calling convention.
+def CC_Sparc32 : CallingConv<[
+  //Custom assign SRet to [sp+64].
+  CCIfSRet<CCCustom<"CC_Sparc_Assign_SRet">>,
+  // i32 f32 arguments get passed in integer registers if there is space.
+  CCIfType<[i32, f32], CCAssignToReg<[I0, I1, I2, I3, I4, I5]>>,
+  // f64 arguments are split and passed through registers or through stack.
+  CCIfType<[f64], CCCustom<"CC_Sparc_Assign_f64">>,
+
+  // Alternatively, they are assigned to the stack in 4-byte aligned units.
+  CCAssignToStack<4, 4>
+]>;
diff --git a/lib/Target/cbg/cbgFrameLowering.cpp b/lib/Target/cbg/cbgFrameLowering.cpp
new file mode 100644
index 0000000..6ae20a4
--- /dev/null
+++ b/lib/Target/cbg/cbgFrameLowering.cpp
@@ -0,0 +1,80 @@
+//====- cbgFrameLowering.cpp - cbg Frame Information -------*- C++ -*-====//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the cbg implementation of TargetFrameLowering class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgFrameLowering.h"
+#include "cbgInstrInfo.h"
+#include "cbgMachineFunctionInfo.h"
+#include "llvm/Function.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineModuleInfo.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/Target/TargetData.h"
+#include "llvm/Target/TargetOptions.h"
+#include "llvm/Support/CommandLine.h"
+
+using namespace llvm;
+
+void cbgFrameLowering::emitPrologue(MachineFunction &MF) const {
+  MachineBasicBlock &MBB = MF.front();
+  MachineFrameInfo *MFI = MF.getFrameInfo();
+  const cbgInstrInfo &TII =
+    *static_cast<const cbgInstrInfo*>(MF.getTarget().getInstrInfo());
+  MachineBasicBlock::iterator MBBI = MBB.begin();
+  DebugLoc dl = MBBI != MBB.end() ? MBBI->getDebugLoc() : DebugLoc();
+
+  // Get the number of bytes to allocate from the FrameInfo
+  int NumBytes = (int) MFI->getStackSize();
+
+  // Emit the correct save instruction based on the number of bytes in
+  // the frame. Minimum stack frame size according to V8 ABI is:
+  //   16 words for register window spill
+  //    1 word for address of returned aggregate-value
+  // +  6 words for passing parameters on the stack
+  // ----------
+  //   23 words * 4 bytes per word = 92 bytes
+  NumBytes += 92;
+
+  // Round up to next doubleword boundary -- a double-word boundary
+  // is required by the ABI.
+  NumBytes = (NumBytes + 7) & ~7;
+  NumBytes = -NumBytes;
+
+  if (NumBytes >= -4096) {
+    BuildMI(MBB, MBBI, dl, TII.get(CBG::SAVEri), CBG::O6)
+      .addReg(CBG::O6).addImm(NumBytes);
+  } else {
+    // Emit this the hard way.  This clobbers G1 which we always know is
+    // available here.
+    unsigned OffHi = (unsigned)NumBytes >> 10U;
+    BuildMI(MBB, MBBI, dl, TII.get(CBG::SETHIi), CBG::G1).addImm(OffHi);
+    // Emit G1 = G1 + I6
+    BuildMI(MBB, MBBI, dl, TII.get(CBG::ORri), CBG::G1)
+      .addReg(CBG::G1).addImm(NumBytes & ((1 << 10)-1));
+    BuildMI(MBB, MBBI, dl, TII.get(CBG::SAVErr), CBG::O6)
+      .addReg(CBG::O6).addReg(CBG::G1);
+  }
+}
+
+void cbgFrameLowering::emitEpilogue(MachineFunction &MF,
+                                  MachineBasicBlock &MBB) const {
+  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
+  const cbgInstrInfo &TII =
+    *static_cast<const cbgInstrInfo*>(MF.getTarget().getInstrInfo());
+  DebugLoc dl = MBBI->getDebugLoc();
+  assert(MBBI->getOpcode() == CBG::RETL &&
+         "Can only put epilog before 'retl' instruction!");
+  BuildMI(MBB, MBBI, dl, TII.get(CBG::RESTORErr), CBG::G0).addReg(CBG::G0)
+    .addReg(CBG::G0);
+}
diff --git a/lib/Target/cbg/cbgFrameLowering.h b/lib/Target/cbg/cbgFrameLowering.h
new file mode 100644
index 0000000..1ee7968
--- /dev/null
+++ b/lib/Target/cbg/cbgFrameLowering.h
@@ -0,0 +1,41 @@
+//===- cbgFrameLowering.h - Define frame lowering for cbg --*- C++ -*--===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBG_FRAMEINFO_H
+#define CBG_FRAMEINFO_H
+
+#include "cbg.h"
+#include "cbgSubtarget.h"
+#include "llvm/Target/TargetFrameLowering.h"
+
+namespace llvm {
+  class cbgSubtarget;
+
+class cbgFrameLowering : public TargetFrameLowering {
+  const cbgSubtarget &STI;
+public:
+  explicit cbgFrameLowering(const cbgSubtarget &sti)
+    : TargetFrameLowering(TargetFrameLowering::StackGrowsDown, 8, 0), STI(sti) {
+  }
+
+  /// emitProlog/emitEpilog - These methods insert prolog and epilog code into
+  /// the function.
+  void emitPrologue(MachineFunction &MF) const;
+  void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const;
+
+  bool hasFP(const MachineFunction &MF) const { return false; }
+};
+
+} // End llvm namespace
+
+#endif
diff --git a/lib/Target/cbg/cbgHWLoop.cpp b/lib/Target/cbg/cbgHWLoop.cpp
new file mode 100644
index 0000000..8836f76
--- /dev/null
+++ b/lib/Target/cbg/cbgHWLoop.cpp
@@ -0,0 +1,639 @@
+/*
+ * cbgHWLoop.cpp
+ *
+ *  Created on: Nov 1, 2011
+ *      Author: cbg
+ */
+
+#include "cbg.h"
+#include "cbgInstrInfo.h"
+#include "PredecessorList.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineOperand.h"
+
+#include <vector>
+#include <list>
+
+#include <iostream>
+
+#if 0
+  #define DD_PRINT(func) {\
+    std::cerr << func << std::endl; \
+  }
+#else
+  #define DD_PRINT(func)
+#endif
+
+using namespace llvm;
+
+namespace {
+  class HWLoopPass : public MachineFunctionPass {
+
+  public:
+    typedef PredecessorList::MBB_list MBB_list;
+    static char ID;
+
+    struct LoopBounds {
+      bool isValidLoop;
+      bool needsIncrement;
+      MachineOperand LoopBound;
+      unsigned IndexVar;
+    };
+
+  private:
+    static bool isIncrement(const MachineInstr &instr);
+    static bool isDecrement(const MachineInstr &instr);
+    static bool isNoDestination(unsigned regNumber,
+                                MachineBasicBlock &MBB,
+                                MachineBasicBlock::reverse_iterator &mbb_iter);
+
+    static bool machineBasicBlockInSet(MachineBasicBlock* const &MBB, MBB_list &mbb_set);
+    static LoopBounds findLoopBound(MachineBasicBlock &MBB);
+    static void updatePredecessors(MachineBasicBlock* newMBB, MachineBasicBlock* MBB);
+
+  protected:
+    TargetMachine &TM;
+    unsigned LoopDepth;
+    unsigned LoopCount;
+    bool RemoveIndexVar;
+
+    virtual MBB_list getPossibleLoops(MachineBasicBlock &MBB) const;
+    virtual void insertSingleHWLoop(MachineBasicBlock &MBB, MachineOperand &MO, bool needsIncrement);
+    virtual void removeIndexVar(MachineBasicBlock &MBB, unsigned regNumber);
+    virtual void removeConditionalBranch(MachineBasicBlock &MBB);
+
+  public:
+
+    explicit HWLoopPass(TargetMachine &tm, unsigned loopDepth, bool rIndexVar) : MachineFunctionPass(ID), TM(tm),
+                                                                 LoopDepth(loopDepth),
+                                                                 LoopCount(0),
+                                                                 RemoveIndexVar(rIndexVar) {}
+
+    /*virtual bool doInitialization(Loop* loop, LPPassManager &LPM) { DD_PRINT(__func__); return false; }
+    virtual bool runOnLoop(Loop* loop, LPPassManager &LPM);
+    virtual bool doFinalization() { DD_PRINT(__func__); return false; }*/
+
+    bool runOnMachineBasicBlock(MachineBasicBlock &MBB);
+    bool runOnMachineFunction(MachineFunction &F);
+
+    virtual const char *getPassName() const {
+      return "CBG HWloop pass";
+    }
+
+  };
+
+  char HWLoopPass::ID = 0;
+
+}
+
+/**
+ * @brief Returns whether a given MBB is already saved in the given list.
+ * @param MBB     Given machine basic block to check.
+ * @param mbb_set Given list (set) of machine basic blocks.
+ * @return True if machine basic block is already part of the list, false otherwise.
+ */
+bool HWLoopPass::machineBasicBlockInSet(MachineBasicBlock* const &MBB, MBB_list &mbb_set) {
+  MBB_list::iterator mbb_iterator;
+  for (mbb_iterator = mbb_set.begin(); mbb_iterator != mbb_set.end(); ++mbb_iterator) {
+    if ((*mbb_iterator)->getNumber() == MBB->getNumber()) {
+      return true;
+    }
+  }
+  return false;
+}
+
+/**
+ * @brief Finds out all MBBs which may be involved in the smallest possible loop
+ *        starting from MBB.
+ * @param MBB
+ * @return A list of MBBs which are part of the loop.
+ */
+HWLoopPass::MBB_list HWLoopPass::getPossibleLoops(MachineBasicBlock &MBB) const {
+
+  MBB_list possible_loops;
+  MBB_list all_successors;
+  MachineBasicBlock::succ_iterator s_iter;
+  MachineBasicBlock::succ_iterator s_end_iter = MBB.succ_end();
+  PredecessorList all_predecessors;
+  bool foundLoop;
+
+  // return empty vector if BB has no successor
+  if (MBB.succ_empty()) {
+    return possible_loops;
+  }
+
+  // insert current basic block as "root element" into predecessor
+  all_predecessors.insertRoot(&MBB);
+
+  // init successor set
+  for (s_iter = MBB.succ_begin(); s_iter != s_end_iter; ++s_iter) {
+    all_successors.push_back(*s_iter);
+    all_predecessors.insertSuccessor(*s_iter, &MBB);
+    if (((*s_iter)->getNumber() == MBB.getNumber()) && (!machineBasicBlockInSet(&MBB, possible_loops))) {
+      possible_loops.push_back(&MBB);
+      // we have found a small basic block loop => ignore bigger ones
+      return possible_loops;
+    }
+  }
+
+  // add all successors to successor set
+  for (MBB_list::iterator suc_it = all_successors.begin();
+      suc_it != all_successors.end();
+      ++suc_it) {
+
+    foundLoop = false;
+
+    s_end_iter = (*suc_it)->succ_end();
+    for (s_iter = (*suc_it)->succ_begin(); s_iter != s_end_iter; ++s_iter) {
+
+      // in any case, add predecessor to set
+      all_predecessors.insertSuccessor(*s_iter, const_cast<const MachineBasicBlock*&>(*suc_it));
+      // if successor of node in successor set is current BB, we have found a loop
+      if ((*s_iter)->getNumber() == MBB.getNumber()) {
+        possible_loops = all_predecessors.getPredecessors(const_cast<const MachineBasicBlock*&>(*suc_it));
+        foundLoop = true;
+        break;
+      } else {
+        // otherwise we have to add it to the successor set
+        if (!machineBasicBlockInSet(*s_iter, all_successors)) {
+          all_successors.push_back(*s_iter);
+        }
+      }
+
+    }
+
+    // we have found a loop, so exit current for loop
+    if (foundLoop) {
+      break;
+    }
+
+  }
+
+  return possible_loops;
+
+}
+
+/**
+ * @brief Changes the successor value of the predecessors of the old machine basic block,
+ *        including jump labels.
+ * @param newMBB Inserted machine basic block, representing the hwloop initialization.
+ * @param MBB    Old machine basic block, representing the simple loop.
+ */
+void HWLoopPass::updatePredecessors(MachineBasicBlock* newMBB, MachineBasicBlock* MBB) {
+
+  std::vector<MachineBasicBlock*> predecessors;
+  MachineBasicBlock::pred_iterator pred_iter;
+  for (pred_iter = MBB->pred_begin();
+       pred_iter != MBB->pred_end();
+       ++pred_iter) {
+    // add all predecessors except own basic block to set
+    if (*pred_iter != MBB) {
+      predecessors.push_back(*pred_iter);
+    }
+  }
+
+  for (pred_iter = predecessors.begin();
+       pred_iter != predecessors.end();
+       ++pred_iter) {
+    (*pred_iter)->removeSuccessor(MBB);
+    (*pred_iter)->addSuccessor(newMBB);
+    // update branch targets to old basic block
+    for (MachineBasicBlock::iterator instr_it = (*pred_iter)->begin();
+         instr_it != (*pred_iter)->end();
+         ++instr_it) {
+      if ((instr_it->getOpcode() == CBG::BA) || (instr_it->getOpcode() == CBG::BCOND)) {
+        if (instr_it->getOperand(0).getMBB() == MBB) {
+          instr_it->getOperand(0).setMBB(newMBB);
+        }
+      }
+      // update hwloop branch targets
+      if (instr_it->getOpcode() == CBG::HWLOOPinit) {
+        if (instr_it->getOperand(1).isMBB() && instr_it->getOperand(1).getMBB() == MBB) {
+          instr_it->getOperand(1).setMBB(newMBB);
+        }
+      }
+    }
+  }
+
+}
+
+/**
+ * @brief Inserts a hwloop instruction before the given machine basic block.
+ * @param MBB            The machine basic block representing the simple loop before which
+ *                       the hwloop instructions have to be inserted.
+ * @param MO             The machine operand respresenting the loop bound. May either be an
+ *                       immediate or a register value.
+ * @param needsIncrement This boolean indicates, whether the given loop bound register in MO
+ *                       has to be incremented before initialization. (Compare while
+ *                       (index < loopbound) vs. (index <= loopbound)).
+ */
+void HWLoopPass::insertSingleHWLoop(MachineBasicBlock &MBB, MachineOperand &MO, bool needsIncrement) {
+
+  // get current function
+  MachineFunction *F = MBB.getParent();
+  const BasicBlock *LLVM_BB = MBB.getBasicBlock();
+
+  // if we have to increment the loop bound register, we have
+  // have to find an unused register
+  TargetRegisterClass::iterator reg_iter;
+
+  // create new machine basic block in current function
+  MachineBasicBlock* newMBB = F->CreateMachineBasicBlock(LLVM_BB);
+  MachineFunction::iterator func_it = F->begin();
+  MachineInstrBuilder mi;
+  DebugLoc dbg_loc = newMBB->begin()->getDebugLoc();
+
+  // search current basic block
+  while ((*func_it).getNumber() != MBB.getNumber()) {
+    ++func_it;
+  }
+  ++func_it;
+
+  // insert new basic block in current position
+  F->insert(func_it, newMBB);
+  newMBB->moveBefore(&MBB);
+
+  // initialize all howloop registers:
+  mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::HWLOOPinit));
+  mi.addReg(CBG::HWLOOP1, RegState::Define).addMBB(&MBB);
+  mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::HWLOOPinit));
+  mi.addReg(CBG::HWLOOP2, RegState::Define).addMBB(MBB.getNextNode());
+  // if the needsIncrement boolean is set, we have to increment
+  // the register value before using it
+  if (needsIncrement) {
+    // get next free register number
+    reg_iter = CBG::IntRegsRegisterClass->allocation_order_begin(*F);
+    while (MBB.isLiveIn(*reg_iter)) {
+      ++reg_iter;
+    }
+    mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADDri));
+    mi.addReg(*reg_iter, RegState::Define).addReg(MO.getReg()).addImm(1);
+
+    mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::HWLOOPinit));
+    mi.addReg(CBG::HWLOOP3, RegState::Define).addReg(*reg_iter, RegState::Kill);
+
+  } else {
+    mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::HWLOOPinit));
+    mi.addReg(CBG::HWLOOP3, RegState::Define).addOperand(MO);
+  }
+
+  // insert hardware loop instruction at end of new block
+  mi = BuildMI(*newMBB, newMBB->end(), dbg_loc, TM.getInstrInfo()->get(CBG::HWLOOP));
+
+  // update all predecessors of old block
+  updatePredecessors(newMBB, &MBB);
+  newMBB->addSuccessor(&MBB);
+  newMBB->addSuccessor(MBB.getNextNode());
+
+  F->RenumberBlocks(newMBB);
+
+}
+
+/**
+ * @brief Checks, whether the current instruction simply increments
+ *        a register by adding "1".
+ * @param instr Machine instruction to check.
+ * @return True, if the register is incrementend, false otherwise.
+ */
+bool HWLoopPass::isIncrement(const MachineInstr &instr) {
+
+  int opCode = instr.getOpcode();
+  int incrementValue;
+  bool isIncrement = false;
+
+  // we only allow ADDri and SUBri to be valid
+  // incremental instructions
+  if (opCode == CBG::ADDri) {
+    // if we have an ADDri instruction, the increment
+    // value has to be +1
+    incrementValue = instr.getOperand(2).getImm();
+    if (incrementValue == 1) {
+      isIncrement = true;
+    }
+  } else if (opCode == CBG::SUBri) {
+    // if we have a SUBri instruction, the increment
+    // value has to be -1
+    incrementValue = instr.getOperand(2).getImm();
+    if (incrementValue == -1) {
+     isIncrement = true;
+    }
+  }
+  // else => we have no increment instruction
+
+  return isIncrement;
+
+}
+
+/**
+ * @brief Checks, whether the current instruction simply decrements
+ *        a register by subtracting "1".
+ * @param instr Machine instruction to check.
+ * @return True, if the register is decrementend, false otherwise.
+ */
+bool HWLoopPass::isDecrement(const MachineInstr &instr) {
+
+  int opCode = instr.getOpcode();
+  int decrementValue;
+  bool isDecrement = false;
+
+  // we only allow ADDri and SUBri to be valid
+  // incremental instructions
+  if (opCode == CBG::ADDri) {
+    // if we have an ADDri instruction, the decrement
+    // value has to be -1
+    decrementValue = instr.getOperand(2).getImm();
+    if (decrementValue == -1) {
+      isDecrement = true;
+    }
+  } else if (opCode == CBG::SUBri) {
+    // if we have a SUBri instruction, the decrement
+    // value has to be 1
+    decrementValue = instr.getOperand(2).getImm();
+    if (decrementValue == 1) {
+     isDecrement = true;
+    }
+  }
+  // else => we have no increment instruction
+
+  return isDecrement;
+
+}
+
+/**
+ * @brief Checks, whether the given register number is no destination register of any
+ *        previous instruction within the current machine basic block.
+ * @param regNumber Register number to check.
+ * @param MBB       Current machine basic block.
+ * @param mbb_iter  Reverse iterater, indicating the last instruction within the
+ *                  current machine basic block where check has to start.
+ * @return True if the current register is no destination register in any previous
+ *         instruction of the current machine basic block, false otherwise.
+ */
+bool HWLoopPass::isNoDestination(unsigned regNumber,
+                                 MachineBasicBlock &MBB,
+                                 MachineBasicBlock::reverse_iterator &mbb_iter) {
+  bool isNoDestination = true;
+
+  // check the whole basic block whether the given register
+  // is the destination of any instruction
+  for (; mbb_iter != MBB.rend(); ++mbb_iter) {
+    // only check if the destination is a valid register
+    if (mbb_iter->getNumOperands() > 0 && mbb_iter->getOperand(0).isReg()) {
+      // if the destination register of current instruction
+      // is equal to given regNumber, we have to stop
+      if (mbb_iter->getOperand(0).getReg() == regNumber) {
+        isNoDestination = false;
+        break;
+      }
+    }
+  }
+
+  return isNoDestination;
+
+}
+
+/**
+ * @brief Tries to guess the index variable (register) and loop bound (register or
+ *        immediate) of the given MBB which has to be a loop.
+ * @param MBB Block to check.
+ * @return A struct which indicates whether the block is a valid loop we can handle,
+ *         whether the loop bound has to be incremented, the loop bound as machine
+ *         operand and the register number of the index variable.
+ */
+HWLoopPass::LoopBounds HWLoopPass::findLoopBound(MachineBasicBlock &MBB) {
+
+  MachineBasicBlock::reverse_iterator mbb_iter = MBB.rbegin();
+  MachineBasicBlock::reverse_iterator mbb_tmp_iter;
+  MachineBasicBlock::reverse_iterator mbb_tmp_iter2;
+  MachineOperand* possibleLoopBound;
+  MachineOperand* possibleIndexVar;
+  unsigned branchCond = 0;
+  MachineOperand LoopBound = MachineOperand::CreateImm(0);
+  unsigned IndexVar = 0;
+  LoopBounds returnValue = {false, false, LoopBound, IndexVar};
+  unsigned OpCode;
+
+  // (1) last instruction has to be a conditional branch with target to
+  // current basic block
+  if ((mbb_iter->getOpcode() == CBG::BCOND) &&
+      (mbb_iter->getOperand(0).getMBB() == &MBB)) {
+    branchCond = mbb_iter->getOperand(1).getImm();
+
+    do {
+      ++mbb_iter;
+      OpCode = mbb_iter->getOpcode();
+      if (OpCode == CBG::SUBCCri || OpCode == CBG::SUBCCrr || OpCode == CBG::ADDCCri || OpCode == CBG::ADDCCrr) {
+        break;
+      }
+    } while (mbb_iter != MBB.rend());
+
+//    std::cerr << "Last instruction of BB#" << MBB.getNumber() << " was conditional branch." << std::endl;
+//    std::cerr << "Opcode of second last instruction: " << mbb_iter->getOpcode() << std::endl;
+
+    // (2) second last instruction only can be a SUBCCrx
+    if ((mbb_iter != MBB.rend()) &&
+       ((mbb_iter->getOpcode() == CBG::SUBCCri) || (mbb_iter->getOpcode() == CBG::SUBCCrr))) {
+
+//      std::cerr << "Second last instruction was SUBCCrx." << std::endl;
+
+      // result of compare operation will be ignored
+      if (mbb_iter->getOperand(0).isDead()) {
+
+//        std::cerr << "Result of compare operation will not be used any more." << std::endl;
+
+        possibleIndexVar = &(mbb_iter->getOperand(1));
+        possibleLoopBound = &(mbb_iter->getOperand(2));
+
+        ++mbb_iter;
+
+        while (mbb_iter != MBB.rend()) {
+          OpCode = mbb_iter->getOpcode();
+          if (OpCode == CBG::SUBri || OpCode == CBG::SUBrr || OpCode == CBG::ADDri || OpCode == CBG::ADDrr) {
+            break;
+          }
+          ++mbb_iter;
+        }
+
+
+
+        if (mbb_iter != MBB.rend()) {
+
+          // (3) src1 register may only be the destination of a predecessing increment or decrement
+          // (3)(a) if idx is decremented, we only allow immediates to be loop bounds
+          if ( isDecrement(*mbb_iter) &&
+               possibleLoopBound->isImm() &&
+              (possibleLoopBound->getImm() <= 0)) {
+            mbb_tmp_iter = mbb_iter;
+            ++mbb_tmp_iter;
+
+            if (isNoDestination(possibleIndexVar->getReg(), MBB, mbb_tmp_iter)) {
+              // if immediate is less that 0, we simply have to change sign
+              if (possibleLoopBound->getImm() < 0) {
+//                std::cerr << "Found constant loop bound " << (-1 * possibleLoopBound->getImm()) << std::endl;
+                returnValue.LoopBound.setImm(-1 * possibleLoopBound->getImm());
+                returnValue.IndexVar = possibleIndexVar->getReg();
+              } else {
+                // if immediate is zero, index variable contains loop bound
+//                std::cerr << "Found loop bound in register " << possibleIndexVar->getReg() << std::endl;
+                returnValue.LoopBound.ChangeToRegister(possibleIndexVar->getReg(), false);
+                returnValue.IndexVar = possibleIndexVar->getReg();
+                if (branchCond == CBGCC::ICC_LE) {
+                  returnValue.needsIncrement = true;
+                }
+              }
+              returnValue.isValidLoop = true;
+            }
+          }
+          // (3)(b) if idx is incremented and compared with constant
+          else if( isIncrement(*mbb_iter) &&
+                   possibleLoopBound->isImm() &&
+                  (possibleLoopBound->getImm() > 0)) {
+            mbb_tmp_iter = mbb_iter;
+            ++mbb_tmp_iter;
+
+            if (isNoDestination(possibleIndexVar->getReg(), MBB, mbb_tmp_iter)) {
+//              std::cerr << "Found constant loop bound " << possibleLoopBound->getImm() << std::endl;
+              returnValue.LoopBound.setImm(possibleLoopBound->getImm());
+              returnValue.IndexVar = possibleIndexVar->getReg();
+              returnValue.isValidLoop = true;
+            }
+
+          }
+
+          // (3)(c) if idx is incremented and compared with a constant register
+          else if( isIncrement(*mbb_iter) &&
+                   possibleLoopBound->isReg()) {
+
+            mbb_tmp_iter = mbb_iter;
+            ++mbb_tmp_iter;
+            mbb_tmp_iter2 = mbb_tmp_iter;
+
+            // neither index variable, nor loop bound register may be used as
+            // destination register
+
+            if (isNoDestination(possibleIndexVar->getReg(), MBB, mbb_tmp_iter) &&
+                isNoDestination(possibleLoopBound->getReg(), MBB, mbb_tmp_iter2)) {
+//              std::cerr << "Found register loop bound in register " << possibleLoopBound->getReg() << std::endl;
+              returnValue.LoopBound.ChangeToRegister(possibleLoopBound->getReg(), false);
+              returnValue.IndexVar = possibleIndexVar->getReg();
+              returnValue.isValidLoop = true;
+              if (branchCond == CBGCC::ICC_LE) {
+                returnValue.needsIncrement = true;
+              }
+            }
+
+          }
+
+
+        }
+
+      }
+
+    }
+
+  }
+
+  return returnValue;
+
+}
+
+/**
+ * @brief Removes last conditional branch at the end of the given machine basic block.
+ * @param MBB Machine basic block to check.
+ */
+void HWLoopPass::removeConditionalBranch(MachineBasicBlock &MBB) {
+
+  MachineBasicBlock::reverse_iterator mbb_iter;
+
+  // remove last two instructions (conditional branch and compare)
+  MBB.rbegin()->eraseFromParent();
+
+  mbb_iter = MBB.rbegin();
+  while (mbb_iter != MBB.rend()) {
+    if (mbb_iter->getOpcode() == CBG::SUBCCri || mbb_iter->getOpcode() == CBG::SUBCCrr) {
+      mbb_iter->eraseFromParent();
+      break;
+    }
+    ++mbb_iter;
+  }
+}
+
+/**
+ * @brief Tries to remove all instructions of the given basic block where the
+ *        index register is involved if this is possible.
+ * @param MBB       Machine basic block to check.
+ * @param regNumber Register number containing the index variable.
+ */
+void HWLoopPass::removeIndexVar(MachineBasicBlock &MBB, unsigned regNumber) {
+
+  MachineBasicBlock::reverse_iterator mbb_iter;
+  bool isUsed = false;
+
+  // check, whether loop index is used as input for any other value
+  for (mbb_iter = MBB.rbegin(); mbb_iter != MBB.rend(); ++mbb_iter) {
+    for (unsigned numOps = 1; numOps < mbb_iter->getNumOperands(); ++numOps) {
+      if ( mbb_iter->getOperand(numOps).isReg() &&
+          (mbb_iter->getOperand(numOps).getReg() == regNumber)) {
+        if (!isDecrement(*mbb_iter) && !isIncrement(*mbb_iter)) {
+          isUsed = true;
+          break;
+        }
+      }
+    }
+    if (isUsed) {
+      break;
+    }
+  }
+
+  // we can remove last increment/decrement instruction, if index var is not used
+  if (!isUsed) {
+    for (mbb_iter = MBB.rbegin(); mbb_iter != MBB.rend(); ++mbb_iter) {
+      if ( mbb_iter->getOperand(0).isReg() &&
+          (mbb_iter->getOperand(0).getReg() == regNumber)) {
+        if (isDecrement(*mbb_iter) || isIncrement(*mbb_iter)) {
+          mbb_iter->eraseFromParent();
+          break;
+        }
+      }
+    }
+  }
+
+}
+
+bool HWLoopPass::runOnMachineFunction(MachineFunction &F) {
+  bool Changed = false;
+  MBB_list possible_loops;
+  for (MachineFunction::iterator FI = F.begin(), FE = F.end();
+      FI != FE; ++FI) {
+    possible_loops = getPossibleLoops(*FI);
+    if (possible_loops.size() == 1) {
+//      std::cerr << "Found loop candidate..." << std::endl;
+//      FI->dump();
+      Changed |= runOnMachineBasicBlock(*FI);
+    }
+  }
+  return Changed;
+}
+
+bool HWLoopPass::runOnMachineBasicBlock(MachineBasicBlock &MBB) {
+  LoopBounds loopOperand = findLoopBound(MBB);
+//  std::cerr << "Valid loop: " << loopOperand.isValidLoop << std::endl;
+  if (loopOperand.isValidLoop) {
+
+    insertSingleHWLoop(MBB, loopOperand.LoopBound, loopOperand.needsIncrement);
+    removeConditionalBranch(MBB);
+    // only remove index variable if option is specified
+    if (RemoveIndexVar) {
+      removeIndexVar(MBB, loopOperand.IndexVar);
+    }
+    return true;
+  }
+  return false;
+}
+
+FunctionPass* llvm::createcbgHWLoopPass(TargetMachine &tm, unsigned loopDepth, bool rIndexVar) {
+  DD_PRINT(__func__);
+  return new HWLoopPass(tm, loopDepth, rIndexVar);
+}
diff --git a/lib/Target/cbg/cbgISelDAGToDAG.cpp b/lib/Target/cbg/cbgISelDAGToDAG.cpp
new file mode 100644
index 0000000..3509a91
--- /dev/null
+++ b/lib/Target/cbg/cbgISelDAGToDAG.cpp
@@ -0,0 +1,216 @@
+//===-- cbgISelDAGToDAG.cpp - A dag to dag inst selector for cbg ------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines an instruction selector for the CBG target.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgTargetMachine.h"
+#include "llvm/Intrinsics.h"
+#include "llvm/CodeGen/SelectionDAGISel.h"
+#include "llvm/Support/Compiler.h"
+#include "llvm/Support/Debug.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+//===----------------------------------------------------------------------===//
+// Instruction Selector Implementation
+//===----------------------------------------------------------------------===//
+
+//===--------------------------------------------------------------------===//
+/// cbgDAGToDAGISel - CBG specific code to select CBG machine
+/// instructions for SelectionDAG operations.
+///
+namespace {
+class cbgDAGToDAGISel : public SelectionDAGISel {
+  /// Subtarget - Keep a pointer to the cbg Subtarget around so that we can
+  /// make the right decision when generating code for different targets.
+  const cbgSubtarget &Subtarget;
+  cbgTargetMachine& TM;
+public:
+  explicit cbgDAGToDAGISel(cbgTargetMachine &tm)
+    : SelectionDAGISel(tm),
+      Subtarget(tm.getSubtarget<cbgSubtarget>()),
+      TM(tm) {
+  }
+
+  SDNode *Select(SDNode *N);
+
+  // Complex Pattern Selectors.
+  bool SelectADDRrr(SDValue N, SDValue &R1, SDValue &R2);
+  bool SelectADDRri(SDValue N, SDValue &Base, SDValue &Offset);
+
+  /// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
+  /// inline asm expressions.
+  virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
+                                            char ConstraintCode,
+                                            std::vector<SDValue> &OutOps);
+
+  virtual const char *getPassName() const {
+    return "CBG DAG->DAG Pattern Instruction Selection";
+  }
+
+  // Include the pieces autogenerated from the target description.
+#include "cbgGenDAGISel.inc"
+
+private:
+  SDNode* getGlobalBaseReg();
+};
+}  // end anonymous namespace
+
+SDNode* cbgDAGToDAGISel::getGlobalBaseReg() {
+  unsigned GlobalBaseReg = TM.getInstrInfo()->getGlobalBaseReg(MF);
+  return CurDAG->getRegister(GlobalBaseReg, TLI.getPointerTy()).getNode();
+}
+
+bool cbgDAGToDAGISel::SelectADDRri(SDValue Addr,
+                                     SDValue &Base, SDValue &Offset) {
+  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
+    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+    Offset = CurDAG->getTargetConstant(0, MVT::i32);
+    return true;
+  }
+  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
+      Addr.getOpcode() == ISD::TargetGlobalAddress)
+    return false;  // direct calls.
+
+  if (Addr.getOpcode() == ISD::ADD) {
+    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
+      if (isInt<13>(CN->getSExtValue())) {
+        if (FrameIndexSDNode *FIN =
+                dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
+          // Constant offset from frame ref.
+          Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
+        } else {
+          Base = Addr.getOperand(0);
+        }
+        Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
+        return true;
+      }
+    }
+    if (Addr.getOperand(0).getOpcode() == SPISD::Lo) {
+      Base = Addr.getOperand(1);
+      Offset = Addr.getOperand(0).getOperand(0);
+      return true;
+    }
+    if (Addr.getOperand(1).getOpcode() == SPISD::Lo) {
+      Base = Addr.getOperand(0);
+      Offset = Addr.getOperand(1).getOperand(0);
+      return true;
+    }
+  }
+  Base = Addr;
+  Offset = CurDAG->getTargetConstant(0, MVT::i32);
+  return true;
+}
+
+bool cbgDAGToDAGISel::SelectADDRrr(SDValue Addr, SDValue &R1, SDValue &R2) {
+  if (Addr.getOpcode() == ISD::FrameIndex) return false;
+  if (Addr.getOpcode() == ISD::TargetExternalSymbol ||
+      Addr.getOpcode() == ISD::TargetGlobalAddress)
+    return false;  // direct calls.
+
+  if (Addr.getOpcode() == ISD::ADD) {
+    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))
+      if (isInt<13>(CN->getSExtValue()))
+        return false;  // Let the reg+imm pattern catch this!
+    if (Addr.getOperand(0).getOpcode() == SPISD::Lo ||
+        Addr.getOperand(1).getOpcode() == SPISD::Lo)
+      return false;  // Let the reg+imm pattern catch this!
+    R1 = Addr.getOperand(0);
+    R2 = Addr.getOperand(1);
+    return true;
+  }
+
+  R1 = Addr;
+  R2 = CurDAG->getRegister(CBG::G0, MVT::i32);
+  return true;
+}
+
+SDNode *cbgDAGToDAGISel::Select(SDNode *N) {
+//  std::cerr << __func__ << std::endl;
+  DebugLoc dl = N->getDebugLoc();
+  if (N->isMachineOpcode())
+    return NULL;   // Already selected.
+
+  switch (N->getOpcode()) {
+  default: break;
+  case SPISD::GLOBAL_BASE_REG:
+    return getGlobalBaseReg();
+
+  case ISD::SDIV:
+  case ISD::UDIV: {
+    // FIXME: should use a custom expander to expose the SRA to the dag.
+    SDValue DivLHS = N->getOperand(0);
+    SDValue DivRHS = N->getOperand(1);
+
+    // Set the Y register to the high-part.
+    SDValue TopPart;
+    if (N->getOpcode() == ISD::SDIV) {
+      TopPart = SDValue(CurDAG->getMachineNode(CBG::SRAri, dl, MVT::i32, DivLHS,
+                                   CurDAG->getTargetConstant(31, MVT::i32)), 0);
+    } else {
+      TopPart = CurDAG->getRegister(CBG::G0, MVT::i32);
+    }
+    TopPart = SDValue(CurDAG->getMachineNode(CBG::WRYrr, dl, MVT::Glue, TopPart,
+                                     CurDAG->getRegister(CBG::G0, MVT::i32)), 0);
+
+    // FIXME: Handle div by immediate.
+    unsigned Opcode = N->getOpcode() == ISD::SDIV ? CBG::SDIVrr : CBG::UDIVrr;
+    return CurDAG->SelectNodeTo(N, Opcode, MVT::i32, DivLHS, DivRHS,
+                                TopPart);
+  }
+  case ISD::MULHU:
+  case ISD::MULHS: {
+    // FIXME: Handle mul by immediate.
+    SDValue MulLHS = N->getOperand(0);
+    SDValue MulRHS = N->getOperand(1);
+    unsigned Opcode = N->getOpcode() == ISD::MULHU ? CBG::UMULrr : CBG::SMULrr;
+    SDNode *Mul = CurDAG->getMachineNode(Opcode, dl, MVT::i32, MVT::Glue,
+                                         MulLHS, MulRHS);
+    // The high part is in the Y register.
+    return CurDAG->SelectNodeTo(N, CBG::RDY, MVT::i32, SDValue(Mul, 1));
+    return NULL;
+  }
+  }
+
+  return SelectCode(N);
+}
+
+
+/// SelectInlineAsmMemoryOperand - Implement addressing mode selection for
+/// inline asm expressions.
+bool
+cbgDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op,
+                                                char ConstraintCode,
+                                                std::vector<SDValue> &OutOps) {
+  SDValue Op0, Op1;
+  switch (ConstraintCode) {
+  default: return true;
+  case 'm':   // memory
+   if (!SelectADDRrr(Op, Op0, Op1))
+     SelectADDRri(Op, Op0, Op1);
+   break;
+  }
+
+  OutOps.push_back(Op0);
+  OutOps.push_back(Op1);
+  return false;
+}
+
+/// createcbgISelDag - This pass converts a legalized DAG into a
+/// CBG-specific DAG, ready for instruction scheduling.
+///
+FunctionPass *llvm::createcbgISelDag(cbgTargetMachine &TM) {
+  return new cbgDAGToDAGISel(TM);
+}
diff --git a/lib/Target/cbg/cbgISelLowering.cpp b/lib/Target/cbg/cbgISelLowering.cpp
new file mode 100644
index 0000000..697ecf2
--- /dev/null
+++ b/lib/Target/cbg/cbgISelLowering.cpp
@@ -0,0 +1,1311 @@
+
+//===-- cbgISelLowering.cpp - cbg DAG Lowering Implementation ---------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the interfaces that cbg uses to lower LLVM code into a
+// selection DAG.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgISelLowering.h"
+#include "cbgTargetMachine.h"
+#include "cbgMachineFunctionInfo.h"
+#include "llvm/DerivedTypes.h"
+#include "llvm/Function.h"
+#include "llvm/Module.h"
+#include "llvm/CodeGen/CallingConvLower.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/CodeGen/SelectionDAG.h"
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "llvm/ADT/VectorExtras.h"
+#include "llvm/Support/ErrorHandling.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+
+//===----------------------------------------------------------------------===//
+// Calling Convention Implementation
+//===----------------------------------------------------------------------===//
+
+static bool CC_Sparc_Assign_SRet(unsigned &ValNo, MVT &ValVT,
+                                 MVT &LocVT, CCValAssign::LocInfo &LocInfo,
+                                 ISD::ArgFlagsTy &ArgFlags, CCState &State)
+{
+  assert (ArgFlags.isSRet());
+
+  //Assign SRet argument
+  State.addLoc(CCValAssign::getCustomMem(ValNo, ValVT,
+                                         0,
+                                         LocVT, LocInfo));
+  return true;
+}
+
+static bool CC_Sparc_Assign_f64(unsigned &ValNo, MVT &ValVT,
+                                MVT &LocVT, CCValAssign::LocInfo &LocInfo,
+                                ISD::ArgFlagsTy &ArgFlags, CCState &State)
+{
+  static const unsigned RegList[] = {
+    CBG::I0, CBG::I1, CBG::I2, CBG::I3, CBG::I4, CBG::I5
+  };
+  //Try to get first reg
+  if (unsigned Reg = State.AllocateReg(RegList, 6)) {
+    State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
+  } else {
+    //Assign whole thing in stack
+    State.addLoc(CCValAssign::getCustomMem(ValNo, ValVT,
+                                           State.AllocateStack(8,4),
+                                           LocVT, LocInfo));
+    return true;
+  }
+
+  //Try to get second reg
+  if (unsigned Reg = State.AllocateReg(RegList, 6))
+    State.addLoc(CCValAssign::getCustomReg(ValNo, ValVT, Reg, LocVT, LocInfo));
+  else
+    State.addLoc(CCValAssign::getCustomMem(ValNo, ValVT,
+                                           State.AllocateStack(4,4),
+                                           LocVT, LocInfo));
+  return true;
+}
+
+#include "cbgGenCallingConv.inc"
+
+SDValue
+cbgTargetLowering::LowerReturn(SDValue Chain,
+                                 CallingConv::ID CallConv, bool isVarArg,
+                                 const SmallVectorImpl<ISD::OutputArg> &Outs,
+                                 const SmallVectorImpl<SDValue> &OutVals,
+                                 DebugLoc dl, SelectionDAG &DAG) const {
+
+  MachineFunction &MF = DAG.getMachineFunction();
+
+  // CCValAssign - represent the assignment of the return value to locations.
+  SmallVector<CCValAssign, 16> RVLocs;
+
+  // CCState - Info about the registers and stack slot.
+  CCState CCInfo(CallConv, isVarArg, DAG.getTarget(),
+                 RVLocs, *DAG.getContext());
+
+  // Analize return values.
+  CCInfo.AnalyzeReturn(Outs, RetCC_Sparc32);
+
+  // If this is the first return lowered for this function, add the regs to the
+  // liveout set for the function.
+  if (MF.getRegInfo().liveout_empty()) {
+    for (unsigned i = 0; i != RVLocs.size(); ++i)
+      if (RVLocs[i].isRegLoc())
+        MF.getRegInfo().addLiveOut(RVLocs[i].getLocReg());
+  }
+
+  SDValue Flag;
+
+  // Copy the result values into the output registers.
+  for (unsigned i = 0; i != RVLocs.size(); ++i) {
+    CCValAssign &VA = RVLocs[i];
+    assert(VA.isRegLoc() && "Can only return in registers!");
+
+    Chain = DAG.getCopyToReg(Chain, dl, VA.getLocReg(),
+                             OutVals[i], Flag);
+
+    // Guarantee that all emitted copies are stuck together with flags.
+    Flag = Chain.getValue(1);
+  }
+
+  unsigned RetAddrOffset = 8; //Call Inst + Delay Slot
+  // If the function returns a struct, copy the SRetReturnReg to I0
+  if (MF.getFunction()->hasStructRetAttr()) {
+    cbgMachineFunctionInfo *SFI = MF.getInfo<cbgMachineFunctionInfo>();
+    unsigned Reg = SFI->getSRetReturnReg();
+    if (!Reg)
+      llvm_unreachable("sret virtual register not created in the entry block");
+    SDValue Val = DAG.getCopyFromReg(Chain, dl, Reg, getPointerTy());
+    Chain = DAG.getCopyToReg(Chain, dl, CBG::I0, Val, Flag);
+    Flag = Chain.getValue(1);
+    if (MF.getRegInfo().liveout_empty())
+      MF.getRegInfo().addLiveOut(CBG::I0);
+    RetAddrOffset = 12; // CallInst + Delay Slot + Unimp
+  }
+
+  SDValue RetAddrOffsetNode = DAG.getConstant(RetAddrOffset, MVT::i32);
+
+  if (Flag.getNode())
+    return DAG.getNode(SPISD::RET_FLAG, dl, MVT::Other, Chain,
+                       RetAddrOffsetNode, Flag);
+  return DAG.getNode(SPISD::RET_FLAG, dl, MVT::Other, Chain, 
+                     RetAddrOffsetNode);
+}
+
+/// LowerFormalArguments - V8 uses a very simple ABI, where all values are
+/// passed in either one or two GPRs, including FP values.  TODO: we should
+/// pass FP values in FP registers for fastcc functions.
+SDValue
+cbgTargetLowering::LowerFormalArguments(SDValue Chain,
+                                          CallingConv::ID CallConv, bool isVarArg,
+                                          const SmallVectorImpl<ISD::InputArg>
+                                            &Ins,
+                                          DebugLoc dl, SelectionDAG &DAG,
+                                          SmallVectorImpl<SDValue> &InVals)
+                                            const {
+
+  MachineFunction &MF = DAG.getMachineFunction();
+  MachineRegisterInfo &RegInfo = MF.getRegInfo();
+  cbgMachineFunctionInfo *FuncInfo = MF.getInfo<cbgMachineFunctionInfo>();
+
+  // Assign locations to all of the incoming arguments.
+  SmallVector<CCValAssign, 16> ArgLocs;
+  CCState CCInfo(CallConv, isVarArg, getTargetMachine(),
+                 ArgLocs, *DAG.getContext());
+  CCInfo.AnalyzeFormalArguments(Ins, CC_Sparc32);
+
+  const unsigned StackOffset = 92;
+
+  for (unsigned i = 0, e = ArgLocs.size(); i != e; ++i) {
+    CCValAssign &VA = ArgLocs[i];
+
+    if (i == 0  && Ins[i].Flags.isSRet()) {
+      //Get SRet from [%fp+64]
+      int FrameIdx = MF.getFrameInfo()->CreateFixedObject(4, 64, true);
+      SDValue FIPtr = DAG.getFrameIndex(FrameIdx, MVT::i32);
+      SDValue Arg = DAG.getLoad(MVT::i32, dl, Chain, FIPtr,
+                                MachinePointerInfo(),
+                                false, false, 0);
+      InVals.push_back(Arg);
+      continue;
+    }
+
+    if (VA.isRegLoc()) {
+      EVT RegVT = VA.getLocVT();
+
+      if (VA.needsCustom()) {
+        assert(VA.getLocVT() == MVT::f64);
+        unsigned VRegHi = RegInfo.createVirtualRegister(&CBG::IntRegsRegClass);
+        MF.getRegInfo().addLiveIn(VA.getLocReg(), VRegHi);
+        SDValue HiVal = DAG.getCopyFromReg(Chain, dl, VRegHi, MVT::i32);
+
+        assert(i+1 < e);
+        CCValAssign &NextVA = ArgLocs[++i];
+
+        SDValue LoVal;
+        if (NextVA.isMemLoc()) {
+          int FrameIdx = MF.getFrameInfo()->
+            CreateFixedObject(4, StackOffset+NextVA.getLocMemOffset(),true);
+          SDValue FIPtr = DAG.getFrameIndex(FrameIdx, MVT::i32);
+          LoVal = DAG.getLoad(MVT::i32, dl, Chain, FIPtr,
+                              MachinePointerInfo(),
+                              false, false, 0);
+        } else {
+          unsigned loReg = MF.addLiveIn(NextVA.getLocReg(),
+                                        &CBG::IntRegsRegClass);
+          LoVal = DAG.getCopyFromReg(Chain, dl, loReg, MVT::i32);
+        }
+        SDValue WholeValue =
+          DAG.getNode(ISD::BUILD_PAIR, dl, MVT::i64, LoVal, HiVal);
+        WholeValue = DAG.getNode(ISD::BITCAST, dl, MVT::f64, WholeValue);
+        InVals.push_back(WholeValue);
+        continue;
+      }
+      unsigned VReg = RegInfo.createVirtualRegister(&CBG::IntRegsRegClass);
+      MF.getRegInfo().addLiveIn(VA.getLocReg(), VReg);
+      SDValue Arg = DAG.getCopyFromReg(Chain, dl, VReg, MVT::i32);
+      if (VA.getLocVT() == MVT::f32)
+        Arg = DAG.getNode(ISD::BITCAST, dl, MVT::f32, Arg);
+      else if (VA.getLocVT() != MVT::i32) {
+        Arg = DAG.getNode(ISD::AssertSext, dl, MVT::i32, Arg,
+                          DAG.getValueType(VA.getLocVT()));
+        Arg = DAG.getNode(ISD::TRUNCATE, dl, VA.getLocVT(), Arg);
+      }
+      InVals.push_back(Arg);
+      continue;
+    }
+
+    assert(VA.isMemLoc());
+
+    unsigned Offset = VA.getLocMemOffset()+StackOffset;
+
+    if (VA.needsCustom()) {
+      assert(VA.getValVT() == MVT::f64);
+      //If it is double-word aligned, just load.
+      if (Offset % 8 == 0) {
+        int FI = MF.getFrameInfo()->CreateFixedObject(8,
+                                                      Offset,
+                                                      true);
+        SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy());
+        SDValue Load = DAG.getLoad(VA.getValVT(), dl, Chain, FIPtr,
+                                   MachinePointerInfo(),
+                                   false,false, 0);
+        InVals.push_back(Load);
+        continue;
+      }
+
+      int FI = MF.getFrameInfo()->CreateFixedObject(4,
+                                                    Offset,
+                                                    true);
+      SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy());
+      SDValue HiVal = DAG.getLoad(MVT::i32, dl, Chain, FIPtr,
+                                  MachinePointerInfo(),
+                                  false, false, 0);
+      int FI2 = MF.getFrameInfo()->CreateFixedObject(4,
+                                                     Offset+4,
+                                                     true);
+      SDValue FIPtr2 = DAG.getFrameIndex(FI2, getPointerTy());
+
+      SDValue LoVal = DAG.getLoad(MVT::i32, dl, Chain, FIPtr2,
+                                  MachinePointerInfo(),
+                                  false, false, 0);
+
+      SDValue WholeValue =
+        DAG.getNode(ISD::BUILD_PAIR, dl, MVT::i64, LoVal, HiVal);
+      WholeValue = DAG.getNode(ISD::BITCAST, dl, MVT::f64, WholeValue);
+      InVals.push_back(WholeValue);
+      continue;
+    }
+
+    int FI = MF.getFrameInfo()->CreateFixedObject(4,
+                                                  Offset,
+                                                  true);
+    SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy());
+    SDValue Load ;
+    if (VA.getValVT() == MVT::i32 || VA.getValVT() == MVT::f32) {
+      Load = DAG.getLoad(VA.getValVT(), dl, Chain, FIPtr,
+                         MachinePointerInfo(),
+                         false, false, 0);
+    } else {
+      ISD::LoadExtType LoadOp = ISD::SEXTLOAD;
+      // cbg is big endian, so add an offset based on the ObjectVT.
+      unsigned Offset = 4-std::max(1U, VA.getValVT().getSizeInBits()/8);
+      FIPtr = DAG.getNode(ISD::ADD, dl, MVT::i32, FIPtr,
+                          DAG.getConstant(Offset, MVT::i32));
+      Load = DAG.getExtLoad(LoadOp, dl, MVT::i32, Chain, FIPtr,
+                            MachinePointerInfo(),
+                            VA.getValVT(), false, false,0);
+      Load = DAG.getNode(ISD::TRUNCATE, dl, VA.getValVT(), Load);
+    }
+    InVals.push_back(Load);
+  }
+
+  if (MF.getFunction()->hasStructRetAttr()) {
+    //Copy the SRet Argument to SRetReturnReg
+    cbgMachineFunctionInfo *SFI = MF.getInfo<cbgMachineFunctionInfo>();
+    unsigned Reg = SFI->getSRetReturnReg();
+    if (!Reg) {
+      Reg = MF.getRegInfo().createVirtualRegister(&CBG::IntRegsRegClass);
+      SFI->setSRetReturnReg(Reg);
+    }
+    SDValue Copy = DAG.getCopyToReg(DAG.getEntryNode(), dl, Reg, InVals[0]);
+    Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other, Copy, Chain);
+  }
+
+  // Store remaining ArgRegs to the stack if this is a varargs function.
+  if (isVarArg) {
+    static const unsigned ArgRegs[] = {
+      CBG::I0, CBG::I1, CBG::I2, CBG::I3, CBG::I4, CBG::I5
+    };
+    unsigned NumAllocated = CCInfo.getFirstUnallocated(ArgRegs, 6);
+    const unsigned *CurArgReg = ArgRegs+NumAllocated, *ArgRegEnd = ArgRegs+6;
+    unsigned ArgOffset = CCInfo.getNextStackOffset();
+    if (NumAllocated == 6)
+      ArgOffset += StackOffset;
+    else {
+      assert(!ArgOffset);
+      ArgOffset = 68+4*NumAllocated;
+    }
+
+    // Remember the vararg offset for the va_start implementation.
+    FuncInfo->setVarArgsFrameOffset(ArgOffset);
+
+    std::vector<SDValue> OutChains;
+
+    for (; CurArgReg != ArgRegEnd; ++CurArgReg) {
+      unsigned VReg = RegInfo.createVirtualRegister(&CBG::IntRegsRegClass);
+      MF.getRegInfo().addLiveIn(*CurArgReg, VReg);
+      SDValue Arg = DAG.getCopyFromReg(DAG.getRoot(), dl, VReg, MVT::i32);
+
+      int FrameIdx = MF.getFrameInfo()->CreateFixedObject(4, ArgOffset,
+                                                          true);
+      SDValue FIPtr = DAG.getFrameIndex(FrameIdx, MVT::i32);
+
+      OutChains.push_back(DAG.getStore(DAG.getRoot(), dl, Arg, FIPtr,
+                                       MachinePointerInfo(),
+                                       false, false, 0));
+      ArgOffset += 4;
+    }
+
+    if (!OutChains.empty()) {
+      OutChains.push_back(Chain);
+      Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other,
+                          &OutChains[0], OutChains.size());
+    }
+  }
+
+  return Chain;
+}
+
+SDValue
+cbgTargetLowering::LowerCall(SDValue Chain, SDValue Callee,
+                               CallingConv::ID CallConv, bool isVarArg,
+                               bool &isTailCall,
+                               const SmallVectorImpl<ISD::OutputArg> &Outs,
+                               const SmallVectorImpl<SDValue> &OutVals,
+                               const SmallVectorImpl<ISD::InputArg> &Ins,
+                               DebugLoc dl, SelectionDAG &DAG,
+                               SmallVectorImpl<SDValue> &InVals) const {
+  // cbg target does not yet support tail call optimization.
+  isTailCall = false;
+
+  // Analyze operands of the call, assigning locations to each operand.
+  SmallVector<CCValAssign, 16> ArgLocs;
+  CCState CCInfo(CallConv, isVarArg, DAG.getTarget(), ArgLocs,
+                 *DAG.getContext());
+  CCInfo.AnalyzeCallOperands(Outs, CC_Sparc32);
+
+  // Get the size of the outgoing arguments stack space requirement.
+  unsigned ArgsSize = CCInfo.getNextStackOffset();
+
+  // Keep stack frames 8-byte aligned.
+  ArgsSize = (ArgsSize+7) & ~7;
+
+  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
+
+  //Create local copies for byval args.
+  SmallVector<SDValue, 8> ByValArgs;
+  for (unsigned i = 0,  e = Outs.size(); i != e; ++i) {
+    ISD::ArgFlagsTy Flags = Outs[i].Flags;
+    if (!Flags.isByVal())
+      continue;
+
+    SDValue Arg = OutVals[i];
+    unsigned Size = Flags.getByValSize();
+    unsigned Align = Flags.getByValAlign();
+
+    int FI = MFI->CreateStackObject(Size, Align, false);
+    SDValue FIPtr = DAG.getFrameIndex(FI, getPointerTy());
+    SDValue SizeNode = DAG.getConstant(Size, MVT::i32);
+
+    Chain = DAG.getMemcpy(Chain, dl, FIPtr, Arg, SizeNode, Align,
+                          false,        //isVolatile,
+                          (Size <= 32), //AlwaysInline if size <= 32
+                          MachinePointerInfo(), MachinePointerInfo());
+    ByValArgs.push_back(FIPtr);
+  }
+
+  Chain = DAG.getCALLSEQ_START(Chain, DAG.getIntPtrConstant(ArgsSize, true));
+
+  SmallVector<std::pair<unsigned, SDValue>, 8> RegsToPass;
+  SmallVector<SDValue, 8> MemOpChains;
+
+  const unsigned StackOffset = 92;
+  bool hasStructRetAttr = false;
+  // Walk the register/memloc assignments, inserting copies/loads.
+  for (unsigned i = 0, realArgIdx = 0, byvalArgIdx = 0, e = ArgLocs.size();
+       i != e;
+       ++i, ++realArgIdx) {
+    CCValAssign &VA = ArgLocs[i];
+    SDValue Arg = OutVals[realArgIdx];
+
+    ISD::ArgFlagsTy Flags = Outs[realArgIdx].Flags;
+
+    //Use local copy if it is a byval arg.
+    if (Flags.isByVal())
+      Arg = ByValArgs[byvalArgIdx++];
+
+    // Promote the value if needed.
+    switch (VA.getLocInfo()) {
+    default: llvm_unreachable("Unknown loc info!");
+    case CCValAssign::Full: break;
+    case CCValAssign::SExt:
+      Arg = DAG.getNode(ISD::SIGN_EXTEND, dl, VA.getLocVT(), Arg);
+      break;
+    case CCValAssign::ZExt:
+      Arg = DAG.getNode(ISD::ZERO_EXTEND, dl, VA.getLocVT(), Arg);
+      break;
+    case CCValAssign::AExt:
+      Arg = DAG.getNode(ISD::ANY_EXTEND, dl, VA.getLocVT(), Arg);
+      break;
+    case CCValAssign::BCvt:
+      Arg = DAG.getNode(ISD::BITCAST, dl, VA.getLocVT(), Arg);
+      break;
+    }
+
+    if (Flags.isSRet()) {
+      assert(VA.needsCustom());
+      // store SRet argument in %sp+64
+      SDValue StackPtr = DAG.getRegister(CBG::O6, MVT::i32);
+      SDValue PtrOff = DAG.getIntPtrConstant(64);
+      PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+      MemOpChains.push_back(DAG.getStore(Chain, dl, Arg, PtrOff,
+                                         MachinePointerInfo(),
+                                         false, false, 0));
+      hasStructRetAttr = true;
+      continue;
+    }
+
+    if (VA.needsCustom()) {
+      assert(VA.getLocVT() == MVT::f64);
+
+      if (VA.isMemLoc()) {
+        unsigned Offset = VA.getLocMemOffset() + StackOffset;
+        //if it is double-word aligned, just store.
+        if (Offset % 8 == 0) {
+          SDValue StackPtr = DAG.getRegister(CBG::O6, MVT::i32);
+          SDValue PtrOff = DAG.getIntPtrConstant(Offset);
+          PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+          MemOpChains.push_back(DAG.getStore(Chain, dl, Arg, PtrOff,
+                                             MachinePointerInfo(),
+                                             false, false, 0));
+          continue;
+        }
+      }
+
+      SDValue StackPtr = DAG.CreateStackTemporary(MVT::f64, MVT::i32);
+      SDValue Store = DAG.getStore(DAG.getEntryNode(), dl,
+                                   Arg, StackPtr, MachinePointerInfo(),
+                                   false, false, 0);
+      // cbg is big-endian, so the high part comes first.
+      SDValue Hi = DAG.getLoad(MVT::i32, dl, Store, StackPtr,
+                               MachinePointerInfo(), false, false, 0);
+      // Increment the pointer to the other half.
+      StackPtr = DAG.getNode(ISD::ADD, dl, StackPtr.getValueType(), StackPtr,
+                             DAG.getIntPtrConstant(4));
+      // Load the low part.
+      SDValue Lo = DAG.getLoad(MVT::i32, dl, Store, StackPtr,
+                               MachinePointerInfo(), false, false, 0);
+
+      if (VA.isRegLoc()) {
+        RegsToPass.push_back(std::make_pair(VA.getLocReg(), Hi));
+        assert(i+1 != e);
+        CCValAssign &NextVA = ArgLocs[++i];
+        if (NextVA.isRegLoc()) {
+          RegsToPass.push_back(std::make_pair(NextVA.getLocReg(), Lo));
+        } else {
+          //Store the low part in stack.
+          unsigned Offset = NextVA.getLocMemOffset() + StackOffset;
+          SDValue StackPtr = DAG.getRegister(CBG::O6, MVT::i32);
+          SDValue PtrOff = DAG.getIntPtrConstant(Offset);
+          PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+          MemOpChains.push_back(DAG.getStore(Chain, dl, Lo, PtrOff,
+                                             MachinePointerInfo(),
+                                             false, false, 0));
+        }
+      } else {
+        unsigned Offset = VA.getLocMemOffset() + StackOffset;
+        // Store the high part.
+        SDValue StackPtr = DAG.getRegister(CBG::O6, MVT::i32);
+        SDValue PtrOff = DAG.getIntPtrConstant(Offset);
+        PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+        MemOpChains.push_back(DAG.getStore(Chain, dl, Hi, PtrOff,
+                                           MachinePointerInfo(),
+                                           false, false, 0));
+        // Store the low part.
+        PtrOff = DAG.getIntPtrConstant(Offset+4);
+        PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+        MemOpChains.push_back(DAG.getStore(Chain, dl, Lo, PtrOff,
+                                           MachinePointerInfo(),
+                                           false, false, 0));
+      }
+      continue;
+    }
+
+    // Arguments that can be passed on register must be kept at
+    // RegsToPass vector
+    if (VA.isRegLoc()) {
+      if (VA.getLocVT() != MVT::f32) {
+        RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
+        continue;
+      }
+      Arg = DAG.getNode(ISD::BITCAST, dl, MVT::i32, Arg);
+      RegsToPass.push_back(std::make_pair(VA.getLocReg(), Arg));
+      continue;
+    }
+
+    assert(VA.isMemLoc());
+
+    // Create a store off the stack pointer for this argument.
+    SDValue StackPtr = DAG.getRegister(CBG::O6, MVT::i32);
+    SDValue PtrOff = DAG.getIntPtrConstant(VA.getLocMemOffset()+StackOffset);
+    PtrOff = DAG.getNode(ISD::ADD, dl, MVT::i32, StackPtr, PtrOff);
+    MemOpChains.push_back(DAG.getStore(Chain, dl, Arg, PtrOff,
+                                       MachinePointerInfo(),
+                                       false, false, 0));
+  }
+
+
+  // Emit all stores, make sure the occur before any copies into physregs.
+  if (!MemOpChains.empty())
+    Chain = DAG.getNode(ISD::TokenFactor, dl, MVT::Other,
+                        &MemOpChains[0], MemOpChains.size());
+
+  // Build a sequence of copy-to-reg nodes chained together with token
+  // chain and flag operands which copy the outgoing args into registers.
+  // The InFlag in necessary since all emited instructions must be
+  // stuck together.
+  SDValue InFlag;
+  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i) {
+    unsigned Reg = RegsToPass[i].first;
+    // Remap I0->I7 -> O0->O7.
+    if (Reg >= CBG::I0 && Reg <= CBG::I7)
+      Reg = Reg-CBG::I0+CBG::O0;
+
+    Chain = DAG.getCopyToReg(Chain, dl, Reg, RegsToPass[i].second, InFlag);
+    InFlag = Chain.getValue(1);
+  }
+
+  unsigned SRetArgSize = (hasStructRetAttr)? getSRetArgSize(DAG, Callee):0;
+
+  // If the callee is a GlobalAddress node (quite common, every direct call is)
+  // turn it into a TargetGlobalAddress node so that legalize doesn't hack it.
+  // Likewise ExternalSymbol -> TargetExternalSymbol.
+  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee))
+    Callee = DAG.getTargetGlobalAddress(G->getGlobal(), dl, MVT::i32);
+  else if (ExternalSymbolSDNode *E = dyn_cast<ExternalSymbolSDNode>(Callee))
+    Callee = DAG.getTargetExternalSymbol(E->getSymbol(), MVT::i32);
+
+  // Returns a chain & a flag for retval copy to use
+  SDVTList NodeTys = DAG.getVTList(MVT::Other, MVT::Glue);
+  SmallVector<SDValue, 8> Ops;
+  Ops.push_back(Chain);
+  Ops.push_back(Callee);
+  if (hasStructRetAttr)
+    Ops.push_back(DAG.getTargetConstant(SRetArgSize, MVT::i32));
+  for (unsigned i = 0, e = RegsToPass.size(); i != e; ++i) {
+    unsigned Reg = RegsToPass[i].first;
+    if (Reg >= CBG::I0 && Reg <= CBG::I7)
+      Reg = Reg-CBG::I0+CBG::O0;
+
+    Ops.push_back(DAG.getRegister(Reg, RegsToPass[i].second.getValueType()));
+  }
+  if (InFlag.getNode())
+    Ops.push_back(InFlag);
+
+  Chain = DAG.getNode(SPISD::CALL, dl, NodeTys, &Ops[0], Ops.size());
+  InFlag = Chain.getValue(1);
+
+  Chain = DAG.getCALLSEQ_END(Chain, DAG.getIntPtrConstant(ArgsSize, true),
+                             DAG.getIntPtrConstant(0, true), InFlag);
+  InFlag = Chain.getValue(1);
+
+  // Assign locations to each value returned by this call.
+  SmallVector<CCValAssign, 16> RVLocs;
+  CCState RVInfo(CallConv, isVarArg, DAG.getTarget(),
+                 RVLocs, *DAG.getContext());
+
+  RVInfo.AnalyzeCallResult(Ins, RetCC_Sparc32);
+
+  // Copy all of the result registers out of their specified physreg.
+  for (unsigned i = 0; i != RVLocs.size(); ++i) {
+    unsigned Reg = RVLocs[i].getLocReg();
+
+    // Remap I0->I7 -> O0->O7.
+    if (Reg >= CBG::I0 && Reg <= CBG::I7)
+      Reg = Reg-CBG::I0+CBG::O0;
+
+    Chain = DAG.getCopyFromReg(Chain, dl, Reg,
+                               RVLocs[i].getValVT(), InFlag).getValue(1);
+    InFlag = Chain.getValue(2);
+    InVals.push_back(Chain.getValue(0));
+  }
+
+  return Chain;
+}
+
+unsigned
+cbgTargetLowering::getSRetArgSize(SelectionDAG &DAG, SDValue Callee) const
+{
+  const Function *CalleeFn = 0;
+  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(Callee)) {
+    CalleeFn = dyn_cast<Function>(G->getGlobal());
+  } else if (ExternalSymbolSDNode *E =
+             dyn_cast<ExternalSymbolSDNode>(Callee)) {
+    const Function *Fn = DAG.getMachineFunction().getFunction();
+    const Module *M = Fn->getParent();
+    CalleeFn = M->getFunction(E->getSymbol());
+  }
+
+  if (!CalleeFn)
+    return 0;
+
+  assert(CalleeFn->hasStructRetAttr() &&
+         "Callee does not have the StructRet attribute.");
+
+  const PointerType *Ty = cast<PointerType>(CalleeFn->arg_begin()->getType());
+  const Type *ElementTy = Ty->getElementType();
+  return getTargetData()->getTypeAllocSize(ElementTy);
+}
+
+//===----------------------------------------------------------------------===//
+// TargetLowering Implementation
+//===----------------------------------------------------------------------===//
+
+/// IntCondCCodeToICC - Convert a DAG integer condition code to a SPARC ICC
+/// condition.
+static CBGCC::CondCodes IntCondCCodeToICC(ISD::CondCode CC) {
+  switch (CC) {
+  default: llvm_unreachable("Unknown integer condition code!");
+  case ISD::SETEQ:  return CBGCC::ICC_E;
+  case ISD::SETNE:  return CBGCC::ICC_NE;
+  case ISD::SETLT:  return CBGCC::ICC_L;
+  case ISD::SETGT:  return CBGCC::ICC_G;
+  case ISD::SETLE:  return CBGCC::ICC_LE;
+  case ISD::SETGE:  return CBGCC::ICC_GE;
+  case ISD::SETULT: return CBGCC::ICC_CS;
+  case ISD::SETULE: return CBGCC::ICC_LEU;
+  case ISD::SETUGT: return CBGCC::ICC_GU;
+  case ISD::SETUGE: return CBGCC::ICC_CC;
+  }
+}
+
+/// FPCondCCodeToFCC - Convert a DAG floatingp oint condition code to a SPARC
+/// FCC condition.
+static CBGCC::CondCodes FPCondCCodeToFCC(ISD::CondCode CC) {
+  switch (CC) {
+  default: llvm_unreachable("Unknown fp condition code!");
+  case ISD::SETEQ:
+  case ISD::SETOEQ: return CBGCC::FCC_E;
+  case ISD::SETNE:
+  case ISD::SETUNE: return CBGCC::FCC_NE;
+  case ISD::SETLT:
+  case ISD::SETOLT: return CBGCC::FCC_L;
+  case ISD::SETGT:
+  case ISD::SETOGT: return CBGCC::FCC_G;
+  case ISD::SETLE:
+  case ISD::SETOLE: return CBGCC::FCC_LE;
+  case ISD::SETGE:
+  case ISD::SETOGE: return CBGCC::FCC_GE;
+  case ISD::SETULT: return CBGCC::FCC_UL;
+  case ISD::SETULE: return CBGCC::FCC_ULE;
+  case ISD::SETUGT: return CBGCC::FCC_UG;
+  case ISD::SETUGE: return CBGCC::FCC_UGE;
+  case ISD::SETUO:  return CBGCC::FCC_U;
+  case ISD::SETO:   return CBGCC::FCC_O;
+  case ISD::SETONE: return CBGCC::FCC_LG;
+  case ISD::SETUEQ: return CBGCC::FCC_UE;
+  }
+}
+
+cbgTargetLowering::cbgTargetLowering(TargetMachine &TM)
+  : TargetLowering(TM, new TargetLoweringObjectFileELF()), ST(&(TM.getSubtarget<cbgSubtarget>())) {
+
+  // Set up the register classes.
+  addRegisterClass(MVT::i32, CBG::IntRegsRegisterClass);
+  addRegisterClass(MVT::f32, CBG::FPRegsRegisterClass);
+  addRegisterClass(MVT::f64, CBG::DFPRegsRegisterClass);
+
+  // Turn FP extload into load/fextend
+  setLoadExtAction(ISD::EXTLOAD, MVT::f32, Expand);
+  // Sparc doesn't have i1 sign extending load
+  setLoadExtAction(ISD::SEXTLOAD, MVT::i1, Promote);
+  // Turn FP truncstore into trunc + store.
+  setTruncStoreAction(MVT::f64, MVT::f32, Expand);
+
+  // Custom legalize GlobalAddress nodes into LO/HI parts.
+  setOperationAction(ISD::GlobalAddress, MVT::i32, Custom);
+  setOperationAction(ISD::GlobalTLSAddress, MVT::i32, Custom);
+  setOperationAction(ISD::ConstantPool , MVT::i32, Custom);
+
+  // Sparc doesn't have sext_inreg, replace them with shl/sra
+  setOperationAction(ISD::SIGN_EXTEND_INREG, MVT::i16, Expand);
+  setOperationAction(ISD::SIGN_EXTEND_INREG, MVT::i8 , Expand);
+  setOperationAction(ISD::SIGN_EXTEND_INREG, MVT::i1 , Expand);
+
+  // Sparc has no REM or DIVREM operations.
+  setOperationAction(ISD::UREM, MVT::i32, Expand);
+  setOperationAction(ISD::SREM, MVT::i32, Expand);
+  setOperationAction(ISD::SDIVREM, MVT::i32, Expand);
+  setOperationAction(ISD::UDIVREM, MVT::i32, Expand);
+
+  // Custom expand fp<->sint
+  setOperationAction(ISD::FP_TO_SINT, MVT::i32, Custom);
+  setOperationAction(ISD::SINT_TO_FP, MVT::i32, Custom);
+
+  // Expand fp<->uint
+  setOperationAction(ISD::FP_TO_UINT, MVT::i32, Expand);
+  setOperationAction(ISD::UINT_TO_FP, MVT::i32, Expand);
+
+  setOperationAction(ISD::BITCAST, MVT::f32, Expand);
+  setOperationAction(ISD::BITCAST, MVT::i32, Expand);
+
+  // Sparc has no select or setcc: expand to SELECT_CC.
+  setOperationAction(ISD::SELECT, MVT::i32, Expand);
+  setOperationAction(ISD::SELECT, MVT::f32, Expand);
+  setOperationAction(ISD::SELECT, MVT::f64, Expand);
+  setOperationAction(ISD::SETCC, MVT::i32, Expand);
+  setOperationAction(ISD::SETCC, MVT::f32, Expand);
+  setOperationAction(ISD::SETCC, MVT::f64, Expand);
+
+  // Sparc doesn't have BRCOND either, it has BR_CC.
+  setOperationAction(ISD::BRCOND, MVT::Other, Expand);
+  setOperationAction(ISD::BRIND, MVT::Other, Expand);
+  setOperationAction(ISD::BR_JT, MVT::Other, Expand);
+  setOperationAction(ISD::BR_CC, MVT::i32, Custom);
+  setOperationAction(ISD::BR_CC, MVT::f32, Custom);
+  setOperationAction(ISD::BR_CC, MVT::f64, Custom);
+
+  setOperationAction(ISD::SELECT_CC, MVT::i32, Custom);
+  setOperationAction(ISD::SELECT_CC, MVT::f32, Custom);
+  setOperationAction(ISD::SELECT_CC, MVT::f64, Custom);
+
+  // SPARC has no intrinsics for these particular operations.
+  setOperationAction(ISD::MEMBARRIER, MVT::Other, Expand);
+
+  setOperationAction(ISD::FSIN , MVT::f64, Expand);
+  setOperationAction(ISD::FCOS , MVT::f64, Expand);
+  setOperationAction(ISD::FREM , MVT::f64, Expand);
+  setOperationAction(ISD::FSIN , MVT::f32, Expand);
+  setOperationAction(ISD::FCOS , MVT::f32, Expand);
+  setOperationAction(ISD::FREM , MVT::f32, Expand);
+  setOperationAction(ISD::CTPOP, MVT::i32, Expand);
+  setOperationAction(ISD::CTTZ , MVT::i32, Expand);
+  setOperationAction(ISD::CTLZ , MVT::i32, Expand);
+  setOperationAction(ISD::ROTL , MVT::i32, Expand);
+  setOperationAction(ISD::ROTR , MVT::i32, Expand);
+  setOperationAction(ISD::BSWAP, MVT::i32, Expand);
+  setOperationAction(ISD::FCOPYSIGN, MVT::f64, Expand);
+  setOperationAction(ISD::FCOPYSIGN, MVT::f32, Expand);
+  setOperationAction(ISD::FPOW , MVT::f64, Expand);
+  setOperationAction(ISD::FPOW , MVT::f32, Expand);
+
+  setOperationAction(ISD::SHL_PARTS, MVT::i32, Expand);
+  setOperationAction(ISD::SRA_PARTS, MVT::i32, Expand);
+  setOperationAction(ISD::SRL_PARTS, MVT::i32, Expand);
+
+  // FIXME: Sparc provides these multiplies, but we don't have them yet.
+  setOperationAction(ISD::UMUL_LOHI, MVT::i32, Expand);
+  setOperationAction(ISD::SMUL_LOHI, MVT::i32, Expand);
+
+  setOperationAction(ISD::EH_LABEL, MVT::Other, Expand);
+
+  // VASTART needs to be custom lowered to use the VarArgsFrameIndex.
+  setOperationAction(ISD::VASTART           , MVT::Other, Custom);
+  // VAARG needs to be lowered to not do unaligned accesses for doubles.
+  setOperationAction(ISD::VAARG             , MVT::Other, Custom);
+
+  // Use the default implementation.
+  setOperationAction(ISD::VACOPY            , MVT::Other, Expand);
+  setOperationAction(ISD::VAEND             , MVT::Other, Expand);
+  setOperationAction(ISD::STACKSAVE         , MVT::Other, Expand);
+  setOperationAction(ISD::STACKRESTORE      , MVT::Other, Expand);
+  setOperationAction(ISD::DYNAMIC_STACKALLOC, MVT::i32  , Custom);
+
+  // No debug info support yet.
+  setOperationAction(ISD::EH_LABEL, MVT::Other, Expand);
+
+  setStackPointerRegisterToSaveRestore(CBG::O6);
+
+  /*if (TM.getSubtarget<cbgSubtarget>().isV9())
+    setOperationAction(ISD::CTPOP, MVT::i32, Legal);*/
+
+  computeRegisterProperties();
+}
+
+const char *cbgTargetLowering::getTargetNodeName(unsigned Opcode) const {
+  switch (Opcode) {
+  default: return 0;
+  case SPISD::CMPICC:     return "SPISD::CMPICC";
+  case SPISD::CMPFCC:     return "SPISD::CMPFCC";
+  case SPISD::BRICC:      return "SPISD::BRICC";
+  case SPISD::BRFCC:      return "SPISD::BRFCC";
+  case SPISD::SELECT_ICC: return "SPISD::SELECT_ICC";
+  case SPISD::SELECT_FCC: return "SPISD::SELECT_FCC";
+  case SPISD::Hi:         return "SPISD::Hi";
+  case SPISD::Lo:         return "SPISD::Lo";
+  case SPISD::FTOI:       return "SPISD::FTOI";
+  case SPISD::ITOF:       return "SPISD::ITOF";
+  case SPISD::CALL:       return "SPISD::CALL";
+  case SPISD::RET_FLAG:   return "SPISD::RET_FLAG";
+  case SPISD::GLOBAL_BASE_REG: return "SPISD::GLOBAL_BASE_REG";
+  case SPISD::FLUSHW:     return "SPISD::FLUSHW";
+  }
+}
+
+/// isMaskedValueZeroForTargetNode - Return true if 'Op & Mask' is known to
+/// be zero. Op is expected to be a target specific node. Used by DAG
+/// combiner.
+void cbgTargetLowering::computeMaskedBitsForTargetNode(const SDValue Op,
+                                                         const APInt &Mask,
+                                                         APInt &KnownZero,
+                                                         APInt &KnownOne,
+                                                         const SelectionDAG &DAG,
+                                                         unsigned Depth) const {
+  APInt KnownZero2, KnownOne2;
+  KnownZero = KnownOne = APInt(Mask.getBitWidth(), 0);   // Don't know anything.
+
+  switch (Op.getOpcode()) {
+  default: break;
+  case SPISD::SELECT_ICC:
+  case SPISD::SELECT_FCC:
+    DAG.ComputeMaskedBits(Op.getOperand(1), Mask, KnownZero, KnownOne,
+                          Depth+1);
+    DAG.ComputeMaskedBits(Op.getOperand(0), Mask, KnownZero2, KnownOne2,
+                          Depth+1);
+    assert((KnownZero & KnownOne) == 0 && "Bits known to be one AND zero?");
+    assert((KnownZero2 & KnownOne2) == 0 && "Bits known to be one AND zero?");
+
+    // Only known if known in both the LHS and RHS.
+    KnownOne &= KnownOne2;
+    KnownZero &= KnownZero2;
+    break;
+  }
+}
+
+// Look at LHS/RHS/CC and see if they are a lowered setcc instruction.  If so
+// set LHS/RHS and SPCC to the LHS/RHS of the setcc and SPCC to the condition.
+static void LookThroughSetCC(SDValue &LHS, SDValue &RHS,
+                             ISD::CondCode CC, unsigned &SPCC) {
+  if (isa<ConstantSDNode>(RHS) &&
+      cast<ConstantSDNode>(RHS)->isNullValue() &&
+      CC == ISD::SETNE &&
+      ((LHS.getOpcode() == SPISD::SELECT_ICC &&
+        LHS.getOperand(3).getOpcode() == SPISD::CMPICC) ||
+       (LHS.getOpcode() == SPISD::SELECT_FCC &&
+        LHS.getOperand(3).getOpcode() == SPISD::CMPFCC)) &&
+      isa<ConstantSDNode>(LHS.getOperand(0)) &&
+      isa<ConstantSDNode>(LHS.getOperand(1)) &&
+      cast<ConstantSDNode>(LHS.getOperand(0))->isOne() &&
+      cast<ConstantSDNode>(LHS.getOperand(1))->isNullValue()) {
+    SDValue CMPCC = LHS.getOperand(3);
+    SPCC = cast<ConstantSDNode>(LHS.getOperand(2))->getZExtValue();
+    LHS = CMPCC.getOperand(0);
+    RHS = CMPCC.getOperand(1);
+  }
+}
+
+SDValue cbgTargetLowering::LowerGlobalAddress(SDValue Op,
+                                                SelectionDAG &DAG) const {
+  const GlobalValue *GV = cast<GlobalAddressSDNode>(Op)->getGlobal();
+  // FIXME there isn't really any debug info here
+  DebugLoc dl = Op.getDebugLoc();
+  SDValue GA = DAG.getTargetGlobalAddress(GV, dl, MVT::i32);
+  SDValue Hi = DAG.getNode(SPISD::Hi, dl, MVT::i32, GA);
+  SDValue Lo = DAG.getNode(SPISD::Lo, dl, MVT::i32, GA);
+
+  if (getTargetMachine().getRelocationModel() != Reloc::PIC_)
+    return DAG.getNode(ISD::ADD, dl, MVT::i32, Lo, Hi);
+
+  SDValue GlobalBase = DAG.getNode(SPISD::GLOBAL_BASE_REG, dl,
+                                   getPointerTy());
+  SDValue RelAddr = DAG.getNode(ISD::ADD, dl, MVT::i32, Lo, Hi);
+  SDValue AbsAddr = DAG.getNode(ISD::ADD, dl, MVT::i32,
+                                GlobalBase, RelAddr);
+  return DAG.getLoad(getPointerTy(), dl, DAG.getEntryNode(),
+                     AbsAddr, MachinePointerInfo(), false, false, 0);
+}
+
+SDValue cbgTargetLowering::LowerConstantPool(SDValue Op,
+                                               SelectionDAG &DAG) const {
+  ConstantPoolSDNode *N = cast<ConstantPoolSDNode>(Op);
+  // FIXME there isn't really any debug info here
+  DebugLoc dl = Op.getDebugLoc();
+  const Constant *C = N->getConstVal();
+  SDValue CP = DAG.getTargetConstantPool(C, MVT::i32, N->getAlignment());
+  SDValue Hi = DAG.getNode(SPISD::Hi, dl, MVT::i32, CP);
+  SDValue Lo = DAG.getNode(SPISD::Lo, dl, MVT::i32, CP);
+  if (getTargetMachine().getRelocationModel() != Reloc::PIC_)
+    return DAG.getNode(ISD::ADD, dl, MVT::i32, Lo, Hi);
+
+  SDValue GlobalBase = DAG.getNode(SPISD::GLOBAL_BASE_REG, dl,
+                                   getPointerTy());
+  SDValue RelAddr = DAG.getNode(ISD::ADD, dl, MVT::i32, Lo, Hi);
+  SDValue AbsAddr = DAG.getNode(ISD::ADD, dl, MVT::i32,
+                                GlobalBase, RelAddr);
+  return DAG.getLoad(getPointerTy(), dl, DAG.getEntryNode(),
+                     AbsAddr, MachinePointerInfo(), false, false, 0);
+}
+
+static SDValue LowerFP_TO_SINT(SDValue Op, SelectionDAG &DAG) {
+  DebugLoc dl = Op.getDebugLoc();
+  // Convert the fp value to integer in an FP register.
+  assert(Op.getValueType() == MVT::i32);
+  Op = DAG.getNode(SPISD::FTOI, dl, MVT::f32, Op.getOperand(0));
+  return DAG.getNode(ISD::BITCAST, dl, MVT::i32, Op);
+}
+
+static SDValue LowerSINT_TO_FP(SDValue Op, SelectionDAG &DAG) {
+  DebugLoc dl = Op.getDebugLoc();
+  assert(Op.getOperand(0).getValueType() == MVT::i32);
+  SDValue Tmp = DAG.getNode(ISD::BITCAST, dl, MVT::f32, Op.getOperand(0));
+  // Convert the int value to FP in an FP register.
+  return DAG.getNode(SPISD::ITOF, dl, Op.getValueType(), Tmp);
+}
+
+static SDValue LowerBR_CC(SDValue Op, SelectionDAG &DAG) {
+  SDValue Chain = Op.getOperand(0);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(1))->get();
+  SDValue LHS = Op.getOperand(2);
+  SDValue RHS = Op.getOperand(3);
+  SDValue Dest = Op.getOperand(4);
+  DebugLoc dl = Op.getDebugLoc();
+  unsigned Opc, SPCC = ~0U;
+
+  // If this is a br_cc of a "setcc", and if the setcc got lowered into
+  // an CMP[IF]CC/SELECT_[IF]CC pair, find the original compared values.
+  LookThroughSetCC(LHS, RHS, CC, SPCC);
+
+  // Get the condition flag.
+  SDValue CompareFlag;
+  if (LHS.getValueType() == MVT::i32) {
+    std::vector<EVT> VTs;
+    VTs.push_back(MVT::i32);
+    VTs.push_back(MVT::Glue);
+    SDValue Ops[2] = { LHS, RHS };
+    CompareFlag = DAG.getNode(SPISD::CMPICC, dl, VTs, Ops, 2).getValue(1);
+    if (SPCC == ~0U) SPCC = IntCondCCodeToICC(CC);
+    Opc = SPISD::BRICC;
+  } else {
+    CompareFlag = DAG.getNode(SPISD::CMPFCC, dl, MVT::Glue, LHS, RHS);
+    if (SPCC == ~0U) SPCC = FPCondCCodeToFCC(CC);
+    Opc = SPISD::BRFCC;
+  }
+  return DAG.getNode(Opc, dl, MVT::Other, Chain, Dest,
+                     DAG.getConstant(SPCC, MVT::i32), CompareFlag);
+}
+
+static SDValue LowerSELECT_CC(SDValue Op, SelectionDAG &DAG, const cbgSubtarget* ST) {
+
+  SDValue LHS = Op.getOperand(0);
+  SDValue RHS = Op.getOperand(1);
+  ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
+  SDValue TrueVal = Op.getOperand(2);
+  SDValue FalseVal = Op.getOperand(3);
+  DebugLoc dl = Op.getDebugLoc();
+  unsigned Opc, SPCC = ~0U;
+
+  // If this is a select_cc of a "setcc", and if the setcc got lowered into
+  // an CMP[IF]CC/SELECT_[IF]CC pair, find the original compared values.
+  LookThroughSetCC(LHS, RHS, CC, SPCC);
+
+  SDValue CompareFlag;
+  if (LHS.getValueType() == MVT::i32) {
+    std::vector<EVT> VTs;
+    VTs.push_back(LHS.getValueType());   // subcc returns a value
+    VTs.push_back(MVT::Glue);
+    SDValue Ops[2] = { LHS, RHS };
+    CompareFlag = DAG.getNode(SPISD::CMPICC, dl, VTs, Ops, 2).getValue(1);
+    Opc = SPISD::SELECT_ICC;
+    if (SPCC == ~0U) SPCC = IntCondCCodeToICC(CC);
+    // change true and false value if immediate is true value
+    // and reverse condition code
+    if (ST->hasSelCC() && TrueVal.getNumOperands() == 0 && FalseVal.getNumOperands() != 0) {
+//      std::cerr << __func__ << "(): subtarget supports predicated instructions: " << ST->usePredicatedInstructions() << std::endl;
+      SDValue tmpSDNode = TrueVal;
+      TrueVal = FalseVal;
+      FalseVal = tmpSDNode;
+//      std::cerr << __func__ << "(): changed order of input values." << std::endl;
+      SPCC = static_cast<unsigned>(CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(SPCC)));
+    }
+  } else {
+    CompareFlag = DAG.getNode(SPISD::CMPFCC, dl, MVT::Glue, LHS, RHS);
+    Opc = SPISD::SELECT_FCC;
+    if (SPCC == ~0U) SPCC = FPCondCCodeToFCC(CC);
+  }
+  return DAG.getNode(Opc, dl, TrueVal.getValueType(), TrueVal, FalseVal,
+                     DAG.getConstant(SPCC, MVT::i32), CompareFlag);
+}
+
+static SDValue LowerVASTART(SDValue Op, SelectionDAG &DAG,
+                            const cbgTargetLowering &TLI) {
+  MachineFunction &MF = DAG.getMachineFunction();
+  cbgMachineFunctionInfo *FuncInfo = MF.getInfo<cbgMachineFunctionInfo>();
+
+  // vastart just stores the address of the VarArgsFrameIndex slot into the
+  // memory location argument.
+  DebugLoc dl = Op.getDebugLoc();
+  SDValue Offset =
+    DAG.getNode(ISD::ADD, dl, MVT::i32,
+                DAG.getRegister(CBG::I6, MVT::i32),
+                DAG.getConstant(FuncInfo->getVarArgsFrameOffset(),
+                                MVT::i32));
+  const Value *SV = cast<SrcValueSDNode>(Op.getOperand(2))->getValue();
+  return DAG.getStore(Op.getOperand(0), dl, Offset, Op.getOperand(1),
+                      MachinePointerInfo(SV), false, false, 0);
+}
+
+static SDValue LowerVAARG(SDValue Op, SelectionDAG &DAG) {
+  SDNode *Node = Op.getNode();
+  EVT VT = Node->getValueType(0);
+  SDValue InChain = Node->getOperand(0);
+  SDValue VAListPtr = Node->getOperand(1);
+  const Value *SV = cast<SrcValueSDNode>(Node->getOperand(2))->getValue();
+  DebugLoc dl = Node->getDebugLoc();
+  SDValue VAList = DAG.getLoad(MVT::i32, dl, InChain, VAListPtr,
+                               MachinePointerInfo(SV), false, false, 0);
+  // Increment the pointer, VAList, to the next vaarg
+  SDValue NextPtr = DAG.getNode(ISD::ADD, dl, MVT::i32, VAList,
+                                  DAG.getConstant(VT.getSizeInBits()/8,
+                                                  MVT::i32));
+  // Store the incremented VAList to the legalized pointer
+  InChain = DAG.getStore(VAList.getValue(1), dl, NextPtr,
+                         VAListPtr, MachinePointerInfo(SV), false, false, 0);
+  // Load the actual argument out of the pointer VAList, unless this is an
+  // f64 load.
+  if (VT != MVT::f64)
+    return DAG.getLoad(VT, dl, InChain, VAList, MachinePointerInfo(),
+                       false, false, 0);
+
+  // Otherwise, load it as i64, then do a bitconvert.
+  SDValue V = DAG.getLoad(MVT::i64, dl, InChain, VAList, MachinePointerInfo(),
+                          false, false, 0);
+
+  // Bit-Convert the value to f64.
+  SDValue Ops[2] = {
+    DAG.getNode(ISD::BITCAST, dl, MVT::f64, V),
+    V.getValue(1)
+  };
+  return DAG.getMergeValues(Ops, 2, dl);
+}
+
+static SDValue LowerDYNAMIC_STACKALLOC(SDValue Op, SelectionDAG &DAG) {
+  SDValue Chain = Op.getOperand(0);  // Legalize the chain.
+  SDValue Size  = Op.getOperand(1);  // Legalize the size.
+  DebugLoc dl = Op.getDebugLoc();
+
+  unsigned SPReg = CBG::O6;
+  SDValue SP = DAG.getCopyFromReg(Chain, dl, SPReg, MVT::i32);
+  SDValue NewSP = DAG.getNode(ISD::SUB, dl, MVT::i32, SP, Size); // Value
+  Chain = DAG.getCopyToReg(SP.getValue(1), dl, SPReg, NewSP);    // Output chain
+
+  // The resultant pointer is actually 16 words from the bottom of the stack,
+  // to provide a register spill area.
+  SDValue NewVal = DAG.getNode(ISD::ADD, dl, MVT::i32, NewSP,
+                                 DAG.getConstant(96, MVT::i32));
+  SDValue Ops[2] = { NewVal, Chain };
+  return DAG.getMergeValues(Ops, 2, dl);
+}
+
+
+static SDValue getFLUSHW(SDValue Op, SelectionDAG &DAG) {
+  DebugLoc dl = Op.getDebugLoc();
+  SDValue Chain = DAG.getNode(SPISD::FLUSHW,
+                              dl, MVT::Other, DAG.getEntryNode());
+  return Chain;
+}
+
+static SDValue LowerFRAMEADDR(SDValue Op, SelectionDAG &DAG) {
+  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
+  MFI->setFrameAddressIsTaken(true);
+
+  EVT VT = Op.getValueType();
+  DebugLoc dl = Op.getDebugLoc();
+  unsigned FrameReg = CBG::I6;
+
+  uint64_t depth = Op.getConstantOperandVal(0);
+
+  SDValue FrameAddr;
+  if (depth == 0)
+    FrameAddr = DAG.getCopyFromReg(DAG.getEntryNode(), dl, FrameReg, VT);
+  else {
+    // flush first to make sure the windowed registers' values are in stack
+    SDValue Chain = getFLUSHW(Op, DAG);
+    FrameAddr = DAG.getCopyFromReg(Chain, dl, FrameReg, VT);
+
+    for (uint64_t i = 0; i != depth; ++i) {
+      SDValue Ptr = DAG.getNode(ISD::ADD,
+                                dl, MVT::i32,
+                                FrameAddr, DAG.getIntPtrConstant(56));
+      FrameAddr = DAG.getLoad(MVT::i32, dl,
+                              Chain,
+                              Ptr,
+                              MachinePointerInfo(), false, false, 0);
+    }
+  }
+  return FrameAddr;
+}
+
+static SDValue LowerRETURNADDR(SDValue Op, SelectionDAG &DAG) {
+  MachineFrameInfo *MFI = DAG.getMachineFunction().getFrameInfo();
+  MFI->setReturnAddressIsTaken(true);
+
+  EVT VT = Op.getValueType();
+  DebugLoc dl = Op.getDebugLoc();
+  unsigned RetReg = CBG::I7;
+
+  uint64_t depth = Op.getConstantOperandVal(0);
+
+  SDValue RetAddr;
+  if (depth == 0)
+    RetAddr = DAG.getCopyFromReg(DAG.getEntryNode(), dl, RetReg, VT);
+  else {
+    // flush first to make sure the windowed registers' values are in stack
+    SDValue Chain = getFLUSHW(Op, DAG);
+    RetAddr = DAG.getCopyFromReg(Chain, dl, CBG::I6, VT);
+
+    for (uint64_t i = 0; i != depth; ++i) {
+      SDValue Ptr = DAG.getNode(ISD::ADD,
+                                dl, MVT::i32,
+                                RetAddr,
+                                DAG.getIntPtrConstant((i == depth-1)?60:56));
+      RetAddr = DAG.getLoad(MVT::i32, dl,
+                            Chain,
+                            Ptr,
+                            MachinePointerInfo(), false, false, 0);
+    }
+  }
+  return RetAddr;
+}
+
+SDValue cbgTargetLowering::
+LowerOperation(SDValue Op, SelectionDAG &DAG) const {
+  switch (Op.getOpcode()) {
+  default: llvm_unreachable("Should not custom lower this!");
+  case ISD::RETURNADDR:         return LowerRETURNADDR(Op, DAG);
+  case ISD::FRAMEADDR:          return LowerFRAMEADDR(Op, DAG);
+  case ISD::GlobalTLSAddress:
+    llvm_unreachable("TLS not implemented for CBG.");
+  case ISD::GlobalAddress:      return LowerGlobalAddress(Op, DAG);
+  case ISD::ConstantPool:       return LowerConstantPool(Op, DAG);
+  case ISD::FP_TO_SINT:         return LowerFP_TO_SINT(Op, DAG);
+  case ISD::SINT_TO_FP:         return LowerSINT_TO_FP(Op, DAG);
+  case ISD::BR_CC:              return LowerBR_CC(Op, DAG);
+  case ISD::SELECT_CC:          return LowerSELECT_CC(Op, DAG, this->ST);
+  case ISD::VASTART:            return LowerVASTART(Op, DAG, *this);
+  case ISD::VAARG:              return LowerVAARG(Op, DAG);
+  case ISD::DYNAMIC_STACKALLOC: return LowerDYNAMIC_STACKALLOC(Op, DAG);
+  }
+}
+
+MachineBasicBlock *
+cbgTargetLowering::EmitInstrWithCustomInserter(MachineInstr *MI,
+                                                 MachineBasicBlock *BB) const {
+  const TargetInstrInfo &TII = *getTargetMachine().getInstrInfo();
+  unsigned BROpcode;
+  unsigned CC;
+  DebugLoc dl = MI->getDebugLoc();
+  // Figure out the conditional branch opcode to use for this select_cc.
+  switch (MI->getOpcode()) {
+  default: llvm_unreachable("Unknown SELECT_CC!");
+  case CBG::SELECT_CC_Int_ICC:
+  case CBG::SELECT_CC_FP_ICC:
+  case CBG::SELECT_CC_DFP_ICC:
+    BROpcode = CBG::BCOND;
+    break;
+  case CBG::SELECT_CC_Int_FCC:
+  case CBG::SELECT_CC_FP_FCC:
+  case CBG::SELECT_CC_DFP_FCC:
+    BROpcode = CBG::FBCOND;
+    break;
+  }
+
+  CC = (CBGCC::CondCodes)MI->getOperand(3).getImm();
+
+  // To "insert" a SELECT_CC instruction, we actually have to insert the diamond
+  // control-flow pattern.  The incoming instruction knows the destination vreg
+  // to set, the condition code register to branch on, the true/false values to
+  // select between, and a branch opcode to use.
+  const BasicBlock *LLVM_BB = BB->getBasicBlock();
+  MachineFunction::iterator It = BB;
+  ++It;
+
+  //  thisMBB:
+  //  ...
+  //   TrueVal = ...
+  //   [f]bCC copy1MBB
+  //   fallthrough --> copy0MBB
+  MachineBasicBlock *thisMBB = BB;
+  MachineFunction *F = BB->getParent();
+  MachineBasicBlock *copy0MBB = F->CreateMachineBasicBlock(LLVM_BB);
+  MachineBasicBlock *sinkMBB = F->CreateMachineBasicBlock(LLVM_BB);
+  F->insert(It, copy0MBB);
+  F->insert(It, sinkMBB);
+
+  // Transfer the remainder of BB and its successor edges to sinkMBB.
+  sinkMBB->splice(sinkMBB->begin(), BB,
+                  llvm::next(MachineBasicBlock::iterator(MI)),
+                  BB->end());
+  sinkMBB->transferSuccessorsAndUpdatePHIs(BB);
+
+  // Add the true and fallthrough blocks as its successors.
+  BB->addSuccessor(copy0MBB);
+  BB->addSuccessor(sinkMBB);
+
+  BuildMI(BB, dl, TII.get(BROpcode)).addMBB(sinkMBB).addImm(CC);
+
+  //  copy0MBB:
+  //   %FalseValue = ...
+  //   # fallthrough to sinkMBB
+  BB = copy0MBB;
+
+  // Update machine-CFG edges
+  BB->addSuccessor(sinkMBB);
+
+  //  sinkMBB:
+  //   %Result = phi [ %FalseValue, copy0MBB ], [ %TrueValue, thisMBB ]
+  //  ...
+  BB = sinkMBB;
+  BuildMI(*BB, BB->begin(), dl, TII.get(CBG::PHI), MI->getOperand(0).getReg())
+    .addReg(MI->getOperand(2).getReg()).addMBB(copy0MBB)
+    .addReg(MI->getOperand(1).getReg()).addMBB(thisMBB);
+
+  MI->eraseFromParent();   // The pseudo instruction is gone now.
+  return BB;
+}
+
+//===----------------------------------------------------------------------===//
+//                         Sparc Inline Assembly Support
+//===----------------------------------------------------------------------===//
+
+/// getConstraintType - Given a constraint letter, return the type of
+/// constraint it is for this target.
+cbgTargetLowering::ConstraintType
+cbgTargetLowering::getConstraintType(const std::string &Constraint) const {
+  if (Constraint.size() == 1) {
+    switch (Constraint[0]) {
+    default:  break;
+    case 'r': return C_RegisterClass;
+    }
+  }
+
+  return TargetLowering::getConstraintType(Constraint);
+}
+
+std::pair<unsigned, const TargetRegisterClass*>
+cbgTargetLowering::getRegForInlineAsmConstraint(const std::string &Constraint,
+                                                  EVT VT) const {
+  if (Constraint.size() == 1) {
+    switch (Constraint[0]) {
+    case 'r':
+      return std::make_pair(0U, CBG::IntRegsRegisterClass);
+    }
+  }
+
+  return TargetLowering::getRegForInlineAsmConstraint(Constraint, VT);
+}
+
+std::vector<unsigned> cbgTargetLowering::
+getRegClassForInlineAsmConstraint(const std::string &Constraint,
+                                  EVT VT) const {
+  if (Constraint.size() != 1)
+    return std::vector<unsigned>();
+
+  switch (Constraint[0]) {
+  default: break;
+  case 'r':
+    return make_vector<unsigned>(CBG::L0, CBG::L1, CBG::L2, CBG::L3,
+                                 CBG::L4, CBG::L5, CBG::L6, CBG::L7,
+                                 CBG::I0, CBG::I1, CBG::I2, CBG::I3,
+                                 CBG::I4, CBG::I5,
+                                 CBG::O0, CBG::O1, CBG::O2, CBG::O3,
+                                 CBG::O4, CBG::O5, CBG::O7, 0);
+  }
+
+  return std::vector<unsigned>();
+}
+
+bool
+cbgTargetLowering::isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const {
+  // The Sparc target isn't yet aware of offsets.
+  return false;
+}
+
+/// getFunctionAlignment - Return the Log2 alignment of this function.
+unsigned cbgTargetLowering::getFunctionAlignment(const Function *) const {
+  return 2;
+}
diff --git a/lib/Target/cbg/cbgISelLowering.h b/lib/Target/cbg/cbgISelLowering.h
new file mode 100644
index 0000000..1044011
--- /dev/null
+++ b/lib/Target/cbg/cbgISelLowering.h
@@ -0,0 +1,111 @@
+//===-- cbgISelLowering.h - CBG DAG Lowering Interface ------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the interfaces that cbg uses to lower LLVM code into a
+// selection DAG.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBG_ISELLOWERING_H
+#define CBG_ISELLOWERING_H
+
+#include "llvm/Target/TargetLowering.h"
+#include "cbgSubtarget.h"
+#include "cbg.h"
+
+namespace llvm {
+  namespace SPISD {
+    enum {
+      FIRST_NUMBER = ISD::BUILTIN_OP_END,
+      CMPICC,      // Compare two GPR operands, set icc.
+      CMPFCC,      // Compare two FP operands, set fcc.
+      BRICC,       // Branch to dest on icc condition
+      BRFCC,       // Branch to dest on fcc condition
+      SELECT_ICC,  // Select between two values using the current ICC flags.
+      SELECT_FCC,  // Select between two values using the current FCC flags.
+
+      Hi, Lo,      // Hi/Lo operations, typically on a global address.
+
+      FTOI,        // FP to Int within a FP register.
+      ITOF,        // Int to FP within a FP register.
+
+      CALL,        // A call instruction.
+      RET_FLAG,    // Return with a flag operand.
+      GLOBAL_BASE_REG, // Global base reg for PIC
+      FLUSHW       // FLUSH register windows to stack
+    };
+  }
+
+  class cbgTargetLowering : public TargetLowering {
+    const cbgSubtarget* ST;
+  public:
+    cbgTargetLowering(TargetMachine &TM);
+    virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;
+
+    /// computeMaskedBitsForTargetNode - Determine which of the bits specified
+    /// in Mask are known to be either zero or one and return them in the
+    /// KnownZero/KnownOne bitsets.
+    virtual void computeMaskedBitsForTargetNode(const SDValue Op,
+                                                const APInt &Mask,
+                                                APInt &KnownZero,
+                                                APInt &KnownOne,
+                                                const SelectionDAG &DAG,
+                                                unsigned Depth = 0) const;
+
+    virtual MachineBasicBlock *
+      EmitInstrWithCustomInserter(MachineInstr *MI,
+                                  MachineBasicBlock *MBB) const;
+
+    virtual const char *getTargetNodeName(unsigned Opcode) const;
+
+    ConstraintType getConstraintType(const std::string &Constraint) const;
+    std::pair<unsigned, const TargetRegisterClass*>
+    getRegForInlineAsmConstraint(const std::string &Constraint, EVT VT) const;
+    std::vector<unsigned>
+    getRegClassForInlineAsmConstraint(const std::string &Constraint,
+                                      EVT VT) const;
+
+    virtual bool isOffsetFoldingLegal(const GlobalAddressSDNode *GA) const;
+
+    /// getFunctionAlignment - Return the Log2 alignment of this function.
+    virtual unsigned getFunctionAlignment(const Function *F) const;
+
+    virtual SDValue
+      LowerFormalArguments(SDValue Chain,
+                           CallingConv::ID CallConv,
+                           bool isVarArg,
+                           const SmallVectorImpl<ISD::InputArg> &Ins,
+                           DebugLoc dl, SelectionDAG &DAG,
+                           SmallVectorImpl<SDValue> &InVals) const;
+
+    virtual SDValue
+      LowerCall(SDValue Chain, SDValue Callee,
+                CallingConv::ID CallConv, bool isVarArg,
+                bool &isTailCall,
+                const SmallVectorImpl<ISD::OutputArg> &Outs,
+                const SmallVectorImpl<SDValue> &OutVals,
+                const SmallVectorImpl<ISD::InputArg> &Ins,
+                DebugLoc dl, SelectionDAG &DAG,
+                SmallVectorImpl<SDValue> &InVals) const;
+
+    virtual SDValue
+      LowerReturn(SDValue Chain,
+                  CallingConv::ID CallConv, bool isVarArg,
+                  const SmallVectorImpl<ISD::OutputArg> &Outs,
+                  const SmallVectorImpl<SDValue> &OutVals,
+                  DebugLoc dl, SelectionDAG &DAG) const;
+
+    SDValue LowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
+    SDValue LowerConstantPool(SDValue Op, SelectionDAG &DAG) const;
+
+    unsigned getSRetArgSize(SelectionDAG &DAG, SDValue Callee) const;
+  };
+} // end namespace llvm
+
+#endif    // CBG_ISELLOWERING_H
diff --git a/lib/Target/cbg/cbgInstrFormats.td b/lib/Target/cbg/cbgInstrFormats.td
new file mode 100644
index 0000000..472cf8f
--- /dev/null
+++ b/lib/Target/cbg/cbgInstrFormats.td
@@ -0,0 +1,114 @@
+//===- cbgInstrFormats.td - cbg Instruction Formats ----*- tablegen -*-===//
+// 
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+// 
+//===----------------------------------------------------------------------===//
+
+class InstSP<dag outs, dag ins, string asmstr, list<dag> pattern> : Instruction {
+  field bits<32> Inst;
+
+  let Namespace = "CBG";
+
+  bits<2> op;
+  let Inst{31-30} = op;               // Top two bits are the 'op' field
+  
+  dag OutOperandList = outs;
+  dag InOperandList = ins;
+  let AsmString   = asmstr;
+  let Pattern = pattern;
+}
+
+//===----------------------------------------------------------------------===//
+// Format #2 instruction classes in the cbg
+//===----------------------------------------------------------------------===//
+
+// Format 2 instructions
+class F2<dag outs, dag ins, string asmstr, list<dag> pattern>
+   : InstSP<outs, ins, asmstr, pattern> {
+  bits<3>  op2;
+  bits<22> imm22;
+  let op          = 0;    // op = 0
+  let Inst{24-22} = op2;
+  let Inst{21-0}  = imm22;
+}
+
+// Specific F2 classes: SparcV8 manual, page 44
+//
+class F2_1<bits<3> op2Val, dag outs, dag ins, string asmstr, list<dag> pattern>
+   : F2<outs, ins, asmstr, pattern> {
+  bits<5>  rd;
+
+  let op2         = op2Val;
+
+  let Inst{29-25} = rd;
+}
+
+class F2_2<bits<4> condVal, bits<3> op2Val, dag outs, dag ins, string asmstr, 
+           list<dag> pattern> : F2<outs, ins, asmstr, pattern> {
+  bits<4>   cond;
+  bit       annul = 0;     // currently unused
+
+  let cond        = condVal;
+  let op2         = op2Val;
+
+  let Inst{29}    = annul;
+  let Inst{28-25} = cond;
+}
+
+//===----------------------------------------------------------------------===//
+// Format #3 instruction classes in the Sparc
+//===----------------------------------------------------------------------===//
+
+class F3<dag outs, dag ins, string asmstr, list<dag> pattern>
+    : InstSP<outs, ins, asmstr, pattern> {
+  bits<5> rd;
+  bits<6> op3;
+  bits<5> rs1;
+  let op{1} = 1;   // Op = 2 or 3
+  let Inst{29-25} = rd;
+  let Inst{24-19} = op3;
+  let Inst{18-14} = rs1;
+}
+
+// Specific F3 classes: SparcV8 manual, page 44
+//
+class F3_1<bits<2> opVal, bits<6> op3val, dag outs, dag ins,
+           string asmstr, list<dag> pattern> : F3<outs, ins, asmstr, pattern> {
+  bits<8> asi = 0; // asi not currently used
+  bits<5> rs2;
+
+  let op         = opVal;
+  let op3        = op3val;
+
+  let Inst{13}   = 0;     // i field = 0
+  let Inst{12-5} = asi;   // address space identifier
+  let Inst{4-0}  = rs2;
+}
+
+class F3_2<bits<2> opVal, bits<6> op3val, dag outs, dag ins, 
+           string asmstr, list<dag> pattern> : F3<outs, ins, asmstr, pattern> {
+  bits<13> simm13;
+
+  let op         = opVal;
+  let op3        = op3val;
+
+  let Inst{13}   = 1;     // i field = 1
+  let Inst{12-0} = simm13;
+}
+
+// floating-point
+class F3_3<bits<2> opVal, bits<6> op3val, bits<9> opfval, dag outs, dag ins,
+           string asmstr, list<dag> pattern> : F3<outs, ins, asmstr, pattern> {
+  bits<5> rs2;
+
+  let op         = opVal;
+  let op3        = op3val;
+
+  let Inst{13-5} = opfval;   // fp opcode
+  let Inst{4-0}  = rs2;
+}
+
+
diff --git a/lib/Target/cbg/cbgInstrInfo.cpp b/lib/Target/cbg/cbgInstrInfo.cpp
new file mode 100644
index 0000000..db68295
--- /dev/null
+++ b/lib/Target/cbg/cbgInstrInfo.cpp
@@ -0,0 +1,346 @@
+//===- cbgInstrInfo.cpp - cbg Instruction Information -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the cbg implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgInstrInfo.h"
+#include "cbgSubtarget.h"
+#include "cbg.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "cbgGenInstrInfo.inc"
+#include "cbgMachineFunctionInfo.h"
+
+#include <iostream>
+
+using namespace llvm;
+
+cbgInstrInfo::cbgInstrInfo(cbgSubtarget &ST)
+  : TargetInstrInfoImpl(cbgInsts, array_lengthof(cbgInsts)),
+    RI(ST, *this), Subtarget(ST) {
+}
+
+/// isLoadFromStackSlot - If the specified machine instruction is a direct
+/// load from a stack slot, return the virtual or physical register number of
+/// the destination along with the FrameIndex of the loaded stack slot.  If
+/// not, return 0.  This predicate must return 0 if the instruction has
+/// any side effects other than loading from the stack slot.
+unsigned cbgInstrInfo::isLoadFromStackSlot(const MachineInstr *MI,
+                                             int &FrameIndex) const {
+  if (MI->getOpcode() == CBG::LDri ||
+      MI->getOpcode() == CBG::LDFri ||
+      MI->getOpcode() == CBG::LDDFri) {
+    if (MI->getOperand(1).isFI() && MI->getOperand(2).isImm() &&
+        MI->getOperand(2).getImm() == 0) {
+      FrameIndex = MI->getOperand(1).getIndex();
+      return MI->getOperand(0).getReg();
+    }
+  }
+  return 0;
+}
+
+/// isStoreToStackSlot - If the specified machine instruction is a direct
+/// store to a stack slot, return the virtual or physical register number of
+/// the source reg along with the FrameIndex of the loaded stack slot.  If
+/// not, return 0.  This predicate must return 0 if the instruction has
+/// any side effects other than storing to the stack slot.
+unsigned cbgInstrInfo::isStoreToStackSlot(const MachineInstr *MI,
+                                            int &FrameIndex) const {
+  if (MI->getOpcode() == CBG::STri ||
+      MI->getOpcode() == CBG::STFri ||
+      MI->getOpcode() == CBG::STDFri) {
+    if (MI->getOperand(0).isFI() && MI->getOperand(1).isImm() &&
+        MI->getOperand(1).getImm() == 0) {
+      FrameIndex = MI->getOperand(0).getIndex();
+      return MI->getOperand(2).getReg();
+    }
+  }
+  return 0;
+}
+
+static bool IsIntegerCC(unsigned CC)
+{
+  return  (CC <= CBGCC::ICC_VC);
+}
+
+
+
+CBGCC::CondCodes CBG::getOppositeBranchCondition(CBGCC::CondCodes CC)
+{
+  switch(CC) {
+  default: llvm_unreachable("Unknown condition code");
+  case CBGCC::ICC_NE:   return CBGCC::ICC_E;
+  case CBGCC::ICC_E:    return CBGCC::ICC_NE;
+  case CBGCC::ICC_G:    return CBGCC::ICC_LE;
+  case CBGCC::ICC_LE:   return CBGCC::ICC_G;
+  case CBGCC::ICC_GE:   return CBGCC::ICC_L;
+  case CBGCC::ICC_L:    return CBGCC::ICC_GE;
+  case CBGCC::ICC_GU:   return CBGCC::ICC_LEU;
+  case CBGCC::ICC_LEU:  return CBGCC::ICC_GU;
+  case CBGCC::ICC_CC:   return CBGCC::ICC_CS;
+  case CBGCC::ICC_CS:   return CBGCC::ICC_CC;
+  case CBGCC::ICC_POS:  return CBGCC::ICC_NEG;
+  case CBGCC::ICC_NEG:  return CBGCC::ICC_POS;
+  case CBGCC::ICC_VC:   return CBGCC::ICC_VS;
+  case CBGCC::ICC_VS:   return CBGCC::ICC_VC;
+
+  case CBGCC::FCC_U:    return CBGCC::FCC_O;
+  case CBGCC::FCC_O:    return CBGCC::FCC_U;
+  case CBGCC::FCC_G:    return CBGCC::FCC_LE;
+  case CBGCC::FCC_LE:   return CBGCC::FCC_G;
+  case CBGCC::FCC_UG:   return CBGCC::FCC_ULE;
+  case CBGCC::FCC_ULE:  return CBGCC::FCC_UG;
+  case CBGCC::FCC_L:    return CBGCC::FCC_GE;
+  case CBGCC::FCC_GE:   return CBGCC::FCC_L;
+  case CBGCC::FCC_UL:   return CBGCC::FCC_UGE;
+  case CBGCC::FCC_UGE:  return CBGCC::FCC_UL;
+  case CBGCC::FCC_LG:   return CBGCC::FCC_UE;
+  case CBGCC::FCC_UE:   return CBGCC::FCC_LG;
+  case CBGCC::FCC_NE:   return CBGCC::FCC_E;
+  case CBGCC::FCC_E:    return CBGCC::FCC_NE;
+  }
+}
+
+bool cbgInstrInfo::AnalyzeBranch(MachineBasicBlock &MBB,
+                                   MachineBasicBlock *&TBB,
+                                   MachineBasicBlock *&FBB,
+                                   SmallVectorImpl<MachineOperand> &Cond,
+                                   bool AllowModify) const
+{
+
+  MachineBasicBlock::iterator I = MBB.end();
+  MachineBasicBlock::iterator UnCondBrIter = MBB.end();
+
+  while (I != MBB.begin()) {
+    --I;
+
+    if (I->isDebugValue())
+      continue;
+
+    //When we see a non-terminator, we are done
+    if (!isUnpredicatedTerminator(I))
+      break;
+
+    //Terminator is not a branch
+    if (!I->getDesc().isBranch())
+      return true;
+
+    //Handle Unconditional branches
+    if (I->getOpcode() == CBG::BA) {
+      UnCondBrIter = I;
+
+      if (!AllowModify) {
+        TBB = I->getOperand(0).getMBB();
+        continue;
+      }
+
+      while (llvm::next(I) != MBB.end())
+        llvm::next(I)->eraseFromParent();
+
+      Cond.clear();
+      FBB = 0;
+
+      if (MBB.isLayoutSuccessor(I->getOperand(0).getMBB())) {
+        TBB = 0;
+        I->eraseFromParent();
+        I = MBB.end();
+        UnCondBrIter = MBB.end();
+        continue;
+      }
+
+      TBB = I->getOperand(0).getMBB();
+      continue;
+    }
+
+    unsigned Opcode = I->getOpcode();
+    if (Opcode != CBG::BCOND && Opcode != CBG::FBCOND)
+      return true; //Unknown Opcode
+
+    CBGCC::CondCodes BranchCode = (CBGCC::CondCodes)I->getOperand(1).getImm();
+
+    if (Cond.empty()) {
+      MachineBasicBlock *TargetBB = I->getOperand(0).getMBB();
+      if (AllowModify && UnCondBrIter != MBB.end() &&
+          MBB.isLayoutSuccessor(TargetBB)) {
+
+        //Transform the code
+        //
+        //    brCC L1
+        //    ba L2
+        // L1:
+        //    ..
+        // L2:
+        //
+        // into
+        //
+        //   brnCC L2
+        // L1:
+        //   ...
+        // L2:
+        //
+        BranchCode = CBG::getOppositeBranchCondition(BranchCode);
+        MachineBasicBlock::iterator OldInst = I;
+        BuildMI(MBB, UnCondBrIter, MBB.findDebugLoc(I), get(Opcode))
+          .addMBB(UnCondBrIter->getOperand(0).getMBB()).addImm(BranchCode);
+        BuildMI(MBB, UnCondBrIter, MBB.findDebugLoc(I), get(CBG::BA))
+          .addMBB(TargetBB);
+        MBB.addSuccessor(TargetBB);
+        OldInst->eraseFromParent();
+        UnCondBrIter->eraseFromParent();
+
+        UnCondBrIter = MBB.end();
+        I = MBB.end();
+        continue;
+      }
+      FBB = TBB;
+      TBB = I->getOperand(0).getMBB();
+      Cond.push_back(MachineOperand::CreateImm(BranchCode));
+      continue;
+    }
+    //FIXME: Handle subsequent conditional branches
+    //For now, we can't handle multiple conditional branches
+    return true;
+  }
+  return false;
+}
+
+unsigned
+cbgInstrInfo::InsertBranch(MachineBasicBlock &MBB,MachineBasicBlock *TBB,
+                             MachineBasicBlock *FBB,
+                             const SmallVectorImpl<MachineOperand> &Cond,
+                             DebugLoc DL) const {
+  assert(TBB && "InsertBranch must not be told to insert a fallthrough");
+  assert((Cond.size() == 1 || Cond.size() == 0) &&
+         "cbg branch conditions should have one component!");
+
+  if (Cond.empty()) {
+    assert(!FBB && "Unconditional branch with multiple successors!");
+    BuildMI(&MBB, DL, get(CBG::BA)).addMBB(TBB);
+    return 1;
+  }
+
+  //Conditional branch
+  unsigned CC = Cond[0].getImm();
+
+  if (IsIntegerCC(CC))
+    BuildMI(&MBB, DL, get(CBG::BCOND)).addMBB(TBB).addImm(CC);
+  else
+    BuildMI(&MBB, DL, get(CBG::FBCOND)).addMBB(TBB).addImm(CC);
+  if (!FBB)
+    return 1;
+
+  BuildMI(&MBB, DL, get(CBG::BA)).addMBB(FBB);
+  return 2;
+}
+
+unsigned cbgInstrInfo::RemoveBranch(MachineBasicBlock &MBB) const
+{
+  MachineBasicBlock::iterator I = MBB.end();
+  unsigned Count = 0;
+  while (I != MBB.begin()) {
+    --I;
+
+    if (I->isDebugValue())
+      continue;
+
+    if (I->getOpcode() != CBG::BA
+        && I->getOpcode() != CBG::BCOND
+        && I->getOpcode() != CBG::FBCOND)
+      break; // Not a branch
+
+    I->eraseFromParent();
+    I = MBB.end();
+    ++Count;
+  }
+  return Count;
+}
+
+void cbgInstrInfo::copyPhysReg(MachineBasicBlock &MBB,
+                                 MachineBasicBlock::iterator I, DebugLoc DL,
+                                 unsigned DestReg, unsigned SrcReg,
+                                 bool KillSrc) const {
+  if (CBG::IntRegsRegClass.contains(DestReg, SrcReg))
+    BuildMI(MBB, I, DL, get(CBG::ORrr), DestReg).addReg(CBG::G0)
+      .addReg(SrcReg, getKillRegState(KillSrc));
+  else if (CBG::FPRegsRegClass.contains(DestReg, SrcReg))
+    BuildMI(MBB, I, DL, get(CBG::FMOVS), DestReg)
+      .addReg(SrcReg, getKillRegState(KillSrc));
+  /*else if (CBG::DFPRegsRegClass.contains(DestReg, SrcReg))
+    BuildMI(MBB, I, DL, get(Subtarget.isV9() ? CBG::FMOVD : CBG::FpMOVD), DestReg)
+      .addReg(SrcReg, getKillRegState(KillSrc));*/
+  else
+    llvm_unreachable("Impossible reg-to-reg copy");
+}
+
+void cbgInstrInfo::
+storeRegToStackSlot(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,
+                    unsigned SrcReg, bool isKill, int FI,
+                    const TargetRegisterClass *RC,
+                    const TargetRegisterInfo *TRI) const {
+  DebugLoc DL;
+  if (I != MBB.end()) DL = I->getDebugLoc();
+
+  // On the order of operands here: think "[FrameIdx + 0] = SrcReg".
+  if (RC == CBG::IntRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::STri)).addFrameIndex(FI).addImm(0)
+      .addReg(SrcReg, getKillRegState(isKill));
+  else if (RC == CBG::FPRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::STFri)).addFrameIndex(FI).addImm(0)
+      .addReg(SrcReg,  getKillRegState(isKill));
+  else if (RC == CBG::DFPRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::STDFri)).addFrameIndex(FI).addImm(0)
+      .addReg(SrcReg,  getKillRegState(isKill));
+  else
+    llvm_unreachable("Can't store this register to stack slot");
+}
+
+void cbgInstrInfo::
+loadRegFromStackSlot(MachineBasicBlock &MBB, MachineBasicBlock::iterator I,
+                     unsigned DestReg, int FI,
+                     const TargetRegisterClass *RC,
+                     const TargetRegisterInfo *TRI) const {
+  DebugLoc DL;
+  if (I != MBB.end()) DL = I->getDebugLoc();
+
+  if (RC == CBG::IntRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::LDri), DestReg).addFrameIndex(FI).addImm(0);
+  else if (RC == CBG::FPRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::LDFri), DestReg).addFrameIndex(FI).addImm(0);
+  else if (RC == CBG::DFPRegsRegisterClass)
+    BuildMI(MBB, I, DL, get(CBG::LDDFri), DestReg).addFrameIndex(FI).addImm(0);
+  else
+    llvm_unreachable("Can't load this register from stack slot");
+}
+
+unsigned cbgInstrInfo::getGlobalBaseReg(MachineFunction *MF) const
+{
+  cbgMachineFunctionInfo *cbgFI = MF->getInfo<cbgMachineFunctionInfo>();
+  unsigned GlobalBaseReg = cbgFI->getGlobalBaseReg();
+  if (GlobalBaseReg != 0)
+    return GlobalBaseReg;
+
+  // Insert the set of GlobalBaseReg into the first MBB of the function
+  MachineBasicBlock &FirstMBB = MF->front();
+  MachineBasicBlock::iterator MBBI = FirstMBB.begin();
+  MachineRegisterInfo &RegInfo = MF->getRegInfo();
+
+  GlobalBaseReg = RegInfo.createVirtualRegister(&CBG::IntRegsRegClass);
+
+
+  DebugLoc dl;
+
+  BuildMI(FirstMBB, MBBI, dl, get(CBG::GETPCX), GlobalBaseReg);
+  cbgFI->setGlobalBaseReg(GlobalBaseReg);
+  return GlobalBaseReg;
+}
diff --git a/lib/Target/cbg/cbgInstrInfo.h b/lib/Target/cbg/cbgInstrInfo.h
new file mode 100644
index 0000000..5f35f69
--- /dev/null
+++ b/lib/Target/cbg/cbgInstrInfo.h
@@ -0,0 +1,126 @@
+//===- cbgInstrInfo.h - cbg Instruction Information ---------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the cbg implementation of the TargetInstrInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBGINSTRUCTIONINFO_H
+#define CBGINSTRUCTIONINFO_H
+
+#include "cbg.h"
+#include "llvm/Target/TargetInstrInfo.h"
+#include "cbgRegisterInfo.h"
+
+namespace llvm {
+
+/// SPII - This namespace holds all of the target specific flags that
+/// instruction info tracks.
+///
+namespace SPII {
+  enum {
+    Pseudo = (1<<0),
+    Load = (1<<1),
+    Store = (1<<2),
+    DelaySlot = (1<<3)
+  };
+}
+
+namespace CBG {
+  CBGCC::CondCodes getOppositeBranchCondition(CBGCC::CondCodes CC);
+}
+
+class cbgInstrInfo : public TargetInstrInfoImpl {
+  const cbgRegisterInfo RI;
+  const cbgSubtarget& Subtarget;
+
+public:
+  explicit cbgInstrInfo(cbgSubtarget &ST);
+
+  /// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As
+  /// such, whenever a client has an instance of instruction info, it should
+  /// always be able to get register info as well (through this method).
+  ///
+  virtual const cbgRegisterInfo &getRegisterInfo() const { return RI; }
+
+  /// isLoadFromStackSlot - If the specified machine instruction is a direct
+  /// load from a stack slot, return the virtual or physical register number of
+  /// the destination along with the FrameIndex of the loaded stack slot.  If
+  /// not, return 0.  This predicate must return 0 if the instruction has
+  /// any side effects other than loading from the stack slot.
+  virtual unsigned isLoadFromStackSlot(const MachineInstr *MI,
+                                       int &FrameIndex) const;
+  
+  /// isStoreToStackSlot - If the specified machine instruction is a direct
+  /// store to a stack slot, return the virtual or physical register number of
+  /// the source reg along with the FrameIndex of the loaded stack slot.  If
+  /// not, return 0.  This predicate must return 0 if the instruction has
+  /// any side effects other than storing to the stack slot.
+  virtual unsigned isStoreToStackSlot(const MachineInstr *MI,
+                                      int &FrameIndex) const;
+
+
+  virtual bool AnalyzeBranch(MachineBasicBlock &MBB, MachineBasicBlock *&TBB,
+                             MachineBasicBlock *&FBB,
+                             SmallVectorImpl<MachineOperand> &Cond,
+                             bool AllowModify = false) const ;
+
+  virtual unsigned RemoveBranch(MachineBasicBlock &MBB) const;
+
+  virtual unsigned InsertBranch(MachineBasicBlock &MBB, MachineBasicBlock *TBB,
+                                MachineBasicBlock *FBB,
+                                const SmallVectorImpl<MachineOperand> &Cond,
+                                DebugLoc DL) const;
+
+  virtual void copyPhysReg(MachineBasicBlock &MBB,
+                           MachineBasicBlock::iterator I, DebugLoc DL,
+                           unsigned DestReg, unsigned SrcReg,
+                           bool KillSrc) const;
+  
+  virtual void storeRegToStackSlot(MachineBasicBlock &MBB,
+                                   MachineBasicBlock::iterator MBBI,
+                                   unsigned SrcReg, bool isKill, int FrameIndex,
+                                   const TargetRegisterClass *RC,
+                                   const TargetRegisterInfo *TRI) const;
+
+  virtual void loadRegFromStackSlot(MachineBasicBlock &MBB,
+                                    MachineBasicBlock::iterator MBBI,
+                                    unsigned DestReg, int FrameIndex,
+                                    const TargetRegisterClass *RC,
+                                    const TargetRegisterInfo *TRI) const;
+  
+  unsigned getGlobalBaseReg(MachineFunction *MF) const;
+
+//  /// isPredicated - Returns true if the instruction is already predicated.
+//  ///
+//  virtual bool isPredicated(const MachineInstr *MI);
+//
+//  /// PredicateInstruction - Convert the instruction into a predicated
+//  /// instruction. It returns true if the operation was successful.
+//  virtual
+//  bool PredicateInstruction(MachineInstr *MI,
+//                        const SmallVectorImpl<MachineOperand> &Pred) const;
+//
+//  /// SubsumesPredicate - Returns true if the first specified predicate
+//  /// subsumes the second, e.g. GE subsumes GT.
+//  virtual
+//  bool SubsumesPredicate(const SmallVectorImpl<MachineOperand> &Pred1,
+//                         const SmallVectorImpl<MachineOperand> &Pred2) const;
+//
+//  /// DefinesPredicate - If the specified instruction defines any predicate
+//  /// or condition code register(s) used for predication, returns true as well
+//  /// as the definition predicate(s) by reference.
+//  virtual bool DefinesPredicate(MachineInstr *MI,
+//                                std::vector<MachineOperand> &Pred) const;
+
+};
+
+}
+
+#endif
diff --git a/lib/Target/cbg/cbgInstrInfo.td b/lib/Target/cbg/cbgInstrInfo.td
new file mode 100644
index 0000000..10e4762
--- /dev/null
+++ b/lib/Target/cbg/cbgInstrInfo.td
@@ -0,0 +1,1328 @@
+//===- cbgInstrInfo.td - Target Description for cbg Target ------------===//
+// 
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+// 
+//===----------------------------------------------------------------------===//
+//
+// This file describes the cbg instructions in TableGen format.
+//
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+// Instruction format superclass
+//===----------------------------------------------------------------------===//
+
+include "cbgInstrFormats.td"
+
+//===----------------------------------------------------------------------===//
+// Feature predicates.
+//===----------------------------------------------------------------------===//
+
+// HasV9 - This predicate is true when the target processor supports V9
+// instructions.  Note that the machine may be running in 32-bit mode.
+//def HasV9   : Predicate<"Subtarget.isV9()">;
+
+// HasNoV9 - This predicate is true when the target doesn't have V9
+// instructions.  Use of this is just a hack for the isel not having proper
+// costs for V8 instructions that are more expensive than their V9 ones.
+//def HasNoV9 : Predicate<"!Subtarget.isV9()">;
+
+// HasVIS - This is true when the target processor has VIS extensions.
+//def HasVIS : Predicate<"Subtarget.isVIS()">;
+
+// UseDeprecatedInsts - This predicate is true when the target processor is a
+// V8, or when it is V9 but the V8 deprecated instructions are efficient enough
+// to use when appropriate.  In either of these cases, the instruction selector
+// will pick deprecated instructions.
+//def UseDeprecatedInsts : Predicate<"Subtarget.useDeprecatedV8Instructions()">;
+
+def HasSelCC : Predicate<"Subtarget.hasSelCC()">;
+def HasMovCC : Predicate<"Subtarget.hasMovCC()">;
+def HasPredBlocksCC : Predicate<"Subtarget.hasPredBlocksCC()">;
+def HasPredBlocksReg : Predicate<"Subtarget.hasPredBlocksReg()">;
+def HasPredInstrCC : Predicate<"Subtarget.hasPredInstrCC() && !Subtarget.hasPredInstrReg()">;
+def HasPredInstrReg : Predicate<"Subtarget.hasPredInstrReg() && !Subtarget.hasPredInstrCC()">;
+//def HasNoPredInstr : Predicate<"!Subtarget.hasPredInstrCC() && !Subtarget.hasPredInstrReg()">;
+//def HasNoPredInstr : Predicate<"!Subtarget.hasPredInstrCC()">;
+def HasHWLoop : Predicate<"Subtarget.hasHWLoop()">;
+def HasHWLoops : Predicate<"Subtarget.hasHWLoops()">;
+def HasVLIWIfElse : Predicate<"Subtarget.hasVLIWIfElse()">;
+
+//===----------------------------------------------------------------------===//
+// Instruction Pattern Stuff
+//===----------------------------------------------------------------------===//
+
+def simm8  : PatLeaf<(imm), [{ return isInt<8>(N->getSExtValue()); }]>;
+
+def simm11  : PatLeaf<(imm), [{ return isInt<11>(N->getSExtValue()); }]>;
+
+def simm13  : PatLeaf<(imm), [{ return isInt<13>(N->getSExtValue()); }]>;
+
+def LO10 : SDNodeXForm<imm, [{
+  return CurDAG->getTargetConstant((unsigned)N->getZExtValue() & 1023,
+                                   MVT::i32);
+}]>;
+
+def HI22 : SDNodeXForm<imm, [{
+  // Transformation function: shift the immediate value down into the low bits.
+  return CurDAG->getTargetConstant((unsigned)N->getZExtValue() >> 10, MVT::i32);
+}]>;
+
+def SETHIimm : PatLeaf<(imm), [{
+  return (((unsigned)N->getZExtValue() >> 10) << 10) ==
+         (unsigned)N->getZExtValue();
+}], HI22>;
+
+// Addressing modes.
+def ADDRrr : ComplexPattern<i32, 2, "SelectADDRrr", [], []>;
+def ADDRri : ComplexPattern<i32, 2, "SelectADDRri", [frameindex], []>;
+
+// Address operands
+def MEMrr : Operand<i32> {
+  let PrintMethod = "printMemOperand";
+  let MIOperandInfo = (ops IntRegs, IntRegs);
+}
+def MEMri : Operand<i32> {
+  let PrintMethod = "printMemOperand";
+  let MIOperandInfo = (ops IntRegs, i32imm);
+}
+
+// Branch targets have OtherVT type.
+def brtarget : Operand<OtherVT>;
+def calltarget : Operand<i32>;
+
+// Operand for printing out a condition code.
+let PrintMethod = "printCCOperand" in
+  def CCOp : Operand<i32>;
+
+let PrintMethod = "printPRegTFOperand" in
+  def TFOp : Operand<i32>;
+
+def SDTSPcmpfcc : 
+SDTypeProfile<0, 2, [SDTCisFP<0>, SDTCisSameAs<0, 1>]>;
+def SDTSPbrcc : 
+SDTypeProfile<0, 2, [SDTCisVT<0, OtherVT>, SDTCisVT<1, i32>]>;
+def SDTSPselectcc :
+SDTypeProfile<1, 3, [SDTCisSameAs<0, 1>, SDTCisSameAs<1, 2>, SDTCisVT<3, i32>]>;
+def SDTSPFTOI :
+SDTypeProfile<1, 1, [SDTCisVT<0, f32>, SDTCisFP<1>]>;
+def SDTSPITOF :
+SDTypeProfile<1, 1, [SDTCisFP<0>, SDTCisVT<1, f32>]>;
+
+def SPcmpicc : SDNode<"SPISD::CMPICC", SDTIntBinOp, [SDNPOutGlue]>;
+def SPcmpfcc : SDNode<"SPISD::CMPFCC", SDTSPcmpfcc, [SDNPOutGlue]>;
+def SPbricc : SDNode<"SPISD::BRICC", SDTSPbrcc, [SDNPHasChain, SDNPInGlue]>;
+def SPbrfcc : SDNode<"SPISD::BRFCC", SDTSPbrcc, [SDNPHasChain, SDNPInGlue]>;
+
+def SPhi    : SDNode<"SPISD::Hi", SDTIntUnaryOp>;
+def SPlo    : SDNode<"SPISD::Lo", SDTIntUnaryOp>;
+
+def SPftoi  : SDNode<"SPISD::FTOI", SDTSPFTOI>;
+def SPitof  : SDNode<"SPISD::ITOF", SDTSPITOF>;
+
+def SPselecticc : SDNode<"SPISD::SELECT_ICC", SDTSPselectcc, [SDNPInGlue]>;
+def SPselectfcc : SDNode<"SPISD::SELECT_FCC", SDTSPselectcc, [SDNPInGlue]>;
+
+//  These are target-independent nodes, but have target-specific formats.
+def SDT_SPCallSeqStart : SDCallSeqStart<[ SDTCisVT<0, i32> ]>;
+def SDT_SPCallSeqEnd   : SDCallSeqEnd<[ SDTCisVT<0, i32>,
+                                        SDTCisVT<1, i32> ]>;
+
+def callseq_start : SDNode<"ISD::CALLSEQ_START", SDT_SPCallSeqStart,
+                           [SDNPHasChain, SDNPOutGlue]>;
+def callseq_end   : SDNode<"ISD::CALLSEQ_END",   SDT_SPCallSeqEnd,
+                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]>;
+
+def SDT_SPCall    : SDTypeProfile<0, -1, [SDTCisVT<0, i32>]>;
+def call          : SDNode<"SPISD::CALL", SDT_SPCall,
+                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue,
+                            SDNPVariadic]>;
+
+def SDT_SPRet     : SDTypeProfile<0, 1, [SDTCisVT<0, i32>]>;
+def retflag       : SDNode<"SPISD::RET_FLAG", SDT_SPRet,
+                           [SDNPHasChain, SDNPOptInGlue]>;
+
+def flushw        : SDNode<"SPISD::FLUSHW", SDTNone,
+                           [SDNPHasChain]>;
+
+def getPCX        : Operand<i32> {
+  let PrintMethod = "printGetPCX";
+}
+
+
+// Lemberg predicate operand. Default to -1 = always. Second part is
+// condition register.
+def pred_cc : PredicateOperand<i32, (ops i32imm, PPRED),
+              (ops (i32 -1), (i32 zero_reg))> {
+  let PrintMethod = "printPredCCOperand";
+}
+
+
+//===----------------------------------------------------------------------===//
+// CBG Flag Conditions
+//===----------------------------------------------------------------------===//
+
+// Note that these values must be kept in sync with the CCOp::CondCode enum
+// values.
+class ICC_VAL<int N> : PatLeaf<(i32 N)>;
+def ICC_NE  : ICC_VAL< 9>;  // Not Equal
+def ICC_E   : ICC_VAL< 1>;  // Equal
+def ICC_G   : ICC_VAL<10>;  // Greater
+def ICC_LE  : ICC_VAL< 2>;  // Less or Equal
+def ICC_GE  : ICC_VAL<11>;  // Greater or Equal
+def ICC_L   : ICC_VAL< 3>;  // Less
+def ICC_GU  : ICC_VAL<12>;  // Greater Unsigned
+def ICC_LEU : ICC_VAL< 4>;  // Less or Equal Unsigned
+def ICC_CC  : ICC_VAL<13>;  // Carry Clear/Great or Equal Unsigned
+def ICC_CS  : ICC_VAL< 5>;  // Carry Set/Less Unsigned
+def ICC_POS : ICC_VAL<14>;  // Positive
+def ICC_NEG : ICC_VAL< 6>;  // Negative
+def ICC_VC  : ICC_VAL<15>;  // Overflow Clear
+def ICC_VS  : ICC_VAL< 7>;  // Overflow Set
+
+class FCC_VAL<int N> : PatLeaf<(i32 N)>;
+def FCC_U   : FCC_VAL<23>;  // Unordered
+def FCC_G   : FCC_VAL<22>;  // Greater
+def FCC_UG  : FCC_VAL<21>;  // Unordered or Greater
+def FCC_L   : FCC_VAL<20>;  // Less
+def FCC_UL  : FCC_VAL<19>;  // Unordered or Less
+def FCC_LG  : FCC_VAL<18>;  // Less or Greater
+def FCC_NE  : FCC_VAL<17>;  // Not Equal
+def FCC_E   : FCC_VAL<25>;  // Equal
+def FCC_UE  : FCC_VAL<24>;  // Unordered or Equal
+def FCC_GE  : FCC_VAL<25>;  // Greater or Equal
+def FCC_UGE : FCC_VAL<26>;  // Unordered or Greater or Equal
+def FCC_LE  : FCC_VAL<27>;  // Less or Equal
+def FCC_ULE : FCC_VAL<28>;  // Unordered or Less or Equal
+def FCC_O   : FCC_VAL<29>;  // Ordered
+
+//===----------------------------------------------------------------------===//
+// Instruction Class Templates
+//===----------------------------------------------------------------------===//
+
+/// F3_12 multiclass - Define a normal F3_1/F3_2 pattern in one shot.
+multiclass F3_12<string OpcStr, bits<6> Op3Val, SDNode OpNode> {
+  def rr  : F3_1<2, Op3Val, 
+                 (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                 !strconcat(OpcStr, " $b, $c, $dst"),
+                 [(set IntRegs:$dst, (OpNode IntRegs:$b, IntRegs:$c))]>;
+  def ri  : F3_2<2, Op3Val,
+                 (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
+                 !strconcat(OpcStr, " $b, $c, $dst"),
+                 [(set IntRegs:$dst, (OpNode IntRegs:$b, simm13:$c))]>;
+}
+
+/// F3_12np multiclass - Define a normal F3_1/F3_2 pattern in one shot, with no
+/// pattern.
+multiclass F3_12np<string OpcStr, bits<6> Op3Val> {
+  def rr  : F3_1<2, Op3Val, 
+                 (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                 !strconcat(OpcStr, " $b, $c, $dst"), []>;
+  def ri  : F3_2<2, Op3Val,
+                 (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
+                 !strconcat(OpcStr, " $b, $c, $dst"), []>;
+}
+
+//===----------------------------------------------------------------------===//
+// Instructions
+//===----------------------------------------------------------------------===//
+
+// Pseudo instructions.
+class Pseudo<dag outs, dag ins, string asmstr, list<dag> pattern>
+   : InstSP<outs, ins, asmstr, pattern>;
+
+// GETPCX for PIC
+let Defs = [O7] in {
+  def GETPCX : Pseudo<(outs getPCX:$getpcseq), (ins), "$getpcseq", [] >;
+}
+
+let Defs = [O6], Uses = [O6] in {
+def ADJCALLSTACKDOWN : Pseudo<(outs), (ins i32imm:$amt),
+                               ";ADJCALLSTACKDOWN $amt",
+                               [(callseq_start timm:$amt)]>;
+def ADJCALLSTACKUP : Pseudo<(outs), (ins i32imm:$amt1, i32imm:$amt2),
+                            ";ADJCALLSTACKUP $amt1",
+                            [(callseq_end timm:$amt1, timm:$amt2)]>;
+}
+
+let hasSideEffects = 1, mayStore = 1 in {
+//  let rd = 0, rs1 = 0, rs2 = 0 in
+//    def FLUSHW : F3_1<0b10, 0b101011, (outs), (ins),
+//                      "flushw",
+//                      [(flushw)]>, Requires<[HasV9]>;
+  let rd = 0, rs1 = 1, simm13 = 3 in
+    def TA3 : F3_2<0b10, 0b111010, (outs), (ins),
+                   "ta 3",
+                   [(flushw)]>;
+}
+
+def UNIMP : F2_1<0b000, (outs), (ins i32imm:$val),
+                "unimp $val", []>;
+
+// FpMOVD/FpNEGD/FpABSD - These are lowered to single-precision ops by the 
+// fpmover pass.
+//let Predicates = [HasNoV9] in {  // Only emit these in V8 mode.
+  def FpMOVD : Pseudo<(outs DFPRegs:$dst), (ins DFPRegs:$src),
+                      ";FpMOVD $src, $dst", []>;
+  def FpNEGD : Pseudo<(outs DFPRegs:$dst), (ins DFPRegs:$src),
+                      ";FpNEGD $src, $dst",
+                      [(set DFPRegs:$dst, (fneg DFPRegs:$src))]>;
+  def FpABSD : Pseudo<(outs DFPRegs:$dst), (ins DFPRegs:$src),
+                      ";FpABSD $src, $dst",
+                      [(set DFPRegs:$dst, (fabs DFPRegs:$src))]>;
+//}
+
+// SELECT_CC_* - Used to implement the SELECT_CC DAG operation.  Expanded after
+// instruction selection into a branch sequence.  This has to handle all
+// permutations of selection between i32/f32/f64 on ICC and FCC.
+  // Expanded after instruction selection.
+let Uses = [ICC], usesCustomInserter = 1 in { 
+  def SELECT_CC_Int_ICC
+   : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$T, IntRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_Int_ICC PSEUDO!",
+            [(set IntRegs:$dst, (SPselecticc IntRegs:$T, IntRegs:$F,
+                                             imm:$Cond))]>;
+  def SELECT_CC_FP_ICC
+   : Pseudo<(outs FPRegs:$dst), (ins FPRegs:$T, FPRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_FP_ICC PSEUDO!",
+            [(set FPRegs:$dst, (SPselecticc FPRegs:$T, FPRegs:$F,
+                                            imm:$Cond))]>;
+
+  def SELECT_CC_DFP_ICC
+   : Pseudo<(outs DFPRegs:$dst), (ins DFPRegs:$T, DFPRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_DFP_ICC PSEUDO!",
+            [(set DFPRegs:$dst, (SPselecticc DFPRegs:$T, DFPRegs:$F,
+                                             imm:$Cond))]>;
+}
+
+let usesCustomInserter = 1, Uses = [FCC] in {
+
+  def SELECT_CC_Int_FCC
+   : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$T, IntRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_Int_FCC PSEUDO!",
+            [(set IntRegs:$dst, (SPselectfcc IntRegs:$T, IntRegs:$F,
+                                             imm:$Cond))]>;
+
+  def SELECT_CC_FP_FCC
+   : Pseudo<(outs FPRegs:$dst), (ins FPRegs:$T, FPRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_FP_FCC PSEUDO!",
+            [(set FPRegs:$dst, (SPselectfcc FPRegs:$T, FPRegs:$F,
+                                            imm:$Cond))]>;
+  def SELECT_CC_DFP_FCC
+   : Pseudo<(outs DFPRegs:$dst), (ins DFPRegs:$T, DFPRegs:$F, i32imm:$Cond),
+            "; SELECT_CC_DFP_FCC PSEUDO!",
+            [(set DFPRegs:$dst, (SPselectfcc DFPRegs:$T, DFPRegs:$F,
+                                             imm:$Cond))]>;
+}
+
+
+// Section A.3 - Synthetic Instructions, p. 85
+// special cases of JMPL:
+let isReturn = 1, isTerminator = 1, hasDelaySlot = 1, isBarrier = 1 in {
+  let rd = O7.Num, rs1 = G0.Num in
+    def RETL: F3_2<2, 0b111000, (outs), (ins i32imm:$val),
+                   "jmp %o7+$val", [(retflag simm13:$val)]>;
+
+  let rd = I7.Num, rs1 = G0.Num in
+    def RET: F3_2<2, 0b111000, (outs), (ins i32imm:$val),
+                  "jmp %i7+$val", []>;
+}
+
+// Section B.1 - Load Integer Instructions, p. 90
+def LDSBrr : F3_1<3, 0b001001,
+                  (outs IntRegs:$dst), (ins MEMrr:$addr),
+                  "ldsb [$addr], $dst",
+                  [(set IntRegs:$dst, (sextloadi8 ADDRrr:$addr))]>;
+def LDSBri : F3_2<3, 0b001001,
+                  (outs IntRegs:$dst), (ins MEMri:$addr),
+                  "ldsb [$addr], $dst",
+                  [(set IntRegs:$dst, (sextloadi8 ADDRri:$addr))]>;
+def LDSHrr : F3_1<3, 0b001010,
+                  (outs IntRegs:$dst), (ins MEMrr:$addr),
+                  "ldsh [$addr], $dst",
+                  [(set IntRegs:$dst, (sextloadi16 ADDRrr:$addr))]>;
+def LDSHri : F3_2<3, 0b001010,
+                  (outs IntRegs:$dst), (ins MEMri:$addr),
+                  "ldsh [$addr], $dst",
+                  [(set IntRegs:$dst, (sextloadi16 ADDRri:$addr))]>;
+def LDUBrr : F3_1<3, 0b000001,
+                  (outs IntRegs:$dst), (ins MEMrr:$addr),
+                  "ldub [$addr], $dst",
+                  [(set IntRegs:$dst, (zextloadi8 ADDRrr:$addr))]>;
+def LDUBri : F3_2<3, 0b000001,
+                  (outs IntRegs:$dst), (ins MEMri:$addr),
+                  "ldub [$addr], $dst",
+                  [(set IntRegs:$dst, (zextloadi8 ADDRri:$addr))]>;
+def LDUHrr : F3_1<3, 0b000010,
+                  (outs IntRegs:$dst), (ins MEMrr:$addr),
+                  "lduh [$addr], $dst",
+                  [(set IntRegs:$dst, (zextloadi16 ADDRrr:$addr))]>;
+def LDUHri : F3_2<3, 0b000010,
+                  (outs IntRegs:$dst), (ins MEMri:$addr),
+                  "lduh [$addr], $dst",
+                  [(set IntRegs:$dst, (zextloadi16 ADDRri:$addr))]>;
+def LDrr   : F3_1<3, 0b000000,
+                  (outs IntRegs:$dst), (ins MEMrr:$addr),
+                  "ld [$addr], $dst",
+                  [(set IntRegs:$dst, (load ADDRrr:$addr))]>;
+def LDri   : F3_2<3, 0b000000,
+                  (outs IntRegs:$dst), (ins MEMri:$addr),
+                  "ld [$addr], $dst",
+                  [(set IntRegs:$dst, (load ADDRri:$addr))]>;
+
+// Section B.2 - Load Floating-point Instructions, p. 92
+def LDFrr  : F3_1<3, 0b100000,
+                  (outs FPRegs:$dst), (ins MEMrr:$addr),
+                  "ld [$addr], $dst",
+                  [(set FPRegs:$dst, (load ADDRrr:$addr))]>;
+def LDFri  : F3_2<3, 0b100000,
+                  (outs FPRegs:$dst), (ins MEMri:$addr),
+                  "ld [$addr], $dst",
+                  [(set FPRegs:$dst, (load ADDRri:$addr))]>;
+def LDDFrr : F3_1<3, 0b100011,
+                  (outs DFPRegs:$dst), (ins MEMrr:$addr),
+                  "ldd [$addr], $dst",
+                  [(set DFPRegs:$dst, (load ADDRrr:$addr))]>;
+def LDDFri : F3_2<3, 0b100011,
+                  (outs DFPRegs:$dst), (ins MEMri:$addr),
+                  "ldd [$addr], $dst",
+                  [(set DFPRegs:$dst, (load ADDRri:$addr))]>;
+
+// Section B.4 - Store Integer Instructions, p. 95
+def STBrr : F3_1<3, 0b000101,
+                 (outs), (ins MEMrr:$addr, IntRegs:$src),
+                 "stb $src, [$addr]",
+                 [(truncstorei8 IntRegs:$src, ADDRrr:$addr)]>;
+def STBri : F3_2<3, 0b000101,
+                 (outs), (ins MEMri:$addr, IntRegs:$src),
+                 "stb $src, [$addr]",
+                 [(truncstorei8 IntRegs:$src, ADDRri:$addr)]>;
+def STHrr : F3_1<3, 0b000110,
+                 (outs), (ins MEMrr:$addr, IntRegs:$src),
+                 "sth $src, [$addr]",
+                 [(truncstorei16 IntRegs:$src, ADDRrr:$addr)]>;
+def STHri : F3_2<3, 0b000110,
+                 (outs), (ins MEMri:$addr, IntRegs:$src),
+                 "sth $src, [$addr]",
+                 [(truncstorei16 IntRegs:$src, ADDRri:$addr)]>;
+def STrr  : F3_1<3, 0b000100,
+                 (outs), (ins MEMrr:$addr, IntRegs:$src),
+                 "st $src, [$addr]",
+                 [(store IntRegs:$src, ADDRrr:$addr)]>;
+def STri  : F3_2<3, 0b000100,
+                 (outs), (ins MEMri:$addr, IntRegs:$src),
+                 "st $src, [$addr]",
+                 [(store IntRegs:$src, ADDRri:$addr)]>;
+
+// Section B.5 - Store Floating-point Instructions, p. 97
+def STFrr   : F3_1<3, 0b100100,
+                   (outs), (ins MEMrr:$addr, FPRegs:$src),
+                   "st $src, [$addr]",
+                   [(store FPRegs:$src, ADDRrr:$addr)]>;
+def STFri   : F3_2<3, 0b100100,
+                   (outs), (ins MEMri:$addr, FPRegs:$src),
+                   "st $src, [$addr]",
+                   [(store FPRegs:$src, ADDRri:$addr)]>;
+def STDFrr  : F3_1<3, 0b100111,
+                   (outs), (ins MEMrr:$addr, DFPRegs:$src),
+                   "std  $src, [$addr]",
+                   [(store DFPRegs:$src, ADDRrr:$addr)]>;
+def STDFri  : F3_2<3, 0b100111,
+                   (outs), (ins MEMri:$addr, DFPRegs:$src),
+                   "std $src, [$addr]",
+                   [(store DFPRegs:$src, ADDRri:$addr)]>;
+
+// Section B.9 - SETHI Instruction, p. 104
+def SETHIi: F2_1<0b100,
+                 (outs IntRegs:$dst), (ins i32imm:$src),
+                 "sethi $src, $dst",
+                 [(set IntRegs:$dst, SETHIimm:$src)]>;
+
+// Section B.10 - NOP Instruction, p. 105
+// (It's a special case of SETHI)
+let rd = 0, imm22 = 0 in
+  def NOP : F2_1<0b100, (outs), (ins), "nop", []>;
+
+// Section B.11 - Logical Instructions, p. 106
+defm AND    : F3_12<"and", 0b000001, and>;
+
+def ANDNrr  : F3_1<2, 0b000101,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                   "andn $b, $c, $dst",
+                   [(set IntRegs:$dst, (and IntRegs:$b, (not IntRegs:$c)))]>;
+def ANDNri  : F3_2<2, 0b000101,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
+                   "andn $b, $c, $dst", []>;
+
+defm OR     : F3_12<"or", 0b000010, or>;
+
+def ORNrr   : F3_1<2, 0b000110,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                   "orn $b, $c, $dst",
+                   [(set IntRegs:$dst, (or IntRegs:$b, (not IntRegs:$c)))]>;
+def ORNri   : F3_2<2, 0b000110,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
+                   "orn $b, $c, $dst", []>;
+defm XOR    : F3_12<"xor", 0b000011, xor>;
+
+def XNORrr  : F3_1<2, 0b000111,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                   "xnor $b, $c, $dst",
+                   [(set IntRegs:$dst, (not (xor IntRegs:$b, IntRegs:$c)))]>;
+def XNORri  : F3_2<2, 0b000111,
+                   (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
+                   "xnor $b, $c, $dst", []>;
+
+// Section B.12 - Shift Instructions, p. 107
+defm SLL : F3_12<"sll", 0b100101, shl>;
+defm SRL : F3_12<"srl", 0b100110, srl>;
+defm SRA : F3_12<"sra", 0b100111, sra>;
+
+// Section B.13 - Add Instructions, p. 108
+defm ADD   : F3_12<"add", 0b000000, add>;
+
+// "LEA" forms of add (patterns to make tblgen happy)
+def LEA_ADDri   : F3_2<2, 0b000000,
+                   (outs IntRegs:$dst), (ins MEMri:$addr),
+                   "add ${addr:arith}, $dst",
+                   [(set IntRegs:$dst, ADDRri:$addr)]>;
+
+let Defs = [ICC] in                   
+  defm ADDCC  : F3_12<"addcc", 0b010000, addc>;
+
+let Uses = [ICC] in
+  defm ADDX  : F3_12<"addx", 0b001000, adde>;
+
+// Section B.15 - Subtract Instructions, p. 110
+defm SUB    : F3_12  <"sub"  , 0b000100, sub>;
+let Uses = [ICC] in 
+  defm SUBX   : F3_12  <"subx" , 0b001100, sube>;
+
+let Defs = [ICC] in 
+  defm SUBCC  : F3_12  <"subcc", 0b010100, SPcmpicc>;
+
+let Uses = [ICC], Defs = [ICC] in
+  def SUBXCCrr: F3_1<2, 0b011100, 
+                (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
+                "subxcc $b, $c, $dst", []>;
+
+
+// Section B.18 - Multiply Instructions, p. 113
+let Defs = [Y] in {
+  defm UMUL : F3_12np<"umul", 0b001010>;
+  defm SMUL : F3_12  <"smul", 0b001011, mul>;
+}
+
+// Section B.19 - Divide Instructions, p. 115
+let Defs = [Y] in {
+  defm UDIV : F3_12np<"udiv", 0b001110>;
+  defm SDIV : F3_12np<"sdiv", 0b001111>;
+}
+
+// Section B.20 - SAVE and RESTORE, p. 117
+defm SAVE    : F3_12np<"save"   , 0b111100>;
+defm RESTORE : F3_12np<"restore", 0b111101>;
+
+// Section B.21 - Branch on Integer Condition Codes Instructions, p. 119
+
+// conditional branch class:
+class BranchSP<bits<4> cc, dag ins, string asmstr, list<dag> pattern>
+ : F2_2<cc, 0b010, (outs), ins, asmstr, pattern> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let hasDelaySlot = 1;
+}
+
+let isBarrier = 1 in
+  def BA   : BranchSP<0b1000, (ins brtarget:$dst),
+                      "ba $dst",
+                      [(br bb:$dst)]>;
+
+// FIXME: the encoding for the JIT should look at the condition field.
+let Uses = [ICC] in
+  def BCOND : BranchSP<0, (ins brtarget:$dst, CCOp:$cc),
+                         "b$cc $dst",
+                        [(SPbricc bb:$dst, imm:$cc)]>;
+
+
+// Section B.22 - Branch on Floating-point Condition Codes Instructions, p. 121
+
+// floating-point conditional branch class:
+class FPBranchSP<bits<4> cc, dag ins, string asmstr, list<dag> pattern>
+ : F2_2<cc, 0b110, (outs), ins, asmstr, pattern> {
+  let isBranch = 1;
+  let isTerminator = 1;
+  let hasDelaySlot = 1;
+}
+
+// FIXME: the encoding for the JIT should look at the condition field.
+let Uses = [FCC] in
+  def FBCOND  : FPBranchSP<0, (ins brtarget:$dst, CCOp:$cc),
+                              "fb$cc $dst",
+                              [(SPbrfcc bb:$dst, imm:$cc)]>;
+
+
+// Section B.24 - Call and Link Instruction, p. 125
+// This is the only Format 1 instruction
+let Uses = [O6],
+    hasDelaySlot = 1, isCall = 1,
+    Defs = [O0, O1, O2, O3, O4, O5, O7, G1, G2, G3, G4, G5, G6, G7,
+    D0, D1, D2, D3, D4, D5, D6, D7, D8, D9, D10, D11, D12, D13, D14, D15,
+        ICC, FCC, Y] in {
+  def CALL : InstSP<(outs), (ins calltarget:$dst, variable_ops),
+                    "call $dst", []> {
+    bits<30> disp;
+    let op = 1;
+    let Inst{29-0} = disp;
+  }
+  
+  // indirect calls
+  def JMPLrr : F3_1<2, 0b111000,
+                    (outs), (ins MEMrr:$ptr, variable_ops),
+                    "call $ptr",
+                    [(call ADDRrr:$ptr)]>;
+  def JMPLri : F3_2<2, 0b111000,
+                    (outs), (ins MEMri:$ptr, variable_ops),
+                    "call $ptr",
+                    [(call ADDRri:$ptr)]>;
+}
+
+// Section B.28 - Read State Register Instructions
+let Uses = [Y] in 
+  def RDY : F3_1<2, 0b101000,
+                 (outs IntRegs:$dst), (ins),
+                 "rd %y, $dst", []>;
+
+// Section B.29 - Write State Register Instructions
+let Defs = [Y] in {
+  def WRYrr : F3_1<2, 0b110000,
+                   (outs), (ins IntRegs:$b, IntRegs:$c),
+                   "wr $b, $c, %y", []>;
+  def WRYri : F3_2<2, 0b110000,
+                   (outs), (ins IntRegs:$b, i32imm:$c),
+                   "wr $b, $c, %y", []>;
+}
+// Convert Integer to Floating-point Instructions, p. 141
+def FITOS : F3_3<2, 0b110100, 0b011000100,
+                 (outs FPRegs:$dst), (ins FPRegs:$src),
+                 "fitos $src, $dst",
+                 [(set FPRegs:$dst, (SPitof FPRegs:$src))]>;
+def FITOD : F3_3<2, 0b110100, 0b011001000, 
+                 (outs DFPRegs:$dst), (ins FPRegs:$src),
+                 "fitod $src, $dst",
+                 [(set DFPRegs:$dst, (SPitof FPRegs:$src))]>;
+
+// Convert Floating-point to Integer Instructions, p. 142
+def FSTOI : F3_3<2, 0b110100, 0b011010001,
+                 (outs FPRegs:$dst), (ins FPRegs:$src),
+                 "fstoi $src, $dst",
+                 [(set FPRegs:$dst, (SPftoi FPRegs:$src))]>;
+def FDTOI : F3_3<2, 0b110100, 0b011010010,
+                 (outs FPRegs:$dst), (ins DFPRegs:$src),
+                 "fdtoi $src, $dst",
+                 [(set FPRegs:$dst, (SPftoi DFPRegs:$src))]>;
+
+// Convert between Floating-point Formats Instructions, p. 143
+def FSTOD : F3_3<2, 0b110100, 0b011001001, 
+                 (outs DFPRegs:$dst), (ins FPRegs:$src),
+                 "fstod $src, $dst",
+                 [(set DFPRegs:$dst, (fextend FPRegs:$src))]>;
+def FDTOS : F3_3<2, 0b110100, 0b011000110,
+                 (outs FPRegs:$dst), (ins DFPRegs:$src),
+                 "fdtos $src, $dst",
+                 [(set FPRegs:$dst, (fround DFPRegs:$src))]>;
+
+// Floating-point Move Instructions, p. 144
+def FMOVS : F3_3<2, 0b110100, 0b000000001,
+                 (outs FPRegs:$dst), (ins FPRegs:$src),
+                 "fmovs $src, $dst", []>;
+def FNEGS : F3_3<2, 0b110100, 0b000000101, 
+                 (outs FPRegs:$dst), (ins FPRegs:$src),
+                 "fnegs $src, $dst",
+                 [(set FPRegs:$dst, (fneg FPRegs:$src))]>;
+def FABSS : F3_3<2, 0b110100, 0b000001001, 
+                 (outs FPRegs:$dst), (ins FPRegs:$src),
+                 "fabss $src, $dst",
+                 [(set FPRegs:$dst, (fabs FPRegs:$src))]>;
+
+
+// Floating-point Square Root Instructions, p.145
+def FSQRTS : F3_3<2, 0b110100, 0b000101001, 
+                  (outs FPRegs:$dst), (ins FPRegs:$src),
+                  "fsqrts $src, $dst",
+                  [(set FPRegs:$dst, (fsqrt FPRegs:$src))]>;
+def FSQRTD : F3_3<2, 0b110100, 0b000101010, 
+                  (outs DFPRegs:$dst), (ins DFPRegs:$src),
+                  "fsqrtd $src, $dst",
+                  [(set DFPRegs:$dst, (fsqrt DFPRegs:$src))]>;
+
+
+
+// Floating-point Add and Subtract Instructions, p. 146
+def FADDS  : F3_3<2, 0b110100, 0b001000001,
+                  (outs FPRegs:$dst), (ins FPRegs:$src1, FPRegs:$src2),
+                  "fadds $src1, $src2, $dst",
+                  [(set FPRegs:$dst, (fadd FPRegs:$src1, FPRegs:$src2))]>;
+def FADDD  : F3_3<2, 0b110100, 0b001000010,
+                  (outs DFPRegs:$dst), (ins DFPRegs:$src1, DFPRegs:$src2),
+                  "faddd $src1, $src2, $dst",
+                  [(set DFPRegs:$dst, (fadd DFPRegs:$src1, DFPRegs:$src2))]>;
+def FSUBS  : F3_3<2, 0b110100, 0b001000101,
+                  (outs FPRegs:$dst), (ins FPRegs:$src1, FPRegs:$src2),
+                  "fsubs $src1, $src2, $dst",
+                  [(set FPRegs:$dst, (fsub FPRegs:$src1, FPRegs:$src2))]>;
+def FSUBD  : F3_3<2, 0b110100, 0b001000110,
+                  (outs DFPRegs:$dst), (ins DFPRegs:$src1, DFPRegs:$src2),
+                  "fsubd $src1, $src2, $dst",
+                  [(set DFPRegs:$dst, (fsub DFPRegs:$src1, DFPRegs:$src2))]>;
+
+// Floating-point Multiply and Divide Instructions, p. 147
+def FMULS  : F3_3<2, 0b110100, 0b001001001,
+                  (outs FPRegs:$dst), (ins FPRegs:$src1, FPRegs:$src2),
+                  "fmuls $src1, $src2, $dst",
+                  [(set FPRegs:$dst, (fmul FPRegs:$src1, FPRegs:$src2))]>;
+def FMULD  : F3_3<2, 0b110100, 0b001001010,
+                  (outs DFPRegs:$dst), (ins DFPRegs:$src1, DFPRegs:$src2),
+                  "fmuld $src1, $src2, $dst",
+                  [(set DFPRegs:$dst, (fmul DFPRegs:$src1, DFPRegs:$src2))]>;
+def FSMULD : F3_3<2, 0b110100, 0b001101001,
+                  (outs DFPRegs:$dst), (ins FPRegs:$src1, FPRegs:$src2),
+                  "fsmuld $src1, $src2, $dst",
+                  [(set DFPRegs:$dst, (fmul (fextend FPRegs:$src1),
+                                            (fextend FPRegs:$src2)))]>;
+def FDIVS  : F3_3<2, 0b110100, 0b001001101,
+                 (outs FPRegs:$dst), (ins FPRegs:$src1, FPRegs:$src2),
+                 "fdivs $src1, $src2, $dst",
+                 [(set FPRegs:$dst, (fdiv FPRegs:$src1, FPRegs:$src2))]>;
+def FDIVD  : F3_3<2, 0b110100, 0b001001110,
+                 (outs DFPRegs:$dst), (ins DFPRegs:$src1, DFPRegs:$src2),
+                 "fdivd $src1, $src2, $dst",
+                 [(set DFPRegs:$dst, (fdiv DFPRegs:$src1, DFPRegs:$src2))]>;
+
+// Floating-point Compare Instructions, p. 148
+// Note: the 2nd template arg is different for these guys.
+// Note 2: the result of a FCMP is not available until the 2nd cycle
+// after the instr is retired, but there is no interlock. This behavior
+// is modelled with a forced noop after the instruction.
+let Defs = [FCC] in {
+  def FCMPS  : F3_3<2, 0b110101, 0b001010001,
+                   (outs), (ins FPRegs:$src1, FPRegs:$src2),
+                   "fcmps $src1, $src2\n\tnop",
+                   [(SPcmpfcc FPRegs:$src1, FPRegs:$src2)]>;
+  def FCMPD  : F3_3<2, 0b110101, 0b001010010,
+                   (outs), (ins DFPRegs:$src1, DFPRegs:$src2),
+                   "fcmpd $src1, $src2\n\tnop",
+                   [(SPcmpfcc DFPRegs:$src1, DFPRegs:$src2)]>;
+}
+
+//===----------------------------------------------------------------------===//
+// Individual CBG Instructions Extensions
+//===----------------------------------------------------------------------===//
+
+// select instructions: support all possibilities
+let Predicates = [HasSelCC], Uses = [ICC] in {
+  def SELcc_ii
+    : Pseudo<(outs IntRegs:$dst), (ins  i32imm:$im1, i32imm:$im2, CCOp:$cc),
+             "sel[$cc] $im1, $im2, $dst",
+             [(set IntRegs:$dst, 
+                          (SPselecticc simm8:$im1, simm8:$im2, imm:$cc))]>;
+  def SELcc_ri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$im2, CCOp:$cc),
+             "sel[$cc] $src1, $im2, $dst",
+             [(set IntRegs:$dst,
+                          (SPselecticc IntRegs:$src1, simm11:$im2, imm:$cc))]>;
+  def SELcc_ir
+    : Pseudo<(outs IntRegs:$dst), (ins i32imm:$im1, IntRegs:$src2, CCOp:$cc),
+             "sel[$cc] $im1, $src2, $dst",
+             [(set IntRegs:$dst,
+                          (SPselecticc simm11:$im1, IntRegs:$src2, imm:$cc))]>;
+  def SELcc_rr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, CCOp:$cc),
+             "sel[$cc] $src1, $src2, $dst",
+             [(set IntRegs:$dst,
+                          (SPselecticc IntRegs:$src1, IntRegs:$src2, imm:$cc))]>;
+}
+
+
+// conditional move instructions
+let Predicates = [HasMovCC], Uses = [ICC], Constraints = "$src2 = $dst" in {
+  def MOVcc_rr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, CCOp:$cc),
+             "mov[$cc] $src1, $src2",
+             [(set IntRegs:$dst,
+                          (SPselecticc IntRegs:$src1, IntRegs:$src2, imm:$cc))]>;
+}
+
+// hardware loop instruction
+let Predicates = [HasHWLoop, HasHWLoops] in {
+  let isBranch = 1, isTerminator = 1 in 
+  def HWLOOP 
+    : Pseudo<(outs), (ins),
+             "hwloop start",
+             []>;
+  def HWLOOPinit
+    : Pseudo<(outs HWLOOPRegs:$dst), (ins brtarget:$src),
+             "hwloop init $src, $dst",
+             []>;
+}
+
+// predicated blocks on icc
+let Predicates = [HasPredBlocksCC], Uses = [ICC] in {
+  def PREDBLOCKCC_BEGIN
+    : Pseudo<(outs), (ins CCOp:$cc),
+             "predbegin[$cc]",
+             []>;
+  def PREDBLOCKCC_END
+    : Pseudo<(outs), (ins),
+             "predend",
+             []>;
+}
+
+// predicated blocks on pregs
+let Predicates = [HasPredBlocksReg] in {
+  def PREDBLOCKREG_BEGIN_T
+    : Pseudo<(outs), (ins PREDRegs:$pred),
+             "predbegin[$pred][t]",
+             []>;
+  def PREDBLOCKREG_BEGIN_F
+    : Pseudo<(outs), (ins PREDRegs:$pred),
+             "predbegin[$pred][f]",
+             []>;
+  def PREDBLOCKREG_END
+    : Pseudo<(outs), (ins),
+             "predend",
+             []>;
+}
+
+let Uses = [ICC] in def PREDREGSETCC
+  : Pseudo<(outs PREDRegs:$pred), (ins CCOp:$cc),
+           "predset[$cc] $pred",
+           []>;
+def PREDREGSET
+  : Pseudo<(outs PREDRegs:$pred), (ins),
+           "predset $pred",
+           []>;
+def PREDREGCLEAR
+  : Pseudo<(outs PREDRegs:$pred), (ins),
+           "predclear $pred",
+           []>;
+
+
+// predicated instruction templates
+multiclass Pseudo_pcc<string OpcStr, SDNode OpNode> {
+  def rr  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+                   !strconcat(OpcStr, "[$cc] $src1, $src2, $dst"),
+                   [(set IntRegs:$dst, (OpNode IntRegs:$src1, IntRegs:$src2))]>;
+  def ri  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+                   !strconcat(OpcStr, "[$cc] $src1, $src2, $dst"),
+                   [(set IntRegs:$dst, (OpNode IntRegs:$src1, simm13:$src2))]>;
+}
+
+multiclass Pseudo_pcc_np<string OpcStr> {
+  def rr  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+                   !strconcat(OpcStr, "[$cc] $src1, $src2, $dst"),
+                   []>;
+  def ri  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+                   !strconcat(OpcStr, "[$cc] $src1, $src2, $dst"),
+                   []>;
+}
+
+
+
+// predicated instructions with condition codes
+let Predicates = [HasPredInstrCC], Uses = [ICC] in {
+
+  // Section A.3 - Synthetic Instructions, p. 85
+  // special cases of JMPL:
+  let isReturn = 1, isTerminator = 1, hasDelaySlot = 1, isBarrier = 1 in {
+    def RETL_pcc
+      : Pseudo<(outs), (ins i32imm:$val, pred_cc:$cc),
+               "jmp[$cc] %o7+$val", 
+               [(retflag simm13:$val)]>;
+
+    def RET_pcc
+      : Pseudo<(outs), (ins i32imm:$val, pred_cc:$cc),
+               "jmp[$cc] %i7+$val", 
+               []>;
+  }
+
+  // Section B.1 - Load Integer Instructions, p. 90
+  def LDSB_pccrr 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, pred_cc:$cc),
+             "ldsb[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (sextloadi8 ADDRrr:$addr))]>;
+  def LDSB_pccri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "ldsb[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (sextloadi8 ADDRri:$addr))]>;
+  def LDSH_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, pred_cc:$cc),
+             "ldsh[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (sextloadi16 ADDRrr:$addr))]>;
+  def LDSH_pccri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "ldsh[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (sextloadi16 ADDRri:$addr))]>;
+  def LDUB_pccrr 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, pred_cc:$cc),
+             "ldub[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (zextloadi8 ADDRrr:$addr))]>;
+  def LDUB_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "ldub[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (zextloadi8 ADDRri:$addr))]>;
+  def LDUH_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, pred_cc:$cc),
+             "lduh[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (zextloadi16 ADDRrr:$addr))]>;
+  def LDUH_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "lduh[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (zextloadi16 ADDRri:$addr))]>;
+  def LD_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, pred_cc:$cc),
+             "ld[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (load ADDRrr:$addr))]>;
+  def LD_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "ld[$cc] [$addr], $dst",
+             [(set IntRegs:$dst, (load ADDRri:$addr))]>;
+  
+  // Section B.4 - Store Integer Instructions, p. 95
+  def STB_pccrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, pred_cc:$cc),
+             "stb[$cc] $src, [$addr]",
+             [(truncstorei8 IntRegs:$src, ADDRrr:$addr)]>;
+  def STB_pccri
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, pred_cc:$cc),
+             "stb[$cc] $src, [$addr]",
+             [(truncstorei8 IntRegs:$src, ADDRri:$addr)]>;
+  def STH_pccrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, pred_cc:$cc),
+             "sth[$cc] $src, [$addr]",
+             [(truncstorei16 IntRegs:$src, ADDRrr:$addr)]>;
+  def STH_pccri
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, pred_cc:$cc),
+             "sth[$cc] $src, [$addr]",
+             [(truncstorei16 IntRegs:$src, ADDRri:$addr)]>;
+  def ST_pccrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, pred_cc:$cc),
+             "st[$cc] $src, [$addr]",
+             [(store IntRegs:$src, ADDRrr:$addr)]>;
+  def ST_pccri 
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, pred_cc:$cc),
+             "st[$cc] $src, [$addr]",
+             [(store IntRegs:$src, ADDRri:$addr)]>;
+
+  // Section B.9 - SETHI Instruction, p. 104
+  def SETHIi_pcc
+    : Pseudo<(outs IntRegs:$dst), (ins i32imm:$src, pred_cc:$cc),
+             "sethi[$cc] $src, $dst",
+             [(set IntRegs:$dst, SETHIimm:$src)]>;
+
+  // Section B.11 - Logical Instructions, p. 106
+  defm AND_pcc : Pseudo_pcc<"and", and>;
+
+  def ANDN_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+             "andn[$cc] $src1, $src2, $dst",
+             [(set IntRegs:$dst, (and IntRegs:$src1, (not IntRegs:$src2)))]>;
+
+  def ANDN_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+             "andn[$cc] $src1, $src2, $dst", 
+             []>;
+
+  defm OR_pcc : Pseudo_pcc<"or", or>;
+
+  def ORN_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+             "orn[$cc] $src1, $src2, $dst",
+             [(set IntRegs:$dst, (or IntRegs:$src1, (not IntRegs:$src2)))]>;
+
+  def ORN_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+             "orn[$cc] $src1, $src2, $dst", 
+             []>;
+
+  defm XOR_pcc : Pseudo_pcc<"xor", xor>;
+
+  def XNOR_pccrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+             "xnor[$cc] $src1, $src2, $dst",
+             [(set IntRegs:$dst, (not (xor IntRegs:$src1, IntRegs:$src2)))]>;
+
+  def XNOR_pccri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+             "xnor[$cc] $src1, $src2, $dst", 
+             []>;
+
+  // Section B.12 - Shift Instructions, p. 107
+  defm SLL_pcc : Pseudo_pcc<"sll", shl>;
+  defm SRL_pcc : Pseudo_pcc<"srl", srl>;
+  defm SRA_pcc : Pseudo_pcc<"sra", sra>;
+
+  // Section B.13 - Add Instructions, p. 108
+  defm ADD_pcc : Pseudo_pcc<"add", add>;
+  defm ADDX_pcc : Pseudo_pcc<"addx", adde>;
+
+  // "LEA" forms of add (patterns to make tblgen happy)
+  def LEA_ADD_pccri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, pred_cc:$cc),
+             "add[$cc] ${addr:arith}, $dst",
+             [(set IntRegs:$dst, ADDRri:$addr)]>;
+
+  // Section B.15 - Subtract Instructions, p. 110
+  defm SUB_pcc : Pseudo_pcc<"sub", sub>;
+  defm SUBX_pcc : Pseudo_pcc<"subx", sube>;
+
+  // Section B.18 - Multiply Instructions, p. 113
+  /*let Defs = [Y] in {
+    defm UMUL_pcc : Pseudo_pcc_np<"umul">;
+    defm SMUL_pcc : Pseudo_pcc<"smul", mul>;
+  }*/
+
+  let Defs = [Y] in {
+    def UMUL_pccrr
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "umul[$cc] $src1, $src2, $dst",
+               []>;
+    def UMUL_pccri
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "umul[$cc] $src1, $src2, $dst",
+               []>;
+    def SMUL_pccrr
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "smul[$cc] $src1, $src2, $dst",
+               []>;
+    def SMUL_pccri 
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "smul[$cc] $src1, $src2, $dst",
+               []>;
+  }
+
+
+  // Section B.19 - Divide Instructions, p. 115
+  /*let Defs = [Y] in {
+    defm UDIV_pcc : Pseudo_pcc_np<"udiv">;
+    defm SDIV_pcc : Pseudo_pcc_np<"sdiv">;
+  }*/
+
+  let Defs = [Y] in {
+    def UDIV_pccrr
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "udiv[$cc] $src1, $src2, $dst",
+               []>;
+    def UDIV_pccri
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "udiv[$cc] $src1, $src2, $dst",
+               []>;
+    def SDIV_pccrr
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "sdiv[$cc] $src1, $src2, $dst",
+               []>;
+    def SDIV_pccri 
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$Y, pred_cc:$cc),
+               "sdiv[$cc] $src1, $src2, $dst",
+               []>;
+  }
+  // Section B.20 - SAVE and RESTORE, p. 117
+  def SAVE_pccrr 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+             "save[$cc] $src1, $src2, $dst", 
+             []>;
+
+  def SAVE_pccri 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+             "save[$cc] $src1, $src2, $dst", 
+             []>;
+
+  def RESTORE_pccrr 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, pred_cc:$cc),
+             "restore[$cc] $src1, $src2, $dst", 
+             []>;
+
+  def RESTORE_pccri 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, pred_cc:$cc),
+             "restore[$cc] $src1, $src2, $dst", 
+             []>;
+
+  // Section B.28 - Read State Register Instructions
+  let Uses = [Y] in 
+    def RDY_pcc 
+      : Pseudo<(outs IntRegs:$dst), (ins pred_cc:$cc),
+               "rd[$cc] %y, $dst", 
+               []>;
+}
+
+multiclass Pseudo_preg<string OpcStr> {
+  def rr  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+                   !strconcat(OpcStr, "[$pred][$tf] $src1, $src2, $dst"),
+                   []>;
+  def ri  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+                   !strconcat(OpcStr, "[$pred][$tf] $src1, $src2, $dst"),
+                   []>;
+}
+
+multiclass Pseudo_preg_mdiv<string OpcStr> {
+  def rr  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$Y, PREDRegs:$pred, TFOp:$tf),
+                   !strconcat(OpcStr, "[$pred][$tf] $src1, $src2, $dst"),
+                   []>;
+  def ri  : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$Y, PREDRegs:$pred, TFOp:$tf),
+                   !strconcat(OpcStr, "[$pred][$tf] $src1, $src2, $dst"),
+                   []>;
+}
+// predicated instructions with predicate register
+let Predicates = [HasPredInstrReg] in {
+
+  // Section A.3 - Synthetic Instructions, p. 85
+  // special cases of JMPL:
+  let isReturn = 1, isTerminator = 1, hasDelaySlot = 1, isBarrier = 1 in {
+    def RETL_preg
+      : Pseudo<(outs), (ins i32imm:$val, PREDRegs:$pred, TFOp:$tf),
+               "jmp[$pred][$tf] %o7+$val", 
+               []>;
+
+    def RET_preg
+      : Pseudo<(outs), (ins i32imm:$val, PREDRegs:$pred, TFOp:$tf),
+               "jmp[$pred][$tf] %i7+$val", 
+               []>;
+  }
+
+  // Section B.1 - Load Integer Instructions, p. 90
+  def LDSB_pregrr 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldsb[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDSB_pregri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldsb[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDSH_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldsh[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDSH_pregri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldsh[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDUB_pregrr 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldub[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDUB_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ldub[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDUH_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, PREDRegs:$pred, TFOp:$tf),
+             "lduh[$pred][$tf] [$addr], $dst",
+             []>;
+  def LDUH_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "lduh[$pred][$tf] [$addr], $dst",
+             []>;
+  def LD_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins MEMrr:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ld[$pred][$tf] [$addr], $dst",
+             []>;
+  def LD_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "ld[$pred][$tf] [$addr], $dst",
+             []>;
+  
+  // Section B.4 - Store Integer Instructions, p. 95
+  def STB_pregrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "stb[$pred][$tf] $src, [$addr]",
+             []>;
+  def STB_pregri
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "stb[$pred][$tf] $src, [$addr]",
+             []>;
+  def STH_pregrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "sth[$pred][$tf] $src, [$addr]",
+             []>;
+  def STH_pregri
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "sth[$pred][$tf] $src, [$addr]",
+             []>;
+  def ST_pregrr
+    : Pseudo<(outs), (ins MEMrr:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "st[$pred][$tf] $src, [$addr]",
+             []>;
+  def ST_pregri 
+    : Pseudo<(outs), (ins MEMri:$addr, IntRegs:$src, PREDRegs:$pred, TFOp:$tf),
+             "st[$pred][$tf] $src, [$addr]",
+             []>;
+
+  // Section B.9 - SETHI Instruction, p. 104
+  def SETHIi_preg
+    : Pseudo<(outs IntRegs:$dst), (ins i32imm:$src, PREDRegs:$pred, TFOp:$tf),
+             "sethi[$pred][$tf] $src, $dst",
+             []>;
+
+  // Section B.11 - Logical Instructions, p. 106
+  defm AND_preg : Pseudo_preg<"and">;
+
+  def ANDN_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+             "andn[$pred][$tf] $src1, $src2, $dst",
+             []>;
+
+  def ANDN_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+             "andn[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  defm OR_preg : Pseudo_preg<"or">;
+
+  def ORN_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+             "orn[$pred][$tf] $src1, $src2, $dst",
+             []>;
+
+  def ORN_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+             "orn[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  defm XOR_preg : Pseudo_preg<"xor">;
+
+  def XNOR_pregrr
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+             "xnor[$pred][$tf] $src1, $src2, $dst",
+             []>;
+
+  def XNOR_pregri
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+             "xnor[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  // Section B.12 - Shift Instructions, p. 107
+  defm SLL_preg : Pseudo_preg<"sll">;
+  defm SRL_preg : Pseudo_preg<"srl">;
+  defm SRA_preg : Pseudo_preg<"sra">;
+
+  // Section B.13 - Add Instructions, p. 108
+  defm ADD_preg : Pseudo_preg<"add">;
+  defm ADDX_preg : Pseudo_preg<"addx">;
+
+  // "LEA" forms of add (patterns to make tblgen happy)
+  def LEA_ADD_pregri 
+    : Pseudo<(outs IntRegs:$dst), (ins MEMri:$addr, PREDRegs:$pred, TFOp:$tf),
+             "add[$pred][$tf] ${addr:arith}, $dst",
+             []>;
+
+  // Section B.15 - Subtract Instructions, p. 110
+  defm SUB_preg : Pseudo_preg<"sub">;
+  defm SUBX_preg : Pseudo_preg<"subx">;
+  let Defs = [ICC] in {
+    def SUBCC_pregrr 
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, SpecialRegs:$icc, PREDRegs:$pred, TFOp:$tf),
+               "subcc[$pred][$tf] $src1, $src2, $dst",
+               []>;
+    def SUBCC_pregri 
+      : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, SpecialRegs:$icc, PREDRegs:$pred, TFOp:$tf),
+               "subcc[$pred][$tf] $src1, $src2, $dst",
+               []>;
+  }
+
+  // Section B.18 - Multiply Instructions, p. 113
+  let Defs = [Y] in {
+    defm UMUL_preg : Pseudo_preg_mdiv<"umul">;
+    defm SMUL_preg : Pseudo_preg_mdiv<"smul">;
+  }
+
+  // Section B.19 - Divide Instructions, p. 115
+  let Defs = [Y] in {
+    defm UDIV_preg : Pseudo_preg_mdiv<"udiv">;
+    defm SDIV_preg : Pseudo_preg_mdiv<"sdiv">;
+  }
+
+  // Section B.20 - SAVE and RESTORE, p. 117
+  def SAVE_pregrr 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+             "save[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  def SAVE_pregri 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+             "save[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  def RESTORE_pregrr 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, IntRegs:$src2, PREDRegs:$pred, TFOp:$tf),
+             "restore[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  def RESTORE_pregri 
+    : Pseudo<(outs IntRegs:$dst), (ins IntRegs:$src1, i32imm:$src2, PREDRegs:$pred, TFOp:$tf),
+             "restore[$pred][$tf] $src1, $src2, $dst", 
+             []>;
+
+  // Section B.28 - Read State Register Instructions
+  let Uses = [Y] in 
+    def RDY_preg 
+      : Pseudo<(outs IntRegs:$dst), (ins PREDRegs:$pred, TFOp:$tf),
+               "rd[$pred][$tf] %y, $dst", 
+               []>;
+
+  // allow predicated setting of predicate registers...
+  let Uses = [ICC] in def PREDREGSETCC_PREG
+    : Pseudo<(outs PREDRegs:$dstpred), (ins CCOp:$cc, SpecialRegs:$icc, PREDRegs:$pred, TFOp:$tf),
+             "predset[$pred][$tf][$cc] $dstpred",
+             []>;
+
+}
+
+//===----------------------------------------------------------------------===//
+// Non-Instruction Patterns
+//===----------------------------------------------------------------------===//
+
+// Small immediates.
+def : Pat<(i32 simm13:$val),
+          (ORri G0, imm:$val)>;
+// Arbitrary immediates.
+def : Pat<(i32 imm:$val),
+          (ORri (SETHIi (HI22 imm:$val)), (LO10 imm:$val))>;
+
+// subc
+def : Pat<(subc IntRegs:$b, IntRegs:$c),
+          (SUBCCrr IntRegs:$b, IntRegs:$c)>;
+def : Pat<(subc IntRegs:$b, simm13:$val),
+          (SUBCCri IntRegs:$b, imm:$val)>;
+
+// Global addresses, constant pool entries
+def : Pat<(SPhi tglobaladdr:$in), (SETHIi tglobaladdr:$in)>;
+def : Pat<(SPlo tglobaladdr:$in), (ORri G0, tglobaladdr:$in)>;
+def : Pat<(SPhi tconstpool:$in), (SETHIi tconstpool:$in)>;
+def : Pat<(SPlo tconstpool:$in), (ORri G0, tconstpool:$in)>;
+
+// Add reg, lo.  This is used when taking the addr of a global/constpool entry.
+def : Pat<(add IntRegs:$r, (SPlo tglobaladdr:$in)),
+          (ADDri IntRegs:$r, tglobaladdr:$in)>;
+def : Pat<(add IntRegs:$r, (SPlo tconstpool:$in)),
+          (ADDri IntRegs:$r, tconstpool:$in)>;
+
+// Calls: 
+def : Pat<(call tglobaladdr:$dst),
+          (CALL tglobaladdr:$dst)>;
+def : Pat<(call texternalsym:$dst),
+          (CALL texternalsym:$dst)>;
+
+// Map integer extload's to zextloads.
+def : Pat<(i32 (extloadi1 ADDRrr:$src)), (LDUBrr ADDRrr:$src)>;
+def : Pat<(i32 (extloadi1 ADDRri:$src)), (LDUBri ADDRri:$src)>;
+def : Pat<(i32 (extloadi8 ADDRrr:$src)), (LDUBrr ADDRrr:$src)>;
+def : Pat<(i32 (extloadi8 ADDRri:$src)), (LDUBri ADDRri:$src)>;
+def : Pat<(i32 (extloadi16 ADDRrr:$src)), (LDUHrr ADDRrr:$src)>;
+def : Pat<(i32 (extloadi16 ADDRri:$src)), (LDUHri ADDRri:$src)>;
+
+// zextload bool -> zextload byte
+def : Pat<(i32 (zextloadi1 ADDRrr:$src)), (LDUBrr ADDRrr:$src)>;
+def : Pat<(i32 (zextloadi1 ADDRri:$src)), (LDUBri ADDRri:$src)>;
diff --git a/lib/Target/cbg/cbgMCAsmInfo.cpp b/lib/Target/cbg/cbgMCAsmInfo.cpp
new file mode 100644
index 0000000..efc17fb
--- /dev/null
+++ b/lib/Target/cbg/cbgMCAsmInfo.cpp
@@ -0,0 +1,34 @@
+//===-- cbgMCAsmInfo.cpp - cbg asm properties -------------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the declarations of the cbgMCAsmInfo properties.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgMCAsmInfo.h"
+using namespace llvm;
+
+cbgELFMCAsmInfo::cbgELFMCAsmInfo(const Target &T, StringRef TT) {
+  Data16bitsDirective = "\t.half\t";
+  Data32bitsDirective = "\t.word\t";
+  Data64bitsDirective = 0;  // .xword is only supported by V9.
+  ZeroDirective = "\t.skip\t";
+  CommentString = "!";
+  HasLEB128 = true;
+  SupportsDebugInformation = true;
+  
+  SunStyleELFSectionSwitchSyntax = true;
+  UsesELFSectionDirectiveForBSS = true;
+
+  WeakRefDirective = "\t.weak\t";
+
+  PrivateGlobalPrefix = ".L";
+}
+
+
diff --git a/lib/Target/cbg/cbgMCAsmInfo.h b/lib/Target/cbg/cbgMCAsmInfo.h
new file mode 100644
index 0000000..9dbb726
--- /dev/null
+++ b/lib/Target/cbg/cbgMCAsmInfo.h
@@ -0,0 +1,29 @@
+//=====-- cbgMCAsmInfo.h - cbg asm properties -------------*- C++ -*--====//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the declaration of the cbgMCAsmInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBGTARGETASMINFO_H
+#define CBGTARGETASMINFO_H
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/MC/MCAsmInfo.h"
+
+namespace llvm {
+  class Target;
+
+  struct cbgELFMCAsmInfo : public MCAsmInfo {
+    explicit cbgELFMCAsmInfo(const Target &T, StringRef TT);
+  };
+
+} // namespace llvm
+
+#endif
diff --git a/lib/Target/cbg/cbgMachineFunctionInfo.h b/lib/Target/cbg/cbgMachineFunctionInfo.h
new file mode 100644
index 0000000..6cb5e16
--- /dev/null
+++ b/lib/Target/cbg/cbgMachineFunctionInfo.h
@@ -0,0 +1,47 @@
+//===- cbgMachineFunctionInfo.h - CBG Machine Function Info -*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares  cbg specific per-machine-function information.
+//
+//===----------------------------------------------------------------------===//
+#ifndef CBGMACHINEFUNCTIONINFO_H
+#define CBGMACHINEFUNCTIONINFO_H
+
+#include "llvm/CodeGen/MachineFunction.h"
+
+namespace llvm {
+
+  class cbgMachineFunctionInfo : public MachineFunctionInfo {
+  private:
+    unsigned GlobalBaseReg;
+
+    /// VarArgsFrameOffset - Frame offset to start of varargs area.
+    int VarArgsFrameOffset;
+
+    /// SRetReturnReg - Holds the virtual register into which the sret
+    /// argument is passed.
+    unsigned SRetReturnReg;
+  public:
+    cbgMachineFunctionInfo()
+      : GlobalBaseReg(0), VarArgsFrameOffset(0), SRetReturnReg(0) {}
+    explicit cbgMachineFunctionInfo(MachineFunction &MF)
+      : GlobalBaseReg(0), VarArgsFrameOffset(0), SRetReturnReg(0) {}
+
+    unsigned getGlobalBaseReg() const { return GlobalBaseReg; }
+    void setGlobalBaseReg(unsigned Reg) { GlobalBaseReg = Reg; }
+
+    int getVarArgsFrameOffset() const { return VarArgsFrameOffset; }
+    void setVarArgsFrameOffset(int Offset) { VarArgsFrameOffset = Offset; }
+
+    unsigned getSRetReturnReg() const { return SRetReturnReg; }
+    void setSRetReturnReg(unsigned Reg) { SRetReturnReg = Reg; }
+  };
+}
+
+#endif
diff --git a/lib/Target/cbg/cbgPredicationPass.cpp b/lib/Target/cbg/cbgPredicationPass.cpp
new file mode 100644
index 0000000..88b838d
--- /dev/null
+++ b/lib/Target/cbg/cbgPredicationPass.cpp
@@ -0,0 +1,1917 @@
+/**
+ * @file cbgPredicationPass.cpp
+ *
+ * @date 2011-11-14
+ * @author Clemens Bernhard Geyer
+ */
+
+#include "cbg.h"
+#include "cbgInstrInfo.h"
+#include "llvm/CodeGen/MachineBasicBlock.h"
+#include "llvm/CodeGen/MachineFunctionPass.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineOperand.h"
+
+#include <vector>
+#include <list>
+
+#include <iostream>
+
+using namespace llvm;
+
+namespace {
+  /**
+   * @brief Abstract basic class for all predication passes.
+   *        Provides Methods which are required in all predication passes.
+   */
+  class PredicationPass : public MachineFunctionPass {
+
+  public:
+
+    typedef enum {
+      IFELSEBRANCH,
+      IFBRANCH,
+      NOBRANCH
+    } branchType;
+
+    static char ID;
+
+  protected:
+    TargetMachine &TM;
+
+    static int getConditionCode(MachineBasicBlock &MBB);
+
+    static branchType getBranchType(MachineBasicBlock &TBB, MachineBasicBlock &FBB);
+
+    virtual void removeBranches(MachineBasicBlock &MBB);
+    virtual void mergeBlocks(MachineBasicBlock &Pre, MachineBasicBlock &Post);
+
+    struct BranchMBB {
+      MachineBasicBlock* TBB;
+      MachineBasicBlock* FBB;
+      branchType         btype;
+    };
+
+
+  public:
+
+    typedef std::list<BranchMBB> BranchMBB_list;
+    explicit PredicationPass(TargetMachine &tm) : MachineFunctionPass(ID), TM(tm) {}
+    virtual bool runOnMachineFunction(MachineFunction &F) = 0;
+    virtual const char *getPassName() const {
+      return "CBG predication pass";
+    }
+
+  };
+
+  char PredicationPass::ID = 0;
+
+  /**
+   * @brief Pass to insert predicated blocks based on condition
+   *        codes of the status register.
+   */
+  class PredicatedBlocksCCPass : public PredicationPass {
+  protected:
+    virtual bool definesICC(MachineBasicBlock &MBB);
+    virtual bool insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype);
+  public:
+    explicit PredicatedBlocksCCPass(TargetMachine &tm) : PredicationPass(tm) {}
+    virtual bool runOnMachineFunction(MachineFunction &F);
+  };
+
+  /**
+   * @brief Abstract basic class which provides methods for all
+   *        predication passes using predication registers.
+   */
+  class PredicatedRegPass : public PredicationPass {
+  public:
+    typedef std::list<unsigned> RegList;
+  protected:
+    virtual unsigned getNextFreePredRegister(MachineBasicBlock &MBB);
+    virtual unsigned getNextFreePredRegister(MachineBasicBlock &TBB, MachineBasicBlock &FBB);
+    virtual bool isPredRegInList(RegList &rList, unsigned RegNo);
+    virtual RegList getUsedPredRegisters(MachineBasicBlock &MBB);
+    virtual RegList getUsedPredRegisters(MachineBasicBlock &TBB, MachineBasicBlock &FBB);
+    virtual RegList cutPredRegLists(RegList &rList1, RegList &rList2);
+    virtual RegList unitePredRegLists(RegList &rList1, RegList &rList2);
+    virtual RegList removePredRegClears(MachineBasicBlock &MBB);
+  public:
+    explicit PredicatedRegPass(TargetMachine &tm) : PredicationPass(tm) {}
+    virtual bool runOnMachineFunction(MachineFunction &F) = 0;
+  };
+
+  /**
+   * @brief Pass which implements predicated blocks based on predication registers.
+   */
+  class PredicatedBlocksRegPass : public PredicatedRegPass {
+  protected:
+    virtual void replacePredEnds(MachineBasicBlock &MBB, unsigned PReg, unsigned TF);
+    virtual void removePredEnds(MachineBasicBlock &MBB);
+    virtual bool insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype);
+  public:
+    explicit PredicatedBlocksRegPass(TargetMachine &tm) : PredicatedRegPass(tm) {}
+    virtual bool runOnMachineFunction(MachineFunction &F);
+  };
+
+  /**
+   * @brief Pass which implements a fully predicated instruction set based on
+   *        condition codes of the status register.
+   */
+  class PredicatedInstrCCPass : public PredicatedBlocksCCPass {
+  protected:
+    virtual void changeToPredicatedInstruction(MachineBasicBlock &Pre,
+                                               MachineBasicBlock &MBB,
+                                               unsigned ConditionCode);
+    virtual bool insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype);
+  public:
+    explicit PredicatedInstrCCPass(TargetMachine &tm) : PredicatedBlocksCCPass(tm) {}
+  };
+
+  /**
+   * @brief Pass which implements a fully predicated instruction set based on
+   *        predication registers.
+   */
+  class PredicatedInstrRegPass : public PredicatedRegPass {
+  protected:
+    virtual void changeToPredicatedInstruction(MachineBasicBlock &Pre,
+                                               MachineBasicBlock &MBB,
+                                               unsigned PReg,
+                                               unsigned TF);
+    virtual bool insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype);
+  public:
+    explicit PredicatedInstrRegPass(TargetMachine &tm) : PredicatedRegPass(tm) {}
+    virtual bool runOnMachineFunction(MachineFunction &F);
+  };
+
+}
+
+/**
+ * @brief Returns the condition code of the last conditional branch of
+ *        a machine basic block.
+ * @param MBB The Machine basic block to analyze.
+ * @return Either the condition code of the last conditional branch
+ *         or -1 if there is no conditional branch.
+ */
+int PredicationPass::getConditionCode(MachineBasicBlock &MBB) {
+  MachineBasicBlock::reverse_iterator mbb_iter;
+  for (mbb_iter = MBB.rbegin(); mbb_iter != MBB.rend(); ++mbb_iter) {
+    if (mbb_iter->getOpcode() == CBG::BCOND) {
+      return mbb_iter->getOperand(1).getImm();
+    }
+  }
+  return -1;
+}
+
+
+/**
+ * @brief Analyzes whether to given machine basic blocks may be part of
+ *        of an if-then-else construction.
+ * @param TBB Represents the "if-then" branch.
+ * @param FBB Represents the "else" branch in the case of an IFELSEBRANCH or
+ *            the machine basic block logically following TBB in the case of
+ *            an IFBRANCH.
+ * @return NOBRANCH in the case the machine basic blocks cannot be analyzed,
+ *         IFELSEBRANCH in the case both basic blocks conform to an if-then-else
+ *         graph, or IFBRANCH in the case that TBB is an if-branch and FBB is
+ *         the (logically) following basic block.
+ */
+PredicationPass::branchType PredicationPass::getBranchType(MachineBasicBlock &TBB, MachineBasicBlock &FBB) {
+
+  branchType returnValue = NOBRANCH;
+  MachineBasicBlock::pred_iterator mbb_iter;
+
+  if (&TBB == &FBB) {
+   returnValue = NOBRANCH;
+  } // if-else-branch ? => both only have one predecessor
+  else if (TBB.pred_size() == 1 && FBB.pred_size() == 1) {
+    // both have the same predecessor
+    if (*(TBB.pred_begin()) == *(FBB.pred_begin())) {
+      // both have only one successor
+      if (TBB.succ_size() == 1 && FBB.succ_size() == 1) {
+        // both have the same successor
+        if (*(TBB.succ_begin()) == *(FBB.succ_begin())) {
+          // we assume the following layout: Pre -> FBB -> TBB
+          if  ((*(TBB.pred_begin()))->isLayoutSuccessor(&FBB) &&
+                  FBB.isLayoutSuccessor(&TBB))
+            returnValue = IFELSEBRANCH;
+        }
+      }
+    }
+  } else if (TBB.pred_size() == 1 &&
+           (*TBB.pred_begin())->isLayoutSuccessor(&TBB)) {
+    // only if-branch: The (single) predecessor of TBB also has
+    // to be the layout predecessor of TBB.
+    if (TBB.succ_size() == 1 && TBB.isSuccessor(&FBB)) {
+      // TBB must only have one successor and this
+      // successor has to be FBB.
+      if ((*(TBB.pred_begin()))->isSuccessor(&FBB)) {
+        // FBB and TBB must have the same predecessor, but
+        // FBB does not need to be the layout successor of
+        // TBB.
+        returnValue = IFBRANCH;
+      }
+    }
+  }
+  return returnValue;
+}
+
+
+/**
+ * @brief Appends the second machine basic block to the first one and
+ *        renumbers all basic blocks of the current function.
+ * @param Pre  Basic block which finally holds the instructions of both basic
+ *             blocks.
+ * @param Post The basic block which will finally removed.
+ */
+void PredicationPass::mergeBlocks(MachineBasicBlock &Pre, MachineBasicBlock &Post) {
+
+  MachineBasicBlock::iterator mbb_iter;
+  MachineBasicBlock::succ_iterator succ_iter;
+  MachineFunction* F = Pre.getParent();
+
+  // add all instructions of TBB to Pre basic block
+  mbb_iter = Post.begin();
+  while (mbb_iter != Post.end()) {
+    MachineInstr* MI = mbb_iter->removeFromParent();
+    Pre.push_back(MI);
+    mbb_iter = Post.begin();
+  }
+
+  // removing all (old) successors from pre
+  succ_iter = Pre.succ_begin();
+  while (succ_iter != Pre.succ_end()) {
+    Pre.removeSuccessor(*succ_iter);
+    succ_iter = Pre.succ_begin();
+  }
+  Pre.transferSuccessors(&Post);
+
+  // removing Post
+  Post.eraseFromParent();
+
+  F->RenumberBlocks(&Pre);
+
+}
+
+/**
+ * @brief Removes all conditional and unconditional branches of the given
+ *        machine basic block.
+ * @param MBB The machine basic block from which all branches will be removed.
+ */
+void PredicationPass::removeBranches(MachineBasicBlock &MBB) {
+  MachineBasicBlock::reverse_iterator mbb_iter;
+  std::list<MachineInstr*> branchesToRemove;
+  std::list<MachineInstr*>::iterator branch_iter;
+
+  // save all branches in list
+  for (mbb_iter = MBB.rbegin(); mbb_iter != MBB.rend(); ++mbb_iter) {
+    if (mbb_iter->getOpcode() == CBG::BCOND || mbb_iter->getOpcode() == CBG::BA) {
+      branchesToRemove.push_front(&(*mbb_iter));
+    }
+  }
+
+  // remove all branches from basic block
+  for (branch_iter = branchesToRemove.begin();
+       branch_iter != branchesToRemove.end();
+       ++branch_iter) {
+    (*branch_iter)->eraseFromParent();
+  }
+}
+
+/**
+ * @brief Analyzes whether the given register has already been saved in the
+ *        given list.
+ * @param rList List of registers which are represented by unsigned numbers.
+ * @param RegNo Register number of the register to be tested.
+ * @return True if the given register is part of the list, false otherwise.
+ */
+bool PredicatedRegPass::isPredRegInList(RegList &rList, unsigned RegNo) {
+  RegList::iterator reg_iter;
+  bool inList = false;
+  for (reg_iter = rList.begin(); reg_iter != rList.end(); ++reg_iter) {
+    if (*reg_iter == RegNo) {
+      inList = true;
+      break;
+    }
+  }
+
+  return inList;
+}
+
+/**
+ * @brief Analyzes the used predication registers of a given machine basic block.
+ * @param MBB The machine basic block to analyze.
+ * @return A set (i.e. a list) of used predication registers.
+ */
+PredicatedRegPass::RegList PredicatedRegPass::getUsedPredRegisters(MachineBasicBlock &MBB) {
+
+  RegList rList;
+  MachineBasicBlock::iterator mbb_iter;
+  unsigned OpCode;
+  unsigned RegNo;
+
+  for (mbb_iter = MBB.begin(); mbb_iter != MBB.end(); ++mbb_iter) {
+    OpCode = mbb_iter->getOpcode();
+    // add all used registers to list
+    if (OpCode == CBG::PREDREGSETCC || OpCode == CBG::PREDREGSET || OpCode == CBG::PREDREGCLEAR ||
+        OpCode == CBG::PREDREGSETCC_PREG) {
+      RegNo = mbb_iter->getOperand(0).getReg();
+      if (!isPredRegInList(rList, RegNo)) {
+        rList.push_back(RegNo);
+      }
+    }
+  }
+
+  return rList;
+}
+
+/**
+ * @brief Analyzes the used predication registers of two given machine basic blocks.
+ * @param TBB The first machine basic block to analyze.
+ * @param FBB The first machine basic block to analyze.
+ * @return A set (i.e. a list) of used predication registers.
+ */
+PredicatedRegPass::RegList PredicatedRegPass::getUsedPredRegisters(MachineBasicBlock &TBB, MachineBasicBlock &FBB) {
+
+  RegList rList;
+  MachineBasicBlock::iterator mbb_iter;
+  unsigned OpCode;
+  unsigned RegNo;
+
+  for (mbb_iter = TBB.begin(); mbb_iter != TBB.end(); ++mbb_iter) {
+    OpCode = mbb_iter->getOpcode();
+    // add all used registers to list
+    if (OpCode == CBG::PREDREGSETCC || OpCode == CBG::PREDREGSET || OpCode == CBG::PREDREGCLEAR ||
+        OpCode == CBG::PREDREGSETCC_PREG) {
+      RegNo = mbb_iter->getOperand(0).getReg();
+      if (!isPredRegInList(rList, RegNo)) {
+        rList.push_back(RegNo);
+      }
+    }
+  }
+
+  for (mbb_iter = FBB.begin(); mbb_iter != FBB.end(); ++mbb_iter) {
+    OpCode = mbb_iter->getOpcode();
+    // add all used registers to list
+    if (OpCode == CBG::PREDREGSETCC || OpCode == CBG::PREDREGSET || OpCode == CBG::PREDREGCLEAR ||
+        OpCode == CBG::PREDREGSETCC_PREG) {
+      RegNo = mbb_iter->getOperand(0).getReg();
+      if (!isPredRegInList(rList, RegNo)) {
+        rList.push_back(RegNo);
+      }
+    }
+  }
+
+  return rList;
+}
+
+/**
+ * @brief Gets a set of registers which are part of both given lists.
+ * @param rList1 First input set of registers.
+ * @param rList2 Second input set of registers.
+ * @return A set (i.e. a list) of registers representing a cut of rList1 and rList2.
+ */
+PredicatedRegPass::RegList PredicatedRegPass::cutPredRegLists(RegList &rList1, RegList &rList2) {
+  RegList rList = rList1;
+  RegList::iterator reglist_iter = rList.begin();
+
+  while(reglist_iter != rList.end()) {
+    if (!isPredRegInList(rList2, *reglist_iter)) {
+      rList.remove(*reglist_iter);
+      reglist_iter = rList.begin();
+      continue;
+    }
+    ++reglist_iter;
+  }
+
+  return rList;
+
+}
+
+/**
+ * @brief Gets a set of registers which unite registers of both given lists.
+ * @param rList1 First input set of registers.
+ * @param rList2 Second input set of registers.
+ * @return A set (i.e. a list) of registers representing a unite operation of rList1 and rList2.
+ */
+PredicatedRegPass::RegList PredicatedRegPass::unitePredRegLists(RegList &rList1, RegList &rList2) {
+  RegList rList = rList1;
+  RegList::iterator reglist_iter = rList2.begin();
+
+  while(reglist_iter != rList2.end()) {
+    if (!isPredRegInList(rList, *reglist_iter)) {
+      rList.push_back(*reglist_iter);
+    }
+    ++reglist_iter;
+  }
+
+  return rList;
+
+}
+
+/**
+ * @brief Register allocator for predication registers based on the
+ *        given machine basic block.
+ * @param MBB The machine basic block which is the basis for the register
+ *        allocator.
+ * @return The first predication register which is not used in MBB or (-1)
+ *         if there is no free register.
+ */
+unsigned PredicatedRegPass::getNextFreePredRegister(MachineBasicBlock &MBB) {
+
+  RegList rList = getUsedPredRegisters(MBB);
+  CBG::PREDRegsClass predRegs;
+  CBG::PREDRegsClass::iterator pregclass_iter;
+  unsigned nextFreePredRegister = static_cast<unsigned>(-1);
+
+  for (pregclass_iter = predRegs.begin(); pregclass_iter != predRegs.end(); ++pregclass_iter) {
+    if (!isPredRegInList(rList, *pregclass_iter)) {
+      nextFreePredRegister = *pregclass_iter;
+      break;
+    }
+  }
+
+  return nextFreePredRegister;
+
+}
+
+/**
+ * @brief Register allocator for predication registers based on the
+ *        given machine basic blocks.
+ * @param MBB First machine basic block which is the basis for the register
+ *        allocator.
+ * @param FBB Second machine basic block which is the basis for the register
+ *        allocator.
+ * @return The first predication register which is not used in MBB and FBB
+ *         or (-1) if there is no free register.
+ */
+unsigned PredicatedRegPass::getNextFreePredRegister(MachineBasicBlock &TBB, MachineBasicBlock &FBB) {
+
+  RegList rList = getUsedPredRegisters(TBB, FBB);
+
+  CBG::PREDRegsClass predRegs;
+  CBG::PREDRegsClass::iterator pregclass_iter;
+  unsigned nextFreePredRegister = static_cast<unsigned>(-1);
+
+  for (pregclass_iter = predRegs.begin(); pregclass_iter != predRegs.end(); ++pregclass_iter) {
+    if (!isPredRegInList(rList, *pregclass_iter)) {
+      nextFreePredRegister = *pregclass_iter;
+      break;
+    }
+  }
+
+  return nextFreePredRegister;
+
+}
+
+/**
+ * @brief Removes all predclear instructions before any predicated
+ *        block begin instruction from the given MBB.
+ * @param MBB The machine basic block to analyze.
+ * @return A List of all removed predicated registers.
+ */
+PredicatedRegPass::RegList PredicatedRegPass::removePredRegClears(MachineBasicBlock &MBB) {
+
+  RegList rList;
+
+  MachineBasicBlock::iterator mbb_iter = MBB.begin();
+  while (mbb_iter != MBB.end()) {
+    if (mbb_iter->getOpcode() == CBG::PREDREGCLEAR) {
+      rList.push_back(mbb_iter->getOperand(0).getReg());
+      mbb_iter->eraseFromParent();
+      mbb_iter = MBB.begin();
+      continue;
+    }
+    if (mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_T ||
+        mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_F) {
+      break;
+    }
+    ++mbb_iter;
+  }
+
+  return rList;
+
+}
+
+/**
+ * @brief Replaces all occurring predend instructions of the given basic block by
+ *        predbegin[preg][t/f].
+ * @param MBB The machine basic block which is the subject of change.
+ * @param PReg The predicate register which is source of the predbegin instruction.
+ * @param TF Sets the t/f flag of the predbegin instruction.
+ */
+void PredicatedBlocksRegPass::replacePredEnds(MachineBasicBlock &MBB, unsigned PReg, unsigned TF) {
+  MachineBasicBlock::iterator mbb_iter;
+  MachineBasicBlock::iterator pred_end;
+
+  DebugLoc dbg_loc = MBB.begin()->getDebugLoc();
+
+  for (mbb_iter = MBB.begin(); mbb_iter != MBB.end(); ) {
+    // replace a predend by predbegin[preg][tf] instruction
+    if (mbb_iter->getOpcode() == CBG::PREDBLOCKREG_END) {
+      pred_end = mbb_iter;
+      ++mbb_iter;
+      if (TF == 1) {
+        BuildMI(MBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_BEGIN_T))
+            .addReg(PReg);
+      } else {
+        BuildMI(MBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_BEGIN_F))
+            .addReg(PReg);
+      }
+      // remove predend instruction
+      pred_end->eraseFromParent();
+      // set mbb iter to begin of current MBB
+      mbb_iter = MBB.begin();
+      continue;
+    }
+    ++mbb_iter;
+  }
+
+}
+
+/**
+ * @brief Removes all redundant instructions terminating a predicated block
+ *        from the given MBB.
+ * @param MBB The machine basic block to analyze.
+ */
+void PredicatedBlocksRegPass::removePredEnds(MachineBasicBlock &MBB) {
+  MachineBasicBlock::iterator mbb_iter;
+  MachineBasicBlock::iterator pred_end = MBB.end();
+
+  for (mbb_iter = MBB.begin(); mbb_iter != MBB.end(); ) {
+    // pred_end is not set
+    if (pred_end == MBB.end()) {
+      // we have found a prendend or predbegin instruction
+      if (mbb_iter->getOpcode() == CBG::PREDBLOCKREG_END ||
+          mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_T ||
+          mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_F) {
+        // save that we have found one and continue
+        pred_end = mbb_iter;
+        ++mbb_iter;
+        continue;
+      }
+    } else {
+      // pred_end has been set
+      if (mbb_iter->getOpcode() == CBG::PREDBLOCKREG_END ||
+          mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_T ||
+          mbb_iter->getOpcode() == CBG::PREDBLOCKREG_BEGIN_F) {
+        // we have found the beginning of a predicated block, so
+        // we should remove any predecessing predend or predbegin
+        // instructions
+        pred_end->eraseFromParent();
+        pred_end = MBB.end();
+        mbb_iter = MBB.begin();
+        continue;
+      }
+    }
+    // if pred_end has been defined and we did not have any
+    // predend or predbegin block, we have to clear the pred_end
+    // instruction
+    pred_end = MBB.end();
+    ++mbb_iter;
+  }
+
+
+}
+
+/**
+ * @brief Analyzes the given MBB and returns true, if it contains
+ *        at least one instruction which sets the ICCs of the SPARC psr.
+ * @param MBB The machine basic block to test.
+ * @return False, if there is no defining instruction, true otherwise.
+ */
+bool PredicatedBlocksCCPass::definesICC(MachineBasicBlock &MBB) {
+  int define_counter = 0;
+  MachineBasicBlock::reverse_iterator mbb_iter;
+  const TargetRegisterInfo* registerInfo = TM.getRegisterInfo();
+
+  // check for ever instruction within current MBB
+  for (mbb_iter = MBB.rbegin(); mbb_iter != MBB.rend(); ++mbb_iter) {
+    // if the current instruction defines the ICC, increment counter
+    if (mbb_iter->definesRegister(CBG::ICC, registerInfo)) {
+      define_counter++;
+    }
+  }
+  if (define_counter > 0) {
+    return true;
+  } else {
+    return false;
+  }
+}
+
+/**
+ * @brief Tries to insert a predicated block by merging the predecessor of
+ *        TBB, FBB and their successor, depending on the branch type.
+ * @param TBB   Represents the "if-then" branch.
+ * @param FBB   Represents the "else" branch in the case of an IFELSEBRANCH or
+ *              the machine basic block logically following TBB in the case of
+ *              an IFBRANCH.
+ * @param btype Result of the getBranchType() method and may be either IFELSEBRANCH
+ *              or IFBRANCH.
+ * @see getBranchType()
+ * @return True if the predicated block could be inserted successfully, false if the
+ *         basic blocks have not been touched.
+ */
+bool PredicatedBlocksCCPass::insertPredicatedBlock(MachineBasicBlock &TBB,
+                                                   MachineBasicBlock &FBB,
+                                                   branchType btype) {
+
+  DebugLoc dbg_loc = TBB.begin()->getDebugLoc();
+  MachineBasicBlock* predecessor;
+  MachineBasicBlock* successor;
+  MachineBasicBlock::iterator mbb_iter;
+  int conditionCode;
+  bool Changed = false;
+
+
+
+  // in the case of an if-else branch, none of them may change the
+  // ICC register
+  if (btype == IFELSEBRANCH && !definesICC(TBB) && !definesICC(FBB)) {
+
+    // in the case of an if-then-else construction,
+    // we have to handle the following CFG:
+    // Pre -> FBB -> TBB -> [possible other MBBs] -> Post
+
+    // get predecessor (by definition, TBB has only one predecessor)
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // TBB has exactly one successor
+      successor = *(TBB.succ_begin());
+
+      // if the successor of TBB is also a layout successor
+      // we can remove branches from FBB and insert the
+      // PREDBLOCKCC_END instruction at the end
+      if (TBB.isLayoutSuccessor(successor)) {
+        removeBranches(FBB);
+        mbb_iter = FBB.end();
+      } else {
+        // otherwise, we have to insert the PREDBLOCKCC_END instruction
+        // before the unconditional branch
+        mbb_iter = FBB.end();
+        --mbb_iter;
+      }
+
+      // remove any branches from TBB and predecessor
+      // because they will be merged with FBB which would
+      // handle the final branch
+      removeBranches(TBB);
+      removeBranches(*predecessor);
+
+      // insert predicated block begin at begin of TBB with the given condition code
+      BuildMI(TBB, TBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKCC_BEGIN))
+        .addImm(conditionCode);
+
+      // insert predicated block begin at begin of FBB with the opposite condition code
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+      BuildMI(FBB, FBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKCC_BEGIN))
+        .addImm(conditionCode);
+
+      // insert predicated block end at end of FBB, resp. before the final unconditional
+      // branch
+      BuildMI(FBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKCC_END));
+
+      // merge predecessor with TBB and FBB
+      mergeBlocks(*predecessor, TBB);
+      mergeBlocks(*predecessor, FBB);
+
+      // if the successor has only one predecessor,
+      // we can merge the two blocks
+      if (successor->pred_size() == 1) {
+        mergeBlocks(*predecessor, *successor);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  // in the case of a single if-branch, TBB is not allowed to
+  // define the ICC
+  } else if (btype == IFBRANCH && !definesICC(TBB)) {
+
+    // in the case of an if-then-end construction,
+    // we have to handle the following CFG:
+    // Pre -> TBB -> [possible other MBBs] -> FBB
+
+    // get the only predecessor of TBB
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB (which is the opposite for TBB)
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // remove all branches from predecessor
+      removeBranches(*predecessor);
+
+      // depending whether FBB is a layout successor of
+      // TBB, we have to insert PREBLOCKCC_END at the
+      // end of TBB or straight before the unconditional
+      // branch
+      if (!TBB.isLayoutSuccessor(&FBB)) {
+        mbb_iter = TBB.end();
+        --mbb_iter;
+      } else {
+        removeBranches(TBB);
+        mbb_iter = TBB.end();
+      }
+
+      // get the opposite condition code for TBB
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+
+      // start predicated block for TBB
+      BuildMI(TBB, TBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKCC_BEGIN))
+        .addImm(conditionCode);
+      // end predicated block
+      BuildMI(TBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKCC_END));
+
+      // merge Pre with TBB
+      mergeBlocks(*predecessor, TBB);
+
+      // only merge FBB with rest if it is a layout successor and it only has
+      // one predecessor
+      if (predecessor->isLayoutSuccessor(&FBB) && FBB.pred_size() == 1) {
+        mergeBlocks(*predecessor, FBB);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+    }
+
+  }
+
+  return Changed;
+
+}
+
+/**
+ * @brief Checks for any two MBBs of the given machine function, whether they form an
+ *        if-then-else of if-then construction and insert a predicated block if possible.
+ * @param F The Machine function to analyze.
+ * @return True, if any predicated block has been inserted, false otherwise.
+ */
+bool PredicatedBlocksCCPass::runOnMachineFunction(MachineFunction &F) {
+  bool Changed = false;
+  MachineFunction::iterator f_outer_iter;
+  MachineFunction::iterator f_inner_iter;
+  BranchMBB_list branches;
+  BranchMBB_list::iterator branch_iter;
+  branchType btype;
+
+  // check for all basic blocks if they form any branches
+  for (f_outer_iter = F.begin(); f_outer_iter != F.end(); ++f_outer_iter) {
+    for (f_inner_iter = F.begin(); f_inner_iter != F.end(); ++f_inner_iter) {
+      btype = getBranchType(*f_inner_iter, *f_outer_iter);
+      if (btype != NOBRANCH) {
+        BranchMBB newBranch = {&(*f_inner_iter), &(*f_outer_iter), btype};
+        branches.push_back(newBranch);
+      }
+    }
+  }
+
+  for (branch_iter = branches.begin(); branch_iter != branches.end(); branch_iter++) {
+    Changed |= insertPredicatedBlock(*(branch_iter->TBB), *(branch_iter->FBB), branch_iter->btype);
+  }
+
+  return Changed;
+}
+
+/**
+ * @brief Creates a new predicated block pass based on the condition codes of the
+ *        status register.
+ * @param tm The target machine for the given pass.
+ * @return FunctionPass pointer to the just created pass.
+ */
+FunctionPass* llvm::createcbgPredBlockCCPass(TargetMachine &tm) {
+  return new PredicatedBlocksCCPass(tm);
+}
+
+/**
+ * @brief Tries to insert a predicated block by merging the predecessor of
+ *        TBB, FBB and their successor, depending on the branch type.
+ * @details TBB and FBB may already contain predicated blocks.
+ * @param TBB   Represents the "if-then" branch.
+ * @param FBB   Represents the "else" branch in the case of an IFELSEBRANCH or
+ *              the machine basic block logically following TBB in the case of
+ *              an IFBRANCH.
+ * @param btype Result of the getBranchType() method and may be either IFELSEBRANCH
+ *              or IFBRANCH.
+ * @see getBranchType()
+ * @return True if the predicated block could be inserted successfully, false if the
+ *         basic blocks have not been touched.
+ */
+bool PredicatedBlocksRegPass::insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype) {
+
+  DebugLoc dbg_loc = TBB.begin()->getDebugLoc();
+  RegList pregList;
+  RegList pregList2;
+  RegList::iterator preglist_iterator;
+  MachineBasicBlock* predecessor;
+  MachineBasicBlock* successor;
+  MachineBasicBlock::iterator mbb_iter;
+  int conditionCode;
+  unsigned nextPReg;
+  bool Changed = false;
+
+  if (btype == IFELSEBRANCH) {
+
+    // in the case of an if-then-else construction,
+    // we have to handle the following CFG:
+    // Pre -> FBB -> TBB -> [possible other MBBs] -> Post
+
+    // get predecessor (by definition, TBB has only one predecessor)
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // TBB has exactly one successor
+      successor = *(TBB.succ_begin());
+
+      // if the successor of TBB is also a layout successor
+      // we can remove branches from FBB and insert the
+      // PREDBLOCKCC_END instruction at the end
+      if (TBB.isLayoutSuccessor(successor)) {
+        removeBranches(FBB);
+        mbb_iter = FBB.end();
+      } else {
+        // otherwise, we have to insert the PREDBLOCKREG_END instruction
+        // before the unconditional branch
+        mbb_iter = FBB.end();
+        --mbb_iter;
+      }
+
+      // allocate the next free predication register
+      nextPReg = getNextFreePredRegister(TBB, FBB);
+
+      // remove any branches from TBB and predecessor
+      removeBranches(TBB);
+      removeBranches(*predecessor);
+
+      // remove any clear predication register from TBB and FBB
+      // and save the used registers in list
+      pregList = removePredRegClears(TBB);
+      pregList2 = removePredRegClears(FBB);
+
+      // clear all pregs before begin of TBB
+      pregList = unitePredRegLists(pregList, pregList2);
+
+      // clear the current predicate register
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+        .addReg(nextPReg, RegState::Define);
+
+      // add clear instructions for all used predicate registers of TBB and FBB at end of predecessor
+      for (preglist_iterator = pregList.begin(); preglist_iterator != pregList.end(); ++preglist_iterator) {
+        BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+          .addReg(*preglist_iterator, RegState::Define);
+      }
+
+      // set the current predication register based on the condition code
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGSETCC))
+        .addReg(nextPReg, RegState::Define).addImm(conditionCode);
+
+      // add begin predicated block instruction at begin of TBB
+      BuildMI(TBB, TBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_BEGIN_T))
+        .addReg(nextPReg);
+
+      // replace all occuring predends by predbegin[nextPreg][t]
+      replacePredEnds(TBB, nextPReg, 1);
+
+      // if the list of used pred registers of FBB contains any entries, we have to insert a block end instruction
+      if (pregList2.size() > 0) {
+        BuildMI(TBB, TBB.end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_END));
+      }
+
+      // add clear instructions for all used predicate registers of FBB at end of true basic block
+      for (preglist_iterator = pregList2.begin(); preglist_iterator != pregList2.end(); ++preglist_iterator) {
+        BuildMI(TBB, TBB.end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+          .addReg(*preglist_iterator, RegState::Define);
+      }
+
+      // add begin predicated block instruction at begin of FBB
+      BuildMI(FBB, FBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_BEGIN_F))
+        .addReg(nextPReg);
+
+      // replace all occuring predends by predbegin[nextPreg][t]
+      replacePredEnds(FBB, nextPReg, 0);
+
+      // add end predicated block instruction at end of FBB, resp. before the unconditional branch of FBB
+      BuildMI(FBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_END));
+
+      // merge predecessor with TBB and FBB
+      mergeBlocks(*predecessor, TBB);
+      mergeBlocks(*predecessor, FBB);
+
+      // if the successor has only one predecessor,
+      // we can merge the two blocks
+      if (successor->pred_size() == 1) {
+        mergeBlocks(*predecessor, *successor);
+      }
+
+      // remove redundant predends and from newly built MBB
+      removePredEnds(*predecessor);
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  } else if (btype == IFBRANCH) {
+
+    // in the case of an if-then-end construction,
+    // we have to handle the following CFG:
+    // Pre -> TBB -> [possible other MBBs] -> FBB
+
+    // get the only predecessor of TBB
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB (which is the opposite for TBB)
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // remove all branches from predecessor
+      removeBranches(*predecessor);
+
+      // depending whether FBB is a layout successor of
+      // TBB, we have to insert PREBLOCKREG_END at the
+      // end of TBB or straight before the unconditional
+      // branch
+      if (!TBB.isLayoutSuccessor(&FBB)) {
+        mbb_iter = TBB.end();
+        --mbb_iter;
+      } else {
+        removeBranches(TBB);
+        mbb_iter = TBB.end();
+      }
+
+      // allocate the next free predication register
+      nextPReg = getNextFreePredRegister(TBB);
+
+      // remove any clear predication register from TBB
+      // and get a set of all used predication registers of TBB
+      pregList = removePredRegClears(TBB);
+
+      // clear the current predicate register
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+        .addReg(nextPReg, RegState::Define);
+
+      // add clear instructions for all used predicate registers of TBB at end of predecessor
+      for (preglist_iterator = pregList.begin(); preglist_iterator != pregList.end(); ++preglist_iterator) {
+        BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+          .addReg(*preglist_iterator, RegState::Define);
+      }
+
+      // get the opposite condition code for TBB
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+
+      // set the current predication register based on the condition code
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGSETCC))
+        .addReg(nextPReg, RegState::Define).addImm(conditionCode);
+
+      // add start predicated block instruction at begin of TBB
+      BuildMI(TBB, TBB.begin(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_BEGIN_T))
+        .addReg(nextPReg);
+
+      // replace all predends within current MBB
+      replacePredEnds(TBB, nextPReg, 1);
+
+      // add end predicated block instruction at end of TBB
+      BuildMI(TBB, mbb_iter, dbg_loc, TM.getInstrInfo()->get(CBG::PREDBLOCKREG_END));
+
+      // merge predecessor with TBB
+      mergeBlocks(*predecessor, TBB);
+
+      // only merge FBB with rest if it is a layout successor and it only has
+      // one predecessor
+      if (predecessor->isLayoutSuccessor(&FBB) && FBB.pred_size() == 1) {
+        mergeBlocks(*predecessor, FBB);
+      }
+
+      // remove redundant end predicted block instruction from newly built MBB
+      removePredEnds(*predecessor);
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  }
+
+  return Changed;
+
+}
+
+/**
+ * @brief Checks for any two MBBs of the given machine function, whether they form an
+ *        if-then-else of if-then construction and insert a predicated block if possible.
+ * @param F The Machine function to analyze.
+ * @return True, if any predicated block has been inserted, false otherwise.
+ */
+bool PredicatedBlocksRegPass::runOnMachineFunction(MachineFunction &F) {
+  bool Changed = false;
+  bool RemovedBranches = true;
+  MachineFunction::iterator f_outer_iter;
+  MachineFunction::iterator f_inner_iter;
+  BranchMBB_list branches;
+  BranchMBB_list::iterator branch_iter;
+  branchType btype;
+//  unsigned passCounter = 1;
+
+  // as long as we can find any branches...
+  while (RemovedBranches) {
+//    std::cerr << "Pass Number: " << passCounter++ << std::endl;
+
+    // set the condition false such that the loop is terminated
+    // in the case we cannot find or remove any more branches
+    RemovedBranches = false;
+    // check for all basic blocks if the form any branches
+    for (f_outer_iter = F.begin(); f_outer_iter != F.end(); ++f_outer_iter) {
+      for (f_inner_iter = F.begin(); f_inner_iter != F.end(); ++f_inner_iter) {
+        btype = getBranchType(*f_inner_iter, *f_outer_iter);
+        if (btype != NOBRANCH) {
+          BranchMBB newBranch = {&(*f_inner_iter), &(*f_outer_iter), btype};
+          branches.push_back(newBranch);
+        }
+      }
+    }
+
+    for (branch_iter = branches.begin(); branch_iter != branches.end(); branch_iter++) {
+      if (insertPredicatedBlock(*(branch_iter->TBB), *(branch_iter->FBB), branch_iter->btype)) {
+        Changed = true;
+        RemovedBranches = true;
+      }
+    }
+
+    // we have to clear all possible branches for the next pass...
+    branches.clear();
+  }
+
+  return Changed;
+}
+
+/**
+ * @brief Creates a new predicated block pass based on predication registers.
+ * @param tm The target machine for the given pass.
+ * @return FunctionPass pointer to the just created pass.
+ */
+FunctionPass* llvm::createcbgPredBlockRegPass(TargetMachine &tm) {
+  return new PredicatedBlocksRegPass(tm);
+}
+
+/**
+ * @brief Merges the two given basic blocks and replaces all instructions
+ *        of MBB with predicated versions.
+ * @param Pre           The predecessor of MBB which will finally contain the instructions
+ *                      of Pre and MBB.
+ * @param MBB           The machine basic block which will be appended to Pre. Moreover,
+ *                      all its instructions are replaced with predicated versions.
+ * @param conditionCode Indicates on which condition code the predicated instruction
+ *                      will be executed.
+ */
+void PredicatedInstrCCPass::changeToPredicatedInstruction(MachineBasicBlock &Pre,
+                                                          MachineBasicBlock &MBB,
+                                                          unsigned conditionCode) {
+
+  MachineFunction* F = MBB.getParent();
+  MachineBasicBlock::iterator mbb_iter;
+  MachineBasicBlock::succ_iterator succ_iter;
+  DebugLoc dbg_loc = Pre.begin()->getDebugLoc();
+  unsigned OpCode;
+  unsigned numOps;
+  bool newPredicatedInstr;
+  MachineInstrBuilder mi;
+
+  for (mbb_iter = MBB.begin(); mbb_iter != MBB.end(); ++mbb_iter) {
+    newPredicatedInstr = true;
+    OpCode = mbb_iter->getOpcode();
+    numOps = mbb_iter->getNumOperands();
+
+    switch (OpCode) {
+      // ignore unknown Opcodes...
+      default:
+//        std::cerr << "Warning: cannot predicate the following instruction:"
+//          << std::endl;
+//        mbb_iter->dump();
+        newPredicatedInstr = false;
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(OpCode));
+        break;
+      // convert RET into predicated RET instructions
+      case CBG::RET:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RET_pcc));
+        break;
+      case CBG::RETL:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RETL_pcc));
+        break;
+      // convert integer LOADs into predicated integer LOADs
+      case CBG::LDSBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSB_pccri));
+        break;
+      case CBG::LDSBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSB_pccrr));
+        break;
+      case CBG::LDSHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSH_pccri));
+        break;
+      case CBG::LDSHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSH_pccrr));
+        break;
+      case CBG::LDUBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUB_pccri));
+        break;
+      case CBG::LDUBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUB_pccrr));
+        break;
+      case CBG::LDUHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUH_pccri));
+        break;
+      case CBG::LDUHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUH_pccrr));
+        break;
+      case CBG::LDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LD_pccri));
+        break;
+      case CBG::LDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LD_pccrr));
+        break;
+      // convert integer STOREs into predicated integer STOREs
+      case CBG::STBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STB_pccri));
+        break;
+      case CBG::STBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STB_pccrr));
+        break;
+      case CBG::STHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STH_pccri));
+        break;
+      case CBG::STHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STH_pccrr));
+        break;
+      case CBG::STri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ST_pccri));
+        break;
+      case CBG::STrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ST_pccrr));
+        break;
+      // convert SETHI into predicated instruction
+      case CBG::SETHIi:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SETHIi_pcc));
+      // convert logical instructions into predicated instructions
+      case CBG::ANDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::AND_pccri));
+        break;
+      case CBG::ANDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::AND_pccrr));
+        break;
+      case CBG::ANDNri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ANDN_pccri));
+        break;
+      case CBG::ANDNrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ANDN_pccrr));
+        break;
+      case CBG::ORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::OR_pccri));
+        break;
+      case CBG::ORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::OR_pccrr));
+        break;
+      case CBG::ORNri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ORN_pccri));
+        break;
+      case CBG::ORNrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ORN_pccrr));
+        break;
+      case CBG::XORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XOR_pccri));
+        break;
+      case CBG::XORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XOR_pccrr));
+        break;
+      case CBG::XNORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XNOR_pccri));
+        break;
+      case CBG::XNORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XNOR_pccrr));
+        break;
+      // convert SHIFT instructions into predicated instructions
+      case CBG::SLLri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SLL_pccri));
+        break;
+      case CBG::SLLrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SLL_pccrr));
+        break;
+      case CBG::SRLri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRL_pccri));
+        break;
+      case CBG::SRLrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRL_pccrr));
+        break;
+      case CBG::SRAri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRA_pccri));
+        break;
+      case CBG::SRArr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRA_pccrr));
+        break;
+      // convert ADD instructions into predicated instructions
+      case CBG::ADDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADD_pccri));
+        break;
+      case CBG::ADDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADD_pccrr));
+        break;
+      case CBG::ADDXri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADDX_pccri));
+        break;
+      case CBG::ADDXrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADDX_pccrr));
+        break;
+      // convert LEA instructions into predicated instructions
+      case CBG::LEA_ADDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LEA_ADD_pccri));
+        break;
+      // convert SUB instructions into predicated instructions
+      case CBG::SUBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUB_pccri));
+        break;
+      case CBG::SUBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUB_pccrr));
+        break;
+      case CBG::SUBXri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBX_pccri));
+        break;
+      case CBG::SUBXrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBX_pccrr));
+        break;
+      // convert MUL instructions into predicated instructions
+      case CBG::UMULri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UMUL_pccri));
+        break;
+      case CBG::UMULrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UMUL_pccrr));
+        break;
+      case CBG::SMULri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SMUL_pccri));
+        break;
+      case CBG::SMULrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SMUL_pccrr));
+        break;
+      // convert DIV instructions into predicated instructions
+      case CBG::UDIVri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UDIV_pccri));
+        break;
+      case CBG::UDIVrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UDIV_pccrr));
+        break;
+      case CBG::SDIVri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SDIV_pccri));
+        break;
+      case CBG::SDIVrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SDIV_pccrr));
+        break;
+      // convert save and restore instructions into predicated instructions
+      case CBG::SAVEri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SAVE_pccri));
+        break;
+      case CBG::SAVErr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SAVE_pccrr));
+        break;
+      case CBG::RESTOREri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RESTORE_pccri));
+        break;
+      case CBG::RESTORErr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RESTORE_pccrr));
+        break;
+      // convert RDY instruction into predicated instruction
+      case CBG::RDY:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RDY_pcc));
+        break;
+    }
+
+    // add all operands
+    for (unsigned idx = 0; idx < numOps; ++idx) {
+      mi.addOperand(mbb_iter->getOperand(idx));
+    }
+
+    // add condition code to new inserted instructions
+    if (newPredicatedInstr) {
+      mi.addImm(conditionCode);
+    }
+
+  }
+
+  // removing all (old) successors from pre
+  succ_iter = Pre.succ_begin();
+  while (succ_iter != Pre.succ_end()) {
+    Pre.removeSuccessor(*succ_iter);
+    succ_iter = Pre.succ_begin();
+  }
+
+  Pre.transferSuccessors(&MBB);
+
+  // removing MBB
+  MBB.eraseFromParent();
+
+  F->RenumberBlocks(&Pre);
+
+}
+
+
+/**
+ * @brief Tries to insert a block with fully predicated instructions by merging
+ *        the predecessor of TBB, FBB and their successor, depending on the
+ *        branch type.
+ * @param TBB   Represents the "if-then" branch.
+ * @param FBB   Represents the "else" branch in the case of an IFELSEBRANCH or
+ *              the machine basic block logically following TBB in the case of
+ *              an IFBRANCH.
+ * @param btype Result of the getBranchType() method and may be either IFELSEBRANCH
+ *              or IFBRANCH.
+ * @see getBranchType()
+ * @return True if the predicated block could be inserted successfully, false if the
+ *         basic blocks have not been touched.
+ */
+bool PredicatedInstrCCPass::insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype) {
+
+  MachineBasicBlock* predecessor;
+  MachineBasicBlock* successor;
+  int conditionCode;
+  bool Changed = false;
+
+  // in the case of an if-else branch, none of them may change the
+  // ICC register
+  if (btype == IFELSEBRANCH && !definesICC(TBB) && !definesICC(FBB)) {
+
+    // in the case of an if-then-else construction,
+    // we have to handle the following CFG:
+    // Pre -> FBB -> TBB -> [possible other MBBs] -> Post
+
+    // get predecessor (by definition, TBB has only one predecessor)
+    predecessor = *(TBB.pred_begin());
+
+    // save condition code for TBB
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // TBB has exactly one successor
+      successor = *(TBB.succ_begin());
+
+      // if the successor of TBB is also a layout successor
+      // we can remove branches from FBB
+      if (TBB.isLayoutSuccessor(successor)) {
+        removeBranches(FBB);
+      }
+
+      // remove any branches from TBB and predecessor
+      removeBranches(TBB);
+      removeBranches(*predecessor);
+
+      // let all instructions of TBB be predicated, based on the
+      // given condition code
+      changeToPredicatedInstruction(*predecessor, TBB, conditionCode);
+
+      // get the opposite condition code for FBB
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+      // let all instructions of FBB be predicated, based on the
+      // given condition code
+      changeToPredicatedInstruction(*predecessor, FBB, conditionCode);
+
+      // if the successor has only one predecessor,
+      // we can merge the two blocks
+      if (successor->pred_size() == 1) {
+        mergeBlocks(*predecessor, *successor);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  // in the case of a single if-branch, TBB is not allowed to
+  // define the ICC
+  } else if (btype == IFBRANCH && !definesICC(TBB)) {
+
+    // in the case of an if-then-end construction,
+    // we have to handle the following CFG:
+    // Pre -> TBB -> [possible other MBBs] -> FBB
+
+    // get the only predecessor of TBB
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB (which is the opposite for TBB)
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // remove any branches from predecessor
+      removeBranches(*predecessor);
+
+      // remove branches from TBB if FBB is layout successor
+      if (TBB.isLayoutSuccessor(&FBB)) {
+        removeBranches(TBB);
+      }
+
+      // get the opposite condition code for TBB
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+
+      // let TBB be predicated based on the given condition code
+      changeToPredicatedInstruction(*predecessor, TBB, conditionCode);
+
+      // only merge FBB with rest if it is a layout successor and it only has
+      // one predecessor
+      if (predecessor->isLayoutSuccessor(&FBB) && FBB.pred_size() == 1) {
+        mergeBlocks(*predecessor, FBB);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  }
+
+  return Changed;
+
+}
+
+/**
+ * @brief Creates a new predicated instruction pass based on the condition code
+ *        of the status register.
+ * @param tm The target machine for the given pass.
+ * @return FunctionPass pointer to the just created pass.
+ */
+FunctionPass* llvm::createcbgPredInstrCCPass(TargetMachine &tm) {
+  return new PredicatedInstrCCPass(tm);
+}
+
+/**
+ * @brief Merges the two given basic blocks and replaces all instructions
+ *        of MBB with predicated versions.
+ * @param Pre  The predecessor of MBB which will finally contain the instructions
+ *             of Pre and MBB.
+ * @param MBB  The machine basic block which will be appended to Pre. Moreover,
+ *             all its instructions are replaced with predicated versions.
+ * @param Preg The predication register on which the predication is based.
+ * @param TF   Indicates whether the instruction shall be executed if the
+ *             predication register is set (true) or cleared (false).
+ */
+void PredicatedInstrRegPass::changeToPredicatedInstruction(MachineBasicBlock &Pre,
+                                                          MachineBasicBlock &MBB,
+                                                          unsigned Preg,
+                                                          unsigned TF) {
+
+  MachineFunction* F = MBB.getParent();
+  MachineBasicBlock::iterator mbb_iter;
+  MachineBasicBlock::succ_iterator succ_iter;
+  DebugLoc dbg_loc = Pre.begin()->getDebugLoc();
+  unsigned OpCode;
+  unsigned numOps;
+  bool newPredicatedInstr;
+  MachineInstrBuilder mi;
+
+  for (mbb_iter = MBB.begin(); mbb_iter != MBB.end(); ++mbb_iter) {
+    newPredicatedInstr = true;
+    OpCode = mbb_iter->getOpcode();
+    numOps = mbb_iter->getNumOperands();
+
+    switch (OpCode) {
+      // ignore unknown Opcodes...
+      default:
+//        std::cerr << "Warning: cannot predicate the following instruction:"
+//          << std::endl;
+//        mbb_iter->dump();
+        newPredicatedInstr = false;
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(OpCode));
+        break;
+      // convert RET into predicated RET instructions
+      case CBG::RET:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RET_preg));
+        break;
+      case CBG::RETL:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RETL_preg));
+        break;
+      // convert integer LOADs into predicated integer LOADs
+      case CBG::LDSBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSB_pregri));
+        break;
+      case CBG::LDSBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSB_pregrr));
+        break;
+      case CBG::LDSHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSH_pregri));
+        break;
+      case CBG::LDSHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDSH_pregrr));
+        break;
+      case CBG::LDUBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUB_pregri));
+        break;
+      case CBG::LDUBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUB_pregrr));
+        break;
+      case CBG::LDUHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUH_pregri));
+        break;
+      case CBG::LDUHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LDUH_pregrr));
+        break;
+      case CBG::LDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LD_pregri));
+        break;
+      case CBG::LDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LD_pregrr));
+        break;
+      // convert integer STOREs into predicated integer STOREs
+      case CBG::STBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STB_pregri));
+        break;
+      case CBG::STBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STB_pregrr));
+        break;
+      case CBG::STHri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STH_pregri));
+        break;
+      case CBG::STHrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::STH_pregrr));
+        break;
+      case CBG::STri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ST_pregri));
+        break;
+      case CBG::STrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ST_pregrr));
+        break;
+      // convert SETHI into predicated instruction
+      case CBG::SETHIi:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SETHIi_preg));
+      // convert logical instructions into predicated instructions
+      case CBG::ANDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::AND_pregri));
+        break;
+      case CBG::ANDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::AND_pregrr));
+        break;
+      case CBG::ANDNri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ANDN_pregri));
+        break;
+      case CBG::ANDNrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ANDN_pregrr));
+        break;
+      case CBG::ORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::OR_pregri));
+        break;
+      case CBG::ORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::OR_pregrr));
+        break;
+      case CBG::ORNri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ORN_pregri));
+        break;
+      case CBG::ORNrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ORN_pregrr));
+        break;
+      case CBG::XORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XOR_pregri));
+        break;
+      case CBG::XORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XOR_pregrr));
+        break;
+      case CBG::XNORri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XNOR_pregri));
+        break;
+      case CBG::XNORrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::XNOR_pregrr));
+        break;
+      // convert SHIFT instructions into predicated instructions
+      case CBG::SLLri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SLL_pregri));
+        break;
+      case CBG::SLLrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SLL_pregrr));
+        break;
+      case CBG::SRLri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRL_pregri));
+        break;
+      case CBG::SRLrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRL_pregrr));
+        break;
+      case CBG::SRAri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRA_pregri));
+        break;
+      case CBG::SRArr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SRA_pregrr));
+        break;
+      // convert ADD instructions into predicated instructions
+      case CBG::ADDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADD_pregri));
+        break;
+      case CBG::ADDrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADD_pregrr));
+        break;
+      case CBG::ADDXri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADDX_pregri));
+        break;
+      case CBG::ADDXrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::ADDX_pregrr));
+        break;
+      // convert LEA instructions into predicated instructions
+      case CBG::LEA_ADDri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::LEA_ADD_pregri));
+        break;
+      // convert SUB instructions into predicated instructions
+      case CBG::SUBri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUB_pregri));
+        break;
+      case CBG::SUBrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUB_pregrr));
+        break;
+      case CBG::SUBXri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBX_pregri));
+        break;
+      case CBG::SUBXrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBX_pregrr));
+        break;
+      case CBG::SUBCCri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBCC_pregri));
+        break;
+      case CBG::SUBCCrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SUBCC_pregrr));
+        break;
+      // convert MUL instructions into predicated instructions
+      case CBG::UMULri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UMUL_pregri));
+        break;
+      case CBG::UMULrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UMUL_pregrr));
+        break;
+      case CBG::SMULri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SMUL_pregri));
+        break;
+      case CBG::SMULrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SMUL_pregrr));
+        break;
+      // convert DIV instructions into predicated instructions
+      case CBG::UDIVri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UDIV_pregri));
+        break;
+      case CBG::UDIVrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::UDIV_pregrr));
+        break;
+      case CBG::SDIVri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SDIV_pregri));
+        break;
+      case CBG::SDIVrr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SDIV_pregrr));
+        break;
+      // convert save and restore instructions into predicated instructions
+      case CBG::SAVEri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SAVE_pregri));
+        break;
+      case CBG::SAVErr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::SAVE_pregrr));
+        break;
+      case CBG::RESTOREri:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RESTORE_pregri));
+        break;
+      case CBG::RESTORErr:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RESTORE_pregrr));
+        break;
+      // convert RDY instruction into predicated instruction
+      case CBG::RDY:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::RDY_preg));
+        break;
+      case CBG::PREDREGSETCC:
+        mi = BuildMI(Pre, Pre.end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGSETCC_PREG));
+        break;
+    }
+
+    // add all operands
+    for (unsigned idx = 0; idx < numOps; ++idx) {
+      mi.addOperand(mbb_iter->getOperand(idx));
+    }
+
+    // add condition code to new inserted instructions
+    if (newPredicatedInstr) {
+      mi.addReg(Preg).addImm(TF);
+    }
+
+  }
+
+  // removing all (old) successors from pre
+  succ_iter = Pre.succ_begin();
+  while (succ_iter != Pre.succ_end()) {
+    Pre.removeSuccessor(*succ_iter);
+    succ_iter = Pre.succ_begin();
+  }
+
+  Pre.transferSuccessors(&MBB);
+
+  // removing MBB
+  MBB.eraseFromParent();
+
+  F->RenumberBlocks(&Pre);
+
+}
+
+/**
+ * @brief Tries to insert a block with fully predicated instructions by merging
+ *        the predecessor of TBB, FBB and their successor, depending on the
+ *        branch type.
+ * @details TBB and FBB may already contain predicated blocks.
+ * @param TBB   Represents the "if-then" branch.
+ * @param FBB   Represents the "else" branch in the case of an IFELSEBRANCH or
+ *              the machine basic block logically following TBB in the case of
+ *              an IFBRANCH.
+ * @param btype Result of the getBranchType() method and may be either IFELSEBRANCH
+ *              or IFBRANCH.
+ * @see getBranchType()
+ * @return True if the predicated block could be inserted successfully, false if the
+ *         basic blocks have not been touched.
+ */
+bool PredicatedInstrRegPass::insertPredicatedBlock(MachineBasicBlock &TBB, MachineBasicBlock &FBB, branchType btype) {
+
+  DebugLoc dbg_loc = TBB.begin()->getDebugLoc();
+  MachineBasicBlock* predecessor;
+  MachineBasicBlock* successor;
+  int conditionCode;
+  unsigned nextPReg;
+  bool Changed = false;
+
+  if (btype == IFELSEBRANCH) {
+
+    // in the case of an if-then-else construction,
+    // we have to handle the following CFG:
+    // Pre -> FBB -> TBB -> [possible other MBBs] -> Post
+
+    // get predecessor (by definition, TBB has only one predecessor)
+    predecessor = *(TBB.pred_begin());
+
+    // save condition code for TBB
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // TBB has exactly one successor
+      successor = *(TBB.succ_begin());
+
+      // if the successor of TBB is also a layout successor
+      // we can remove branches from FBB
+      if (TBB.isLayoutSuccessor(successor)) {
+        removeBranches(FBB);
+      }
+
+      // allocate the next free predication register
+      nextPReg = getNextFreePredRegister(TBB, FBB);
+
+      // remove any branches from TBB and predecessor
+      removeBranches(TBB);
+      removeBranches(*predecessor);
+
+      // clear currently used predicate register
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+        .addReg(nextPReg, RegState::Define);
+
+      // set the current predication register based on the condition code
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGSETCC))
+        .addReg(nextPReg, RegState::Define).addImm(conditionCode);
+
+      // merge predecessor with TBB
+      changeToPredicatedInstruction(*predecessor, TBB, nextPReg, 1);
+
+      // merge predecessor with FBB
+      changeToPredicatedInstruction(*predecessor, FBB, nextPReg, 0);
+
+      // if the successor has only one predecessor,
+      // we can merge the two blocks
+      if (successor->pred_size() == 1) {
+        mergeBlocks(*predecessor, *successor);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  } else if (btype == IFBRANCH) {
+
+    // in the case of an if-then-end construction,
+    // we have to handle the following CFG:
+    // Pre -> TBB -> [possible other MBBs] -> FBB
+
+    // get the only predecessor of TBB
+    predecessor = *(TBB.pred_begin());
+
+    // save the condition code for TBB (which is the opposite for TBB)
+    conditionCode = getConditionCode(*predecessor);
+
+    // if we could not find any conditional branch, do nothing
+    if (conditionCode >= 0) {
+
+      // remove all branches from predecessor
+      removeBranches(*predecessor);
+
+      // remove branches from TBB if FBB is layout successor
+      if (TBB.isLayoutSuccessor(&FBB)) {
+        removeBranches(TBB);
+      }
+
+      // allocate the next free predication register
+      nextPReg = getNextFreePredRegister(TBB);
+
+      // get the opposite condition code for TBB
+      conditionCode = CBG::getOppositeBranchCondition(static_cast<CBGCC::CondCodes>(conditionCode));
+
+      // clear currently used predicate register
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGCLEAR))
+        .addReg(nextPReg, RegState::Define);
+
+      // set the current predication register based on the condition code
+      BuildMI(*predecessor, predecessor->end(), dbg_loc, TM.getInstrInfo()->get(CBG::PREDREGSETCC))
+        .addReg(nextPReg, RegState::Define).addImm(conditionCode);
+
+      // merge predecessor with TBB
+      changeToPredicatedInstruction(*predecessor, TBB, nextPReg, 1);
+
+      // only merge FBB with rest if it is a layout successor and it only has
+      // one predecessor
+      if (predecessor->isLayoutSuccessor(&FBB) && FBB.pred_size() == 1) {
+        mergeBlocks(*predecessor, FBB);
+      }
+
+      // save that we have changed the structure of the function
+      Changed = true;
+
+    }
+
+  }
+
+  return Changed;
+
+}
+
+/**
+ * @brief Checks for any two MBBs of the given machine function, whether they form an
+ *        if-then-else of if-then construction and insert a predicated block if possible.
+ * @param F The Machine function to analyze.
+ * @return True, if any predicated block has been inserted, false otherwise.
+ */
+bool PredicatedInstrRegPass::runOnMachineFunction(MachineFunction &F) {
+  bool Changed = false;
+  bool RemovedBranches = true;
+  MachineFunction::iterator f_outer_iter;
+  MachineFunction::iterator f_inner_iter;
+  BranchMBB_list branches;
+  BranchMBB_list::iterator branch_iter;
+  branchType btype;
+//  unsigned passCounter = 1;
+
+  // as long as we can find any branches...
+  while (RemovedBranches) {
+//    std::cerr << "Pass Number: " << passCounter++ << std::endl;
+    // set the condition false such that the loop is terminated
+    // in the case we cannot find or remove any more branches
+    RemovedBranches = false;
+    // check for all basic blocks if the form any branches
+    for (f_outer_iter = F.begin(); f_outer_iter != F.end(); ++f_outer_iter) {
+      for (f_inner_iter = F.begin(); f_inner_iter != F.end(); ++f_inner_iter) {
+        btype = getBranchType(*f_inner_iter, *f_outer_iter);
+        if (btype != NOBRANCH) {
+          BranchMBB newBranch = {&(*f_inner_iter), &(*f_outer_iter), btype};
+          branches.push_back(newBranch);
+        }
+      }
+    }
+
+    for (branch_iter = branches.begin(); branch_iter != branches.end(); branch_iter++) {
+      if (insertPredicatedBlock(*(branch_iter->TBB), *(branch_iter->FBB), branch_iter->btype)) {
+        Changed = true;
+        RemovedBranches = true;
+      }
+    }
+    // we have to clear all possible branches for the next pass...
+    branches.clear();
+  }
+  return Changed;
+}
+
+/**
+ * @brief Creates a new predicated instruction pass based on predication
+ *        registers.
+ * @param tm The target machine for the given pass.
+ * @return FunctionPass pointer to the just created pass.
+ */
+FunctionPass* llvm::createcbgPredInstrRegPass(TargetMachine &tm) {
+  return new PredicatedInstrRegPass(tm);
+}
diff --git a/lib/Target/cbg/cbgRegisterInfo.cpp b/lib/Target/cbg/cbgRegisterInfo.cpp
new file mode 100644
index 0000000..08f56ad
--- /dev/null
+++ b/lib/Target/cbg/cbgRegisterInfo.cpp
@@ -0,0 +1,134 @@
+//===- cbgRegisterInfo.cpp - CBG Register Information -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the CBG implementation of the TargetRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbg.h"
+#include "cbgRegisterInfo.h"
+#include "cbgSubtarget.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineFunction.h"
+#include "llvm/CodeGen/MachineFrameInfo.h"
+#include "llvm/CodeGen/MachineLocation.h"
+#include "llvm/Support/ErrorHandling.h"
+#include "llvm/Target/TargetInstrInfo.h"
+#include "llvm/Type.h"
+#include "llvm/ADT/BitVector.h"
+#include "llvm/ADT/STLExtras.h"
+using namespace llvm;
+
+cbgRegisterInfo::cbgRegisterInfo(cbgSubtarget &st,
+                                     const TargetInstrInfo &tii)
+  : cbgGenRegisterInfo(CBG::ADJCALLSTACKDOWN, CBG::ADJCALLSTACKUP),
+    Subtarget(st), TII(tii) {
+}
+
+const unsigned* cbgRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF)
+                                                                         const {
+  static const unsigned CalleeSavedRegs[] = { 0 };
+  return CalleeSavedRegs;
+}
+
+BitVector cbgRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
+  BitVector Reserved(getNumRegs());
+  Reserved.set(CBG::G2);
+  Reserved.set(CBG::G3);
+  Reserved.set(CBG::G4);
+  Reserved.set(CBG::O6);
+  Reserved.set(CBG::I6);
+  Reserved.set(CBG::I7);
+  Reserved.set(CBG::G0);
+  Reserved.set(CBG::G5);
+  Reserved.set(CBG::G6);
+  Reserved.set(CBG::G7);
+  return Reserved;
+}
+
+void cbgRegisterInfo::
+eliminateCallFramePseudoInstr(MachineFunction &MF, MachineBasicBlock &MBB,
+                              MachineBasicBlock::iterator I) const {
+  MachineInstr &MI = *I;
+  DebugLoc dl = MI.getDebugLoc();
+  int Size = MI.getOperand(0).getImm();
+  if (MI.getOpcode() == CBG::ADJCALLSTACKDOWN)
+    Size = -Size;
+  if (Size)
+    BuildMI(MBB, I, dl, TII.get(CBG::ADDri), CBG::O6).addReg(CBG::O6).addImm(Size);
+  MBB.erase(I);
+}
+
+void
+cbgRegisterInfo::eliminateFrameIndex(MachineBasicBlock::iterator II,
+                                       int SPAdj, RegScavenger *RS) const {
+  assert(SPAdj == 0 && "Unexpected");
+
+  unsigned i = 0;
+  MachineInstr &MI = *II;
+  DebugLoc dl = MI.getDebugLoc();
+  while (!MI.getOperand(i).isFI()) {
+    ++i;
+    assert(i < MI.getNumOperands() && "Instr doesn't have FrameIndex operand!");
+  }
+
+  int FrameIndex = MI.getOperand(i).getIndex();
+
+  // Addressable stack objects are accessed using neg. offsets from %fp
+  MachineFunction &MF = *MI.getParent()->getParent();
+  int Offset = MF.getFrameInfo()->getObjectOffset(FrameIndex) +
+               MI.getOperand(i+1).getImm();
+
+  // Replace frame index with a frame pointer reference.
+  if (Offset >= -4096 && Offset <= 4095) {
+    // If the offset is small enough to fit in the immediate field, directly
+    // encode it.
+    MI.getOperand(i).ChangeToRegister(CBG::I6, false);
+    MI.getOperand(i+1).ChangeToImmediate(Offset);
+  } else {
+    // Otherwise, emit a G1 = SETHI %hi(offset).  FIXME: it would be better to 
+    // scavenge a register here instead of reserving G1 all of the time.
+    unsigned OffHi = (unsigned)Offset >> 10U;
+    BuildMI(*MI.getParent(), II, dl, TII.get(CBG::SETHIi), CBG::G1).addImm(OffHi);
+    // Emit G1 = G1 + I6
+    BuildMI(*MI.getParent(), II, dl, TII.get(CBG::ADDrr), CBG::G1).addReg(CBG::G1)
+      .addReg(CBG::I6);
+    // Insert: G1+%lo(offset) into the user.
+    MI.getOperand(i).ChangeToRegister(CBG::G1, false);
+    MI.getOperand(i+1).ChangeToImmediate(Offset & ((1 << 10)-1));
+  }
+}
+
+void cbgRegisterInfo::
+processFunctionBeforeFrameFinalized(MachineFunction &MF) const {}
+
+unsigned cbgRegisterInfo::getRARegister() const {
+  return CBG::I7;
+}
+
+unsigned cbgRegisterInfo::getFrameRegister(const MachineFunction &MF) const {
+  return CBG::I6;
+}
+
+unsigned cbgRegisterInfo::getEHExceptionRegister() const {
+  llvm_unreachable("What is the exception register");
+  return 0;
+}
+
+unsigned cbgRegisterInfo::getEHHandlerRegister() const {
+  llvm_unreachable("What is the exception handler register");
+  return 0;
+}
+
+int cbgRegisterInfo::getDwarfRegNum(unsigned RegNum, bool isEH) const {
+  return cbgRegisterInfo::getDwarfRegNumFull(RegNum, 0);
+}
+
+#include "cbgGenRegisterInfo.inc"
+
diff --git a/lib/Target/cbg/cbgRegisterInfo.h b/lib/Target/cbg/cbgRegisterInfo.h
new file mode 100644
index 0000000..de0b51e
--- /dev/null
+++ b/lib/Target/cbg/cbgRegisterInfo.h
@@ -0,0 +1,59 @@
+//===- cbgRegisterInfo.h - cbg Register Information Impl ----*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file contains the cbg implementation of the TargetRegisterInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBGREGISTERINFO_H
+#define CBGREGISTERINFO_H
+
+#include "llvm/Target/TargetRegisterInfo.h"
+#include "cbgGenRegisterInfo.h.inc"
+
+namespace llvm {
+
+class cbgSubtarget;
+class TargetInstrInfo;
+class Type;
+
+struct cbgRegisterInfo : public cbgGenRegisterInfo {
+  cbgSubtarget &Subtarget;
+  const TargetInstrInfo &TII;
+
+  cbgRegisterInfo(cbgSubtarget &st, const TargetInstrInfo &tii);
+
+  /// Code Generation virtual methods...
+  const unsigned *getCalleeSavedRegs(const MachineFunction *MF = 0) const;
+
+  BitVector getReservedRegs(const MachineFunction &MF) const;
+
+  void eliminateCallFramePseudoInstr(MachineFunction &MF,
+                                     MachineBasicBlock &MBB,
+                                     MachineBasicBlock::iterator I) const;
+
+  void eliminateFrameIndex(MachineBasicBlock::iterator II,
+                           int SPAdj, RegScavenger *RS = NULL) const;
+
+  void processFunctionBeforeFrameFinalized(MachineFunction &MF) const;
+
+  // Debug information queries.
+  unsigned getRARegister() const;
+  unsigned getFrameRegister(const MachineFunction &MF) const;
+
+  // Exception handling queries.
+  unsigned getEHExceptionRegister() const;
+  unsigned getEHHandlerRegister() const;
+
+  int getDwarfRegNum(unsigned RegNum, bool isEH) const;
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/lib/Target/cbg/cbgRegisterInfo.td b/lib/Target/cbg/cbgRegisterInfo.td
new file mode 100644
index 0000000..0cbcf89
--- /dev/null
+++ b/lib/Target/cbg/cbgRegisterInfo.td
@@ -0,0 +1,205 @@
+//===- cbgRegisterInfo.td - cbg Register defs ----------*- tablegen -*-===//
+// 
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+// 
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+//  Declarations that describe the Sparc register file 
+//===----------------------------------------------------------------------===//
+
+class cbgReg<string n> : Register<n> {
+  field bits<5> Num;
+  let Namespace = "CBG";
+}
+
+class cbgCtrlReg<string n>: Register<n> {
+  let Namespace = "CBG";
+}
+
+let Namespace = "CBG" in {
+def sub_even : SubRegIndex;
+def sub_odd  : SubRegIndex;
+}
+
+// Registers are identified with 5-bit ID numbers.
+// Ri - 32-bit integer registers
+class Ri<bits<5> num, string n> : cbgReg<n> {
+  let Num = num;
+}
+// Rf - 32-bit floating-point registers
+class Rf<bits<5> num, string n> : cbgReg<n> {
+  let Num = num;
+}
+// Rd - Slots in the FP register file for 64-bit floating-point values.
+class Rd<bits<5> num, string n, list<Register> subregs> : cbgReg<n> {
+  let Num = num;
+  let SubRegs = subregs;
+  let SubRegIndices = [sub_even, sub_odd];
+}
+
+// Control Registers
+def ICC : cbgCtrlReg<"ICC">;
+def FCC : cbgCtrlReg<"FCC">;
+
+// pseudo predicate register
+def PPRED : cbgCtrlReg<"PPRED">;
+def P0  : cbgCtrlReg<"P0">;
+def P1  : cbgCtrlReg<"P1">;
+def P2  : cbgCtrlReg<"P2">;
+def P3  : cbgCtrlReg<"P3">;
+def P4  : cbgCtrlReg<"P4">;
+def P5  : cbgCtrlReg<"P5">;
+def P6  : cbgCtrlReg<"P6">;
+def P7  : cbgCtrlReg<"P7">;
+def P8  : cbgCtrlReg<"P8">;
+def P9  : cbgCtrlReg<"P9">;
+def P10 : cbgCtrlReg<"P10">;
+def P11 : cbgCtrlReg<"P11">;
+def P12 : cbgCtrlReg<"P12">;
+def P13 : cbgCtrlReg<"P13">;
+def P14 : cbgCtrlReg<"P14">;
+def P15 : cbgCtrlReg<"P15">;
+
+// Y register
+def Y : cbgCtrlReg<"Y">;
+
+// HWloop registers
+def HWLOOP1 : cbgCtrlReg<"LOOPS">;
+def HWLOOP2 : cbgCtrlReg<"LOOPE">;
+def HWLOOP3 : cbgCtrlReg<"LOOPB">;
+
+// Integer registers
+def G0 : Ri< 0, "G0">, DwarfRegNum<[0]>;
+def G1 : Ri< 1, "G1">, DwarfRegNum<[1]>;
+def G2 : Ri< 2, "G2">, DwarfRegNum<[2]>; 
+def G3 : Ri< 3, "G3">, DwarfRegNum<[3]>;
+def G4 : Ri< 4, "G4">, DwarfRegNum<[4]>;
+def G5 : Ri< 5, "G5">, DwarfRegNum<[5]>; 
+def G6 : Ri< 6, "G6">, DwarfRegNum<[6]>;
+def G7 : Ri< 7, "G7">, DwarfRegNum<[7]>;
+def O0 : Ri< 8, "O0">, DwarfRegNum<[8]>;
+def O1 : Ri< 9, "O1">, DwarfRegNum<[9]>;
+def O2 : Ri<10, "O2">, DwarfRegNum<[10]>; 
+def O3 : Ri<11, "O3">, DwarfRegNum<[11]>;
+def O4 : Ri<12, "O4">, DwarfRegNum<[12]>;
+def O5 : Ri<13, "O5">, DwarfRegNum<[13]>; 
+def O6 : Ri<14, "SP">, DwarfRegNum<[14]>;
+def O7 : Ri<15, "O7">, DwarfRegNum<[15]>;
+def L0 : Ri<16, "L0">, DwarfRegNum<[16]>;
+def L1 : Ri<17, "L1">, DwarfRegNum<[17]>;
+def L2 : Ri<18, "L2">, DwarfRegNum<[18]>; 
+def L3 : Ri<19, "L3">, DwarfRegNum<[19]>;
+def L4 : Ri<20, "L4">, DwarfRegNum<[20]>;
+def L5 : Ri<21, "L5">, DwarfRegNum<[21]>; 
+def L6 : Ri<22, "L6">, DwarfRegNum<[22]>;
+def L7 : Ri<23, "L7">, DwarfRegNum<[23]>;
+def I0 : Ri<24, "I0">, DwarfRegNum<[24]>;
+def I1 : Ri<25, "I1">, DwarfRegNum<[25]>;
+def I2 : Ri<26, "I2">, DwarfRegNum<[26]>; 
+def I3 : Ri<27, "I3">, DwarfRegNum<[27]>;
+def I4 : Ri<28, "I4">, DwarfRegNum<[28]>;
+def I5 : Ri<29, "I5">, DwarfRegNum<[29]>; 
+def I6 : Ri<30, "FP">, DwarfRegNum<[30]>;
+def I7 : Ri<31, "I7">, DwarfRegNum<[31]>;
+
+// Floating-point registers
+def F0  : Rf< 0,  "F0">, DwarfRegNum<[32]>;
+def F1  : Rf< 1,  "F1">, DwarfRegNum<[33]>;
+def F2  : Rf< 2,  "F2">, DwarfRegNum<[34]>; 
+def F3  : Rf< 3,  "F3">, DwarfRegNum<[35]>;
+def F4  : Rf< 4,  "F4">, DwarfRegNum<[36]>;
+def F5  : Rf< 5,  "F5">, DwarfRegNum<[37]>; 
+def F6  : Rf< 6,  "F6">, DwarfRegNum<[38]>;
+def F7  : Rf< 7,  "F7">, DwarfRegNum<[39]>;
+def F8  : Rf< 8,  "F8">, DwarfRegNum<[40]>; 
+def F9  : Rf< 9,  "F9">, DwarfRegNum<[41]>;
+def F10 : Rf<10, "F10">, DwarfRegNum<[42]>;
+def F11 : Rf<11, "F11">, DwarfRegNum<[43]>; 
+def F12 : Rf<12, "F12">, DwarfRegNum<[44]>;
+def F13 : Rf<13, "F13">, DwarfRegNum<[45]>;
+def F14 : Rf<14, "F14">, DwarfRegNum<[46]>; 
+def F15 : Rf<15, "F15">, DwarfRegNum<[47]>;
+def F16 : Rf<16, "F16">, DwarfRegNum<[48]>;
+def F17 : Rf<17, "F17">, DwarfRegNum<[49]>; 
+def F18 : Rf<18, "F18">, DwarfRegNum<[50]>;
+def F19 : Rf<19, "F19">, DwarfRegNum<[51]>;
+def F20 : Rf<20, "F20">, DwarfRegNum<[52]>; 
+def F21 : Rf<21, "F21">, DwarfRegNum<[53]>;
+def F22 : Rf<22, "F22">, DwarfRegNum<[54]>;
+def F23 : Rf<23, "F23">, DwarfRegNum<[55]>;
+def F24 : Rf<24, "F24">, DwarfRegNum<[56]>;
+def F25 : Rf<25, "F25">, DwarfRegNum<[57]>;
+def F26 : Rf<26, "F26">, DwarfRegNum<[58]>; 
+def F27 : Rf<27, "F27">, DwarfRegNum<[59]>;
+def F28 : Rf<28, "F28">, DwarfRegNum<[60]>;
+def F29 : Rf<29, "F29">, DwarfRegNum<[61]>; 
+def F30 : Rf<30, "F30">, DwarfRegNum<[62]>;
+def F31 : Rf<31, "F31">, DwarfRegNum<[63]>;
+
+// Aliases of the F* registers used to hold 64-bit fp values (doubles)
+def D0  : Rd< 0,  "F0", [F0,   F1]>, DwarfRegNum<[32]>;
+def D1  : Rd< 2,  "F2", [F2,   F3]>, DwarfRegNum<[34]>; 
+def D2  : Rd< 4,  "F4", [F4,   F5]>, DwarfRegNum<[36]>;
+def D3  : Rd< 6,  "F6", [F6,   F7]>, DwarfRegNum<[38]>; 
+def D4  : Rd< 8,  "F8", [F8,   F9]>, DwarfRegNum<[40]>;
+def D5  : Rd<10, "F10", [F10, F11]>, DwarfRegNum<[42]>;
+def D6  : Rd<12, "F12", [F12, F13]>, DwarfRegNum<[44]>;
+def D7  : Rd<14, "F14", [F14, F15]>, DwarfRegNum<[46]>; 
+def D8  : Rd<16, "F16", [F16, F17]>, DwarfRegNum<[48]>;
+def D9  : Rd<18, "F18", [F18, F19]>, DwarfRegNum<[50]>; 
+def D10 : Rd<20, "F20", [F20, F21]>, DwarfRegNum<[52]>;
+def D11 : Rd<22, "F22", [F22, F23]>, DwarfRegNum<[54]>;
+def D12 : Rd<24, "F24", [F24, F25]>, DwarfRegNum<[56]>;
+def D13 : Rd<26, "F26", [F26, F27]>, DwarfRegNum<[58]>; 
+def D14 : Rd<28, "F28", [F28, F29]>, DwarfRegNum<[60]>;
+def D15 : Rd<30, "F30", [F30, F31]>, DwarfRegNum<[62]>;
+
+// Register classes.
+//
+// FIXME: the register order should be defined in terms of the preferred
+// allocation order...
+//
+def IntRegs : RegisterClass<"CBG", [i32], 32, [L0, L1, L2, L3, L4, L5, L6, L7,
+                                     I0, I1, I2, I3, I4, I5,
+                                     O0, O1, O2, O3, O4, O5, O7,
+
+   // FIXME: G1 reserved for now for large imm generation by frame code.
+                                     G1,
+                                     // Non-allocatable regs:
+                                     G2, G3, G4, // FIXME: OK for use only in
+                                                 // applications, not libraries.
+                                     O6, // stack ptr
+                                     I6, // frame ptr
+                                     I7, // return address
+                                     G0, // constant zero
+                                     G5, G6, G7 // reserved for kernel
+                                     ]> {
+  let MethodProtos = [{
+    iterator allocation_order_end(const MachineFunction &MF) const;
+  }];
+  let MethodBodies = [{
+    IntRegsClass::iterator
+    IntRegsClass::allocation_order_end(const MachineFunction &MF) const {
+      // FIXME: These special regs should be taken out of the regclass!
+      return end()-10  // Don't allocate special registers
+         -1;  // FIXME: G1 reserved for large imm generation by frame code.
+    }
+  }];
+}
+
+def FPRegs : RegisterClass<"CBG", [f32], 32, [F0, F1, F2, F3, F4, F5, F6, F7, F8,
+  F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22,
+  F23, F24, F25, F26, F27, F28, F29, F30, F31]>;
+
+def DFPRegs : RegisterClass<"CBG", [f64], 64, [D0, D1, D2, D3, D4, D5, D6, D7,
+  D8, D9, D10, D11, D12, D13, D14, D15]>;
+
+def HWLOOPRegs : RegisterClass<"CBG", [i32], 32, [HWLOOP1, HWLOOP2, HWLOOP3]>;
+
+def PREDRegs : RegisterClass<"CBG", [i32], 16, [P0, P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P11, P12, P13, P14, P15]>;
+
+def SpecialRegs : RegisterClass<"CBG", [i32], 32, [ICC, Y]>;
diff --git a/lib/Target/cbg/cbgSelectionDAGInfo.cpp b/lib/Target/cbg/cbgSelectionDAGInfo.cpp
new file mode 100644
index 0000000..fe473d6
--- /dev/null
+++ b/lib/Target/cbg/cbgSelectionDAGInfo.cpp
@@ -0,0 +1,23 @@
+//===-- cbgSelectionDAGInfo.cpp - cbg SelectionDAG Info ---------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the cbgSelectionDAGInfo class.
+//
+//===----------------------------------------------------------------------===//
+
+#define DEBUG_TYPE "cbg-selectiondag-info"
+#include "cbgTargetMachine.h"
+using namespace llvm;
+
+cbgSelectionDAGInfo::cbgSelectionDAGInfo(const cbgTargetMachine &TM)
+  : TargetSelectionDAGInfo(TM) {
+}
+
+cbgSelectionDAGInfo::~cbgSelectionDAGInfo() {
+}
diff --git a/lib/Target/cbg/cbgSelectionDAGInfo.h b/lib/Target/cbg/cbgSelectionDAGInfo.h
new file mode 100644
index 0000000..0daf533
--- /dev/null
+++ b/lib/Target/cbg/cbgSelectionDAGInfo.h
@@ -0,0 +1,31 @@
+//===-- cbgSelectionDAGInfo.h - cbg SelectionDAG Info -------*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the cbg subclass for TargetSelectionDAGInfo.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBGSELECTIONDAGINFO_H
+#define CBGSELECTIONDAGINFO_H
+
+#include "llvm/Target/TargetSelectionDAGInfo.h"
+
+namespace llvm {
+
+class cbgTargetMachine;
+
+class cbgSelectionDAGInfo : public TargetSelectionDAGInfo {
+public:
+  explicit cbgSelectionDAGInfo(const cbgTargetMachine &TM);
+  ~cbgSelectionDAGInfo();
+};
+
+}
+
+#endif
diff --git a/lib/Target/cbg/cbgSubtarget.cpp b/lib/Target/cbg/cbgSubtarget.cpp
new file mode 100644
index 0000000..a3b3dea
--- /dev/null
+++ b/lib/Target/cbg/cbgSubtarget.cpp
@@ -0,0 +1,35 @@
+//===- cbgSubtarget.cpp - CBG Subtarget Information -------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements the CBG specific subclass of TargetSubtarget.
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbgSubtarget.h"
+#include "cbgGenSubtarget.inc"
+using namespace llvm;
+
+cbgSubtarget::cbgSubtarget(const std::string &TT, const std::string &FS) :
+    HasSelCC(false),
+    HasMovCC(false),
+    HasPredBlocksCC(false),
+    HasPredBlocksReg(false),
+    HasPredInstrCC(false),
+    HasPredInstrReg(false),
+    HasHWLoop(false),
+    HasHWLoops(false),
+    HasVLIWIfElse(false),
+    HasHWLoopOpt(false) {
+  
+  // Determine default and user specified characteristics
+  const char *CPU = "v8";
+
+  // Parse features string.
+  ParseSubtargetFeatures(FS, CPU);
+}
diff --git a/lib/Target/cbg/cbgSubtarget.h b/lib/Target/cbg/cbgSubtarget.h
new file mode 100644
index 0000000..fb2ebd0
--- /dev/null
+++ b/lib/Target/cbg/cbgSubtarget.h
@@ -0,0 +1,66 @@
+//=====-- cbgSubtarget.h - Define Subtarget for the CBG ----*- C++ -*-====//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the CBG specific subclass of TargetSubtarget.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBG_SUBTARGET_H
+#define CBG_SUBTARGET_H
+
+#include "llvm/Target/TargetSubtarget.h"
+#include <string>
+
+namespace llvm {
+
+class cbgSubtarget : public TargetSubtarget {
+  bool HasSelCC;        // target supports selCC instructions
+  bool HasMovCC;        // target supports movCC instructions
+  bool HasPredBlocksCC; // target supports predicated blocks with condition codes
+  bool HasPredBlocksReg;// target supports predicated blocks
+                        // with own predicate register
+  bool HasPredInstrCC;  // target supports fully predicated instructions with
+                        // condition codes
+  bool HasPredInstrReg; // target supports fully predicated instructions with
+                        // own predicate register
+  bool HasHWLoop;       // target provides hardware support for single loop
+  bool HasHWLoops;      // target provides hardware support for nested loops
+  bool HasVLIWIfElse;   // target provides hardware support for concurrent
+                        // execution of if and else branch
+  bool HasHWLoopOpt;    // compiler does not optimize hardware loop assembler code
+  
+public:
+  cbgSubtarget(const std::string &TT, const std::string &FS);
+
+  bool hasSelCC() const { return HasSelCC; }
+  bool hasMovCC() const { return HasMovCC; }
+  bool hasPredBlocksCC() const { return HasPredBlocksCC; }
+  bool hasPredBlocksReg() const { return HasPredBlocksReg; }
+  bool hasPredInstrCC() const { return HasPredInstrCC; }
+  bool hasPredInstrReg() const { return HasPredInstrReg; }
+  bool hasHWLoop() const { return HasHWLoop; }
+  bool hasHWLoops() const { return HasHWLoops; }
+  bool hasHWLoopOpt() const {return HasHWLoopOpt; }
+  bool hasVLIWIfElse() const { return HasVLIWIfElse; }
+  
+  /// ParseSubtargetFeatures - Parses features string setting specified 
+  /// subtarget options.  Definition of function is auto generated by tblgen.
+  std::string ParseSubtargetFeatures(const std::string &FS,
+                                     const std::string &CPU);
+  
+  std::string getDataLayout() const {
+    const char *p;
+    p = "E-p:32:32:32-i64:64:64-f64:64:64-f128:64:64-n32";
+    return std::string(p);
+  }
+};
+
+} // end namespace llvm
+
+#endif
diff --git a/lib/Target/cbg/cbgTargetMachine.cpp b/lib/Target/cbg/cbgTargetMachine.cpp
new file mode 100644
index 0000000..b1e6480
--- /dev/null
+++ b/lib/Target/cbg/cbgTargetMachine.cpp
@@ -0,0 +1,78 @@
+//===-- cbgTargetMachine.cpp - Define TargetMachine for cbg -----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+//
+//===----------------------------------------------------------------------===//
+
+#include "cbg.h"
+#include "cbgMCAsmInfo.h"
+#include "cbgTargetMachine.h"
+#include "llvm/PassManager.h"
+#include "llvm/Analysis/LoopPass.h"
+#include "llvm/Target/TargetRegistry.h"
+
+using namespace llvm;
+
+extern "C" void LLVMInitializecbgTarget() {
+  // Register the target.
+  RegisterTargetMachine<cbgV8TargetMachine> X(ThecbgTarget);
+
+  RegisterAsmInfo<cbgELFMCAsmInfo> A(ThecbgTarget);
+}
+
+/// cbgTargetMachine ctor - Create an ILP32 architecture model
+///
+cbgTargetMachine::cbgTargetMachine(const Target &T, const std::string &TT, 
+                                   const std::string &FS)
+  : LLVMTargetMachine(T, TT),
+    Subtarget(TT, FS),
+    DataLayout(Subtarget.getDataLayout()),
+    TLInfo(*this), TSInfo(*this), InstrInfo(Subtarget),
+    FrameLowering(Subtarget) {
+}
+
+bool cbgTargetMachine::addInstSelector(PassManagerBase &PM,
+                                       CodeGenOpt::Level OptLevel) {
+  PM.add(createcbgISelDag(*this));
+  return false;
+}
+
+/// addPreEmitPass - This pass may be implemented by targets that want to run
+/// passes immediately before machine code is emitted.  This should return
+/// true if -print-machineinstrs should print out the code after the passes.
+bool cbgTargetMachine::addPreEmitPass(PassManagerBase &PM,
+                                      CodeGenOpt::Level OptLevel){
+
+  if (Subtarget.hasPredBlocksCC()) {
+    PM.add(createcbgPredBlockCCPass(*this));
+  } else if (Subtarget.hasPredBlocksReg()) {
+    PM.add(createcbgPredBlockRegPass(*this));
+  } else if (Subtarget.hasPredInstrCC()) {
+    PM.add(createcbgPredInstrCCPass(*this));
+  } else if (Subtarget.hasPredInstrReg()) {
+    PM.add(createcbgPredInstrRegPass(*this));
+  }
+
+  if (Subtarget.hasHWLoop()) {
+    PM.add(createcbgHWLoopPass(*this, 1, Subtarget.hasHWLoopOpt()));
+  } else if (Subtarget.hasHWLoops()) {
+    PM.add(createcbgHWLoopPass(*this, 2, Subtarget.hasHWLoopOpt()));
+  }
+
+  PM.add(createcbgFPMoverPass(*this));
+  PM.add(createcbgDelaySlotFillerPass(*this));
+
+  return true;
+}
+
+cbgV8TargetMachine::cbgV8TargetMachine(const Target &T,
+                                       const std::string &TT,
+                                       const std::string &FS)
+  : cbgTargetMachine(T, TT, FS) {
+}
diff --git a/lib/Target/cbg/cbgTargetMachine.h b/lib/Target/cbg/cbgTargetMachine.h
new file mode 100644
index 0000000..71b65e0
--- /dev/null
+++ b/lib/Target/cbg/cbgTargetMachine.h
@@ -0,0 +1,78 @@
+//===-- cbgTargetMachine.h - Define TargetMachine for cbg ---*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the cbg specific subclass of TargetMachine.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef CBGTARGETMACHINE_H
+#define CBGTARGETMACHINE_H
+
+#include "cbgInstrInfo.h"
+#include "cbgISelLowering.h"
+#include "cbgFrameLowering.h"
+#include "cbgSelectionDAGInfo.h"
+#include "cbgSubtarget.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetData.h"
+#include "llvm/Target/TargetFrameLowering.h"
+
+namespace llvm {
+
+class cbgTargetMachine : public LLVMTargetMachine {
+  cbgSubtarget Subtarget;
+  const TargetData DataLayout;       // Calculates type size & alignment
+  cbgTargetLowering TLInfo;
+  cbgSelectionDAGInfo TSInfo;
+  cbgInstrInfo InstrInfo;
+  cbgFrameLowering FrameLowering;
+public:
+  cbgTargetMachine(const Target &T, const std::string &TT,
+                     const std::string &FS);
+
+  virtual const cbgInstrInfo *getInstrInfo() const { return &InstrInfo; }
+  virtual const TargetFrameLowering  *getFrameLowering() const {
+    return &FrameLowering;
+  }
+  virtual const cbgSubtarget   *getSubtargetImpl() const{ return &Subtarget; }
+  virtual const cbgRegisterInfo *getRegisterInfo() const {
+    return &InstrInfo.getRegisterInfo();
+  }
+  virtual const cbgTargetLowering* getTargetLowering() const {
+    return &TLInfo;
+  }
+  virtual const cbgSelectionDAGInfo* getSelectionDAGInfo() const {
+    return &TSInfo;
+  }
+  virtual const TargetData       *getTargetData() const { return &DataLayout; }
+
+  /*virtual bool addPassesToEmitFile(PassManagerBase &PM,
+                                   formatted_raw_ostream &Out,
+                                   CodeGenFileType FileType,
+                                   CodeGenOpt::Level,
+                                   bool DisableVerify = true);
+
+  virtual bool addPreISel(PassManagerBase &PM, CodeGenOpt::Level OptLevel);*/
+  // Pass Pipeline Configuration
+  virtual bool addInstSelector(PassManagerBase &PM, CodeGenOpt::Level OptLevel);
+  virtual bool addPreEmitPass(PassManagerBase &PM, CodeGenOpt::Level OptLevel);
+
+};
+
+/// cbgV8TargetMachine - cbg 32-bit target machine
+///
+class cbgV8TargetMachine : public cbgTargetMachine {
+public:
+  cbgV8TargetMachine(const Target &T, const std::string &TT,
+                       const std::string &FS);
+};
+
+} // end namespace llvm
+
+#endif
-- 
1.7.0.4

